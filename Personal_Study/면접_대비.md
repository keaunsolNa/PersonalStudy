# 면접 대비

# JAVA

- JAVA
    - 자바의 특징 혹은 자바 언어의 장점
        - 자바의 가장 대표적인 특징은 JVM이라고 할 수 있다. JVM은 Java virtual machine의 약자로 OS에 종속받지 않고 CPU가 Java를 인식, 실행시킬 수 있는 가상 머신이다.
        - JVM이 OS에 비 종속적으로 가동하기에, Java Compiler가 .java 파일을 .class파일로 Compile 시,  Java byte code로 Compile이 이루어진다. 이후 Interpreter를 통해 변환된 byte Code를 운영체제가 인식할 수 있다. 즉, 운영체제에 상관 없이 이식 가능하다. 
        → Java가 인터프리터인 동시에 컴파일러인 이유
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled.png)
        
        - 멀티 스레드 환경을 제공한다.
        - 단일 상속만을 허용한다.
    - 변수란 무엇이며, 변수의 종류는 어떠한 것이 있나
        - 변수란 하나의 값을 저장할 수 있는 저장공간이라고 할 수 있다.
        - 변수의 종류는 원시형(기본형,  Primitive Type)과 참조형(Reference Type) 변수가 있다.
        - Java의 원시형 변수는 정수형(byte, short, int, long), 실수형(float, double), 문자형(char), 논리형(boolean)의 8가지가 있다.
        - 참조형 변수는 8개의 기본형 변수를 사용하여 사용자가 직접 만들어 사용하는 변수를 의미한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%201.png)
            
    - 변수의 명명 규칙, 자바의 네이밍 규칙
        - 변수의 명명 규칙은 지정 시 컴파일 에러가 발생하는 규칙이며, 네이밍 규칙은 컴파일 에러가 발생하지는 않지만 유지보수성을 위해 암묵적으로 정의한 규칙을 의미한다.
        - 변수의 명명 규칙은 
        1. 동일한 범위 내에서 동일한 변수명을 가질 수 없다.
        2. 예약어 사용이 불가능하다.
        3. 대/소문자를 구분한다.
        4. 숫자로 시작할 수 없다.
        5. 특수문자는 ‘_’와 ‘$’만을 허용한다.
        의 5가지가 있다.
        - 자바의 네이밍 규칙은 
        1. 길이의 제한은 없지만 적당한 길이의 변수명을 사용하라.
        2. 합성어일 경우 Camel-Case를 사용하라.
        3. 단어와 단어 사이 언더스코어(_)를 사용하지 말 것.
        4. 한글로 변수명을 짓는 것은 지양하라.
        5. 변수 안에 저장된 값이 어떤 의미를 가지는지 알 수 있도록 이름을 짓는다.
        6. 전형적인 변수명(sum, bNum 등)이 있으면 가급적 사용한다.
        7. 명사형으로 작성한다.
        8. boolean형은 의문문으로 작성하되, 가급적이면 긍정형으로 네이밍한다.
        등이 있다.
    - 변수를 사용하는 목적이 무엇인가
        - 변수를 지정하지 않을 경우 Literal 값이 길어질 수록 인식이 힘들어진다. 즉, 가독성과 재사용성 증가로 인한 유지보수성의 난해함을 줄이는 것. 곧 추상화가 그 목적이다.
    - 객체 지향 언어란 무엇인가
        - 적절한 책임을 수행하는 객체들간의 유연하고 견고한 협력이다.
        - 객체 지향 언어는 접근 제한자를 통한 캡슐화와 단일 책임의 원칙을 통해 적절한 책임을 가수행한다.
        - 객체 지향 언어는 다형성과 상속을 통해 유연하고 견고한 협력을 수행한다.
    - 객체란 무엇인가
        - 변수, 데이터 구조, 함수, 메서드가 될 수 있으며 식별자가 참조하는 메모리의 값이다.  객체 지향 프로그래밍에서의 객체는 클래스의 인스턴스다.
    - 객체지향의 4대 원칙
        - 3대 원칙으로는 상속, 다형성, 캡슐화가 있다. 여기에 추상화를 더 해 4대 원칙으로 불리기도 한다.
    - 캡슐화란 무엇인가
        - 객체의 속성(data fields)과 행위(methods)를 하나로 묶고, 실제 구현 내용 일부를 내부에 감추어 은닉하는 기술.
        - 자바는 접근 제어자를 통해 캡슐화를 지원한다.
    - 상속이란 무엇인가
        - 부모 클래스가 가지는 Member, Type을 자식 클래스가 물려 받아 자신의 Member, Type인 것 처럼 사용할 수 있게 하는 기술이다.
        - C##과는 달리 자바는 단일 상속만을 지원한다.
        - 자식 클래스가 부모 클래스를 선택(지향)한다.
    - 다형성이란 무엇인가
        - 다양한 객체들(상수, 변수, 식, 객체, 메소드 등)이 하나의 자료형(type)에 속하는 것.
        - 유지보수를 위한 대표적인 타입 은닉 기술이다.
        - 송신자와 수신자 간의 객체 타입에 대한 결합도를 메시지에 대한 결합도를 낮춤으로서 달성한다.
    - 추상화란 무엇인가
        - 현실 세계의 복잡함을 일반화와 특수화를 통해 단순하게 만드는 기법이다.
    - 클래스와 객체의 차이점은 무엇인가
        - 객체가 식별자가 참조하는 메모리의 값이라면, 클래스는 객체를 정의하는 틀 또는 설계도와 같은 의미로 사용된다.
        - 인스턴스를 포함하여 비유하자면, 인스턴스는 실체를 가진 핸드폰, 객체는 핸드폰의 이름, 개념. 클래스는 핸드폰을 만들기 위한 설계도라 비유할 수 있다.
    - 객체 지향 언어의 장점은 무엇인가
        - 객체 지향 언어의 대표적인 장점은 3가지 정도가 있다.
        
        1. 소프트웨어의 생상선 향상 : 신뢰성, 재사용성, 쉬운 업그레이드, 쉬운 디버깅 
        2. 실세계에 대한 쉬운 모델링 
        3. 보안성 향상 : 접근제한자를 통한 캡슐화, 데이터 은닉, 다형성
    - 클래스에 사용 가능한 접근제한자와 키워드가 무엇이 있나(의미도 함께)
        - Public, default가 있다.
        - Public은 동일한 프로젝트의 모든 클래스, 필드, 생성자, 메소드에 접근이 가능하며, 모든 패키지에서 호출이 가능한 접근 제어자이다.
        - default는 같은 패키지인 클래스에서만 접근 가능하며, 같은 패키지의 클래스에서만 호출 가능하다. 또한, default의 경우 public, private 등의 다른 접근 제어자와 달리 Class 내부에선 defautl라는 캡슐명을 선언하지 않는다.
    - 생성자에 사용 가능한 접근제한자와 키워드
        - public, protected, default, private 모두 사용 가능하다.
        - protected는 같은 패키지의 클래스 또는 자식 클래스에서만 접근 및 호출이 가능한 접근제어자이다.
        - private는 모든 외부에서 접근 및 객체 생성이 불가능한 접근제어자이다.
    - 필드에 사용 가능한 접근제한자와 키워드
        - public, protected, default, private 모두 사용 가능하다.
    - 메소드에 사용 가능한 접근제한자와 키워드
        - public, protected, default, private 모두 사용 가능하다.
    - final 키워드의 사용 가능 위치와 그 의미
        - 필드, 객체, 클래스 메서드, 메서드의 인자값에 사용 가능하다. 각각의 위치에 따라 의미가 다르다.
        - final field의 경우, 다른 참조값을 지정할 수 없는 변경 불가능한 변수로서의 의미를 가진다. 필드 선언시 non static final field의 경우 생성자를 통한 초기화가 가능하지만 static final field의 경우 생성자를 이용한 초기화가 불가능하며 선언과 동시에 초기화만 가능하다.
        - final object의 경우 다른 참조값을 지정할 수 없는 변수로서의 의미를 가진다. 즉, 한 번 생성한 final 객체는 같은 타입으로 재생성이 불가능한 싱글턴 패턴을 가진다. 단, 객체 자체는 변경 불가능하지만 객체 내부의 변수는 변경 가능하다.
        - final class의 경우 더 이상 상속이 불가능한 class로서의 의미를 가진다. 필드 자체는 Setter 함수를 통해 변경은 가능하다.
        - final method의 경우 상속받은 클래스에서 부모의 final method를 재정의(Override) 할 수 없는 method로서의 의미를 가진다.
        - method의 argument 값으로 사용 시 변경 불가능한 argument 값으로서의 의미를 가진다.
    - 오버로딩이 무엇인가
        - parameter의 타입, 개수, 순서. 즉 Signature를 다르게 함으로서 동일한 메소드명을 사용 가능하게 하는 기술이다.
        - parameter의 종류별로 method의 내용을 다르게 작성해야 하는 경우, 동일한 이름으로 여러 메소드를 관리하기 위해 사용된다.
    - 오버로딩의 성립 요건이 무엇인가
        - Method의 이름은 동일하되, Method의 Signature는 달라야 한다.
    - 오버라이딩이 무엇인가
        - 부모(상위)클래스에서 상속받은 메소드를 자식(하위)클래스가 사용하거나, 재정의하여 사용하는 것.
    - 오버라이딩과 성립 요건이 무엇인가
        - 메소드 이름이 동일해야 한다.
        - 메소드 리턴 타입이 동일해야 한다.
        - 매개변수의 Signature가 동일해야 한다.
        - private 메소드는 오버라이딩 할 수 없다.
        - final 키워드가 사용된 메소드는 오버라이딩 할 수 없다.
        - 접근제한자는 부모 메소드와 같거나 더 넓은 범위어야 한다.
        - 예외처리는 같은 예외이거나 더 하위의 예외를 처리해야 한다.
    - 오버로딩과 오버라이딩의 차이에 대해 전체적으로 설명
        - 오버로딩은 Signature를 다르게 함으로서 동일한 메소드명을 사용 가능하게 하는 기술이며, 오버라이딩은 Signature를 동일하게 함으로서 부모 클래스의 메소드를 재정의하여 사용하는 기술이다.
        - 오버로딩은 메소드의 이름을 통일함으로서 가독성을 높이는데 그 목적이 있으며, 오버라이딩은 다형성을 활용하여 상속받은 부모클래스의 메소드를 자식클래스에서 재정의하여 사용하는 것에 그 목적이 있다.
    - 변수의 선언 위치에 따른 변수 종류와 메모리 할당 위치
        - 변수의 선언 위치에 따른 종류는 인스턴스 변수, 클래스(static, 공유) 변수, 지역 변수의 3가지가 있다.
        - class 영역 안에 생성된 인스턴스 변수와 클래스 변수는 멤버 변수라고 불리기도 한다.
        - 변수의 종류와 선언 위치, 생성 시기는 아래와 같다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%202.png)
            
        - 각 변수의 메모리 할당 위치는 아래와 같다. ( 순서대로 static, stack, heap)
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%203.png)
            
    - static 키워드의 의미와 라이프 사이클
        - Heap이나 Stack 영역이 아닌 Static 영역에서 변수를 관리하고 싶을 때 사용한다. Stack 영역에서 Garbage Collector(GC)의 관리를 받는 레퍼런스 변수와 달리, Stack 영역에 할당된 Static 변수, Static 클래스(Class Member, Static Member) 는 GC의 관리를 받지 않으며 프로그램이 종료되기 전까지 Static 영역에 메모리를 할당받은 채로 유지된다.
    - 매개변수로 가변인자 매개변수 설정하는 방법
        - 가변 인자(Varargs)는 매개변수 선언 시 전달되는 인자의 수에 제한을 두지 않고 동적으로 받으려고 할 때 사용한다.
        - 가변인자를 나타내는 기호(…)을 사용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%204.png)
            
        - PS. 하나가 아닌 여러 개의 매개변수를 받을 때는 ,를 사용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%205.png)
            
    - return 이란?
        - return은 파라미터를 전달한 메소드에게 반환하는 값이다.  즉, 메서드의 실행 결과값이며, void 타입이 아닌 메서드의 반환 값이다. 반복, 조건문 안에서 실행 시에는 즉시 반복, 조건문을 종료하고 파라미터를 전달한 메소드에게 결과값을 반환하라는 의미를 가진다.
    - 매개변수와 인자의 차이
        - 각각 Parameter와 Argument.
        - Parameter : 메소드의 정의 부분에 나열되어 있는 변수(Variable).
        - Argument : 함수를 호출할 때 전달되는 실제 값(Value).
    - 자바에서 메소드의 호출 방식과 자료구조, 해당 자료구조의 특징
        - 자바에서 메소드의 호출 방식은 변수의 값을 넘기는 Call by Value 방식으로 이루어진다. 
        → PS. 프로그래밍 언어에서의 메소드 호출 방식은 그 외에도 Call by Reference, Call by Name, Call by Assignment 등이 있다.
        - Call by Value : 값을 호출하는 것이며, 전달받은 값을 복사하여 처리한다. 즉, 전달받은 값을 변경하여도 원본은 변경되지 않는다.
        - 즉, 기본(원시, Primitive Type) 자료형의 경우 자바의 Call by Value 방식은 값을 넘겨받은 메소드에서 값을 복사하여 새로운 지역 변수에 저장한다. Method1에서 Method2로 값을 넘겼을 때, Method2는 Method1의 변수를 사용한 것이 아닌, 자신이 새롭게 생성한 지역변수에 Method1의 변수 이름과 변수 값을 복사하여 사용하는 것이다.
        - 참조 자료형의 경우 역시 Call by Value 방식이다. 단, 참조 자료형의 경우 값이 변경되는데, 이는 참조 자료형이 Heap Memory에 생성된 객체의 주소값을 참조하는 변수이기 때문이다. 즉, 변수의 값이 아닌 참조 자료형이 참조하고 있는 주소의 값을 넘겼기에 값이 수정되는 것이다. (Call by Reference 방식이 아니다.)
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%206.png)
            
        - 그렇기에, 참조 자료형의 경우 역시 method2에서 method1에서 전달받은 값을 new 연산자를 사용하여 새로운 키워드를 생성, 해당 주소를 참조했을 경우에는 Method1의 참조 자료형의 값이 변경되지 않는다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%207.png)
            
        - 추가로 Heap 영역의 특징으로는 아래의 3가지가 있다.
        → JVM 프로세스에 단 하나의 Heap영역만 존재하고 여러 Thread와 공유가 가능하다. 
        → new 키워드로 생성된 Reference Type의 값이 생성 되어있다.
        → GC에 의해 메모리가 관리된다.
    - package란 무엇인가
        - Class와 Interface의 집합이다.
        - 서로 관련있는 클래스나 Interface를 하나로 묶음으로서 파일을 효율적으로 관리하는데 그 목적이 있다.
        - 물리적으로 하나의 디렉토리(Directory)를 의미한다.
        - 패키지는 상위 패키지에 하위 패키지가 포함될 수 있으며, 디렉토리의 계층 구조는 점(.)으로 구분한다. 
        → ex) java.lang.String
    - import란 무엇인가
        - 자바 컴파일러에 코드에서 사용할 클래스의 패키지에 대한 정보를 미리 제공하는 역할을 한다.
        - 타 패키지의 클래스를 사용할 경우, 해당 클래스의 디렉토리를 매번 명시해야 하지만 Import 사용 시 그 불편함을 줄일 수 있다.
    - 상속을 사용하는 목적이 무엇인가
        - 연관된 일련의 클래스에 대한 공통적인 규약을 정의하고 적용하는 것.
    - 상속의 장점
        - 유지보수가 쉬워지고, 확장성이 용이해지며, 재사용이 가능해지고 코드가 간결해진다.
    - 상속의 특징
        - Java에서는 클래스의 다중 상속을 지원하지 않는다.
        - Java에서는 상속의 횟수에 제한을 두지 않는다.
        - Java에서는 계층구조의 최상위에 Java.lang.Object Class가 있다. 즉, Java의 모든 클래스는 Object 클래스를 상속받도록 되어 있다.
    - 다형성의 장점
        - 코드의 결합도를 낮춤으로서 느슨한 결합을 이룰 수 있다.
        - 여러 타입의 객체를 하나의 타입으로 관리함으로서 유지보수성을 높인다.
        - 오버로딩을 통해 코드의 가독성을 높일 수 있다.
        - 오버라이딩을 통해 구현 편의성을 높일 수 있다.
    - 동적바인딩이란
        - 컴파일 당시에는 해당 타입의 메소드와 연결(Binding)되어 있다가(정적 바인딩) 런타임 시 실제 객체가 가진 오버라이딩 된 메소드로 바인딩이 바뀌어 동작하는 것.
        - 다형성을 사용하여 메소드를 호출할 때 발생한다.
        - 실제 참조하는 객체를 호출한다.
    - 동적바인딩 성립 요건
        - 상속 관계로 이루어져 다형성이 적용된 경우, 메소드 오버라이딩이 되어있을 때.
    - 추상클래스란 무엇인가
        - 0개 이상의 추상 메소드를 포함하는 클래스.
        - 실체 클래스(객체를 직접 생성할 수 있는 클래스)의 공통적인 부분을 추출해 어느정도 규격을 잡아놓은 추상적인 클래스.
    - 추상클래스의 특징
        - 객체, 인스턴스를 생성할 수 없다.
        - 실체 클래스를 상속받는다.
        - abstract 키워드를 통해 구현한다.
        - 추상 클래스를 상속받은 클래스는 추상 클래스가 가지고 있는 추상 메소드를 반드시 구현(Overriding) 해야 한다.
        → 구현하지 않으면 해당 클래스도 추상 클래스가 된다.
    - 추상클래스의 사용 목적
        - 추상 메소드가 포함된 클래스를 상속받는 자식 클래스가 반드시 구현하도록 제약할 수 있다.
        - 공통된 필드와 메서드를 통일하여 유지보수성을 높이고 통일성을 유지할 수 있다.
        - 실체 클래스에서 상속받은 규약에 맞는 실체 클래스를 구현할 수 있다.
        - 실체 클래스를 구현할 때 시간을 절약할 수 있다.
        - OCP(Open-Closed-Principle) 원칙을 지킬 수 있다.
    - 추상클래스의 장점
        - 상속을 통해 중복 코드를 줄일 수 있다.
        - 공통 사항을 한 곳에서 관리함으로서 개발 및 유지보수에 유리하다.
    - 인터페이스란 무엇인가
        - 추상 메소드와(java 8 이후 메소드 Signature 가능) 상수 필드만 가질 수 있는 클래스의 변형체
    - 인터페이스의 특징
        - 인터페이스 영역의 메소드는 추상 메소드만 사용할 수 있다.
        - 생략 시 묵시적으로 public abstract의 형식을 가진다.
        - implements 키워드를 통해 클래스에서 인터페이스를 구현한다.
    - 인터페이스의 사용 목적
        - 자바의 다형성을 극대화하여 개발코드 수정을 줄이고 프로그램 유지보수성을 높이기 위해 사용한다.
        - 필요한 기능을 공통화(표준화) 해서 강제성을 부여하기 위해 사용한다.
    - 인터페이스의 장점
        - 자바의 단일 상속의 단점을 극복했다.
        - 개방 폐쇄 법칙을 통한 클래스간 결합도를 낮춘 프로그래밍이 가능해진다.
    - 추상클래스와 인터페이스 정리
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%208.png)
        
    - String과 Stringbuilder의 차이점
        - String은 불변(immutable)의 속성을 가진다. 
        → 동일한 변수명에 재정의 시, 새로운 메모리 영역을 참조하게 되고 최초 메모리 영역은 GC에 의해 사라진다. 
        → 즉, String 클래스는 불변하기에 문자열을 수정하는 시점에 새로운 String 인스턴스가 생성된 것.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%209.png)
            
        - 문자열 추가, 수정, 삭제 등의 연산이 빈번하게 발생하는 알고리즘에 String 클래스 사용 시 힙 메모리에 많은 양의 Garbage가 생성되어 성능에 악영향을 미친다.
        - StringBuffer(StringBuilder)는 가변(mutable)성을 가진다.
        - .append(), .delete()를 통해 동일 객체 내에서 문자열을 변경할 수 있다. 
        → 문자열의 추가, 수정, 삭제가 빈번하게 발생할 경우 String이 아닌 StringBuffer, StringBuilder를 사용해야 한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2010.png)
            
    - StringBuffer와 StringBuilder의 차이점
        - StringBuffer와 StringBuilder의 가장 큰 차이점은 동기화의 유무에 있다.
        - StringBuffer는 동기화 키워드를 지원하여 멀티 쓰레드 환경에서 안전(Thread-safe) 하다. 
        → Strin도 불변성을 가지기에 Thread-safe를 가지고 있다.
        - 반면 StringBuilder는 동기화를 지원하지 않기에 멀티 쓰레드 환경에서 사용하기에는 적합하지 않다. 단, 동기화를 고려하지 않는 만큼 단일 쓰레드에서의 성능은 StringBuffer보다 뛰어나다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2011.png)
            
    - Wrapper 클래스란?
        - 8가지 기본 타입의 데이터를 인스턴스화 할 수 있도록 하는 클래스.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2012.png)
            
        - Wrapper 클래스로 감싸고 있는 기본 타입의 값은 외부에서 변경할 수 없다. (변경하려면 새로운 Wrapper 객체를 만들어야 한다.)
        - 이 때 기본 자료형을 wrapper class로 변환하는 과정을 Boxing, 그 반대의 과정을 UnBoxing이라고 한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2013.png)
            
        - PS. 레퍼 객체는 내부의 값을 비교하기 위해 == 연산자를 사용할 수 없다. .equals를 사용해야 한다. (참조 변수간 비교)
    - autoboxing과 autounboxing이란
        - 직접 Boxing과 UnBoxing을 하지 않아도 자동으로 Boxing과 UnBoxing이 일어나는 경우를 의미한다.
        - 자동 박싱의 포장 클래스 타입에 기본값이 대입될 경우에 발생한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2014.png)
            
        
    - String을 기본자료형으로 바꾸는 방법
        - Wrapper 클래스로 객체를 생성할 때 생성자의 매개변수에 String 데이터를 넘겨준 뒤, 생성된 객체를 기본 자료형으로 언박싱하는 방법.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2015.png)
            
        - Wrapper 클래스에서 지원하는 정적 메소드 parse기본자료형(문자열) 을 사용하는 방법
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2016.png)
            
    - 기본자료형을 문자열로 바꾸는 방법
        - 기본 자료형을 래퍼 클래스로 박싱 후 레퍼 클래스의 메소드인 toString()으로 변환하는 방법
        - 레퍼 클래스의 정적 메소드인 toString(기본 자료형 데이터)를 이용하는 방법.
        - String 클래스의 정적 메소드인 valueOf(기본자료형 데이터)를 이용하는 방법.
        - 기본 자료형의 데이터와 아무 내용이 없는 “”를 결합하는 방법.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2017.png)
            
    - java.util.Date, java.sql.Date, Calendar, GregorianCalendar
        - [Java.util.Date](http://Java.util.Date) 는 시/분/초를 포함한다. 1970년 1월 1일 00:00:00 GMT 이후의 특정 시점을 millisecond 단위로 나타낸다.
        - [java.sql.Date](http://java.sql.Date) 는 시/분/초를 포함하지 않는다.  [java.util.Date](http://java.util.Date) 클래스를 상속한다. SQL 데이터를 다루기 위함에 목적이 있다. (DB를 다룰 때 주로 사용한다.)
        → 시간 정보를 유지하지 않으므로, 로컬 환경과 DB 간의 시간 변환은 JDBC 드라이버의 구현에 따라 다르다.
        - Calendar 클래스는 abstract 클래스이기에 인스턴스 생성이 불가능하다. 
        → Calendar.getinstance() 메소드나 Calendar 클래스를 상속받는 GregorianCalendar 클래스를 이용하여 객체를 생성한다.
        - Calendar 클래스의 주요 상수
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2018.png)
            
        - Calendar 클래스의 주요 메소드
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2019.png)
            
        - GregorianCalendar 클래스는 Calendar 클래스를 상속받은 클래스다. 
        → Calendar에서 고려하지 않은 윤초(leap second)와 같은 특별한 상황을 위해 사용한다.
        → Calendar에서 월(month)를 나타낼때 1~12가 아닌 0~11로 표현해야 하는 불편함을 해소할 수 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2020.png)
            
    - 예외처리를 하는 목적
        - 실행 중인 프로그램의 비정상적인 종료를 막고, 상태를 정상상태로 유지시키는 것이 목적이다.
    - Stream 종류
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2021.png)
        
        - Stream은 객체 요소를 처리하는 스트림이다.
        - IntStream, LongStream, DoubleStream.은 기본 타입인 int, Long, Double 요소를 처리하는 스트림이다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2022.png)
        
        - FileInputStream : 시스템의 파일에서 입력 바이트를 얻기 위해 사용한다.
        - BufferedInputStream : 바이트 기반 입력 스트림에 연결되어 버퍼를 제공하는 보조 스트림
        - DateInputStream : 데이터를 자료형 별로 처리하는 기능을 추가한 보조 스트림
        - ObjectInputStream : 객체 단위로 입력을 하기 위한 스트림
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2023.png)
        
        - FileOutputStream : 프로그램의 데이터를 파일로 내보내기 위한 용도의 스트림. 1바이트 단위로 데이터를 처리한다.
        - BufferedOutputStream : 바이트 기반 출력 스트림에 연결되어 버퍼를 제공해주는 보조 스트림
        - DataOutputStream : 데이터를 자료형 별로 처리하는 기능을 추가한 보조스트림, 기본 자료형을 출력할 수 있다.
        - ObjectOutputStream : 객체 단위로 출력을 하기 위한 스트림
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2024.png)
            
        - FileReader : FileInputStream과 사용 방법이 거의 동일하나 byte 단위가 아닌 character 단위로 인지하고 읽어들인다. 즉, 한글과 같은 문자열도 읽어올 수 있다.
        - InputStreamReader : 바이트 기반 입력 스트림에 연결되어 문자 입력 스트림읜 Reader로 반환하는 보조 스트림
        - BufferedReader : 문자 기반 입력 스트림에 연결되어 버퍼를 제공하는 보조 스트림.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2025.png)
        
        - FileWirter : 프로그램의 데이터를 파일로 내보내기 위한 용도의 스트림으로 바이트가 아닌 문자열 단위로 이루어진다.
        - OutputStreamWriter : 바이트 기반 출력 스트림에 연결되어 문자 출력 스트림인 Wirter로 변환하는 보조 스트림.
        - BufferedWirter : 문자 기반 출력 스트림에 연결되어 버퍼를 제공해주는 보조 스트림
        - PrintWriter : System.out.print 의 기능을 수행한다. 연결할 출력 스트림을 생성자의 매개값으로 받는다.
    - 자료 구조를 사용하는 이유
        - 자료 구조는 데이터를 효율적으로 저장, 관리하고 메모리를 절약하거나 실행시간을 단축시키는 등에 그 목적이 있다.
        - 대부분의 자료 구조는 특정한 상황에 특화되어 있어 특정 상황에 맞는 최적의 자료구조를 사용 시 성능 향상에 큰 도움이 된다.
    - List계열과 Set계열의 특징
        - List 계열은 순서가 있는 Collection이기에 List에 데이터를 넣는 순서가 보장된다. 
        → index를 통해 특정 아이템을 가져올 수 있다.
        → 중복된 Item을 List에 추가할 수 있다. 
        → List의 contains 실행 속도는 O(n)으로 Set에 비해 느리다. 
        → 선형 자료구조로 이루어져있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2026.png)
            
        - Set 계열은 순서를 보장하지 않는 Collection이기에 데이터를 넣는 순서가 보장되지 않는다. 
        → index를 통해 특정 아이템을 가져올 수 없다.
        —> 단, Set의 구현 방식에 따라 달라질 수 있다.
        → 중복된 Item을 허용하지 않기에 중복 데이터를 추가하려고 하면 무시된다. 
        → Set의 Contains 실행 속도는 O(1)로 빠르다. 즉, 탐색이 잦다면 Set을 고려할 수 있다.
            
            ![제목 없음.png](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/%25EC%25A0%259C%25EB%25AA%25A9_%25EC%2597%2586%25EC%259D%258C.png)
            
    - Map 계열의 특징
        - Key-value pair 형식을 가지고 있다.  key와 value는 모두 인스턴스다.
        - 특정 데이터를 탐색 시 Key를 이용하여 검색한다.
        - Key는 중복 저장을 허용하지 않으며, 값은 중복 저장을 허용한다.
        - Key 값이 중복될 경우, Set과 달리 새로운 데이터를 무시하는 것이 아닌 기존 데이터에 새로운 데이터를 덮어 쓴다.
        - Map은 Interface로 선언되어 있으며, Map을 구현한 여러 클래스들을 통해 사용한다.
            
            ![제목 없음.png](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/%25EC%25A0%259C%25EB%25AA%25A9_%25EC%2597%2586%25EC%259D%258C%201.png)
            
    - Vector란?
        - ArrayList와 동일한 내부구조를 가지고 있다. 가변으로 크기가 조절되며 선형 자료구조(선입선출, FIFO) 를 가지고 있다. ArrayList와의 차이점은 Vector는 동기화된 메소드로 구성되어 있어 멀티 스레드가 동시에 해당 메소드들을 실행할 수 없고, 하나의 스레드가 실행을 완료해야만 다른 스레드들이 실행할 수 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2027.png)
            
        - Vector의 동기화는 장점이자 단점이자. 스레드가 1개일 때도 항상 동기화를 하기에 ArrayList에 비해 성능이 떨어진다.
        - 벡터 선언 시 Casting 연산이 필요하며 잘못된 타입으로 캐스팅 시 에러가 발생하기에 제네릭스가 필요하다.
    - tree구조란?
        - Tree 구조는 비선형 자료구조로 계층적 구조를 가지고 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2028.png)
            
        - 노드(Node) : 트리에서 각각의 구성 요소
        - 루트(Root) : 트리에서 최상위에 존재하는 노드 (Node1)
        - 레벨(level) : 트리에서 각각의 층을 나타내는 단어(Root Node : 0)
        - 형제 노드(Sibling) : 같은 레벨의 노드
        - 간선(Edge) : 노드와 노드를 연결하는 선
        - 부모 노드(Parent Node) : 한 노드를 기준으로 바로 상위에 존재하느 ㄴ노드
        - 자식 노드(Child Node) : 한 노드를 기준으로 바로 하위에 존재하는 노드
        - 높이(Heigh) : 트리 중 최고 레벨
        - 깊이(Depth) : root부터 어떤 특정 노드까지의 깊이
        - 리프(Leaf: : 자식이 없는 최말단 노드
    - stack
        - 선형 메모리 공간에 데이터를 저장하면서 후입선출(LIFO)의 시멘틱을 따르는 자료구조.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2029.png)
            
        - List 컬렉션 클래스의 Vector 클래스를 상속받는다.
    - queue
        - 자바에서의 Queue 메모리 구조는 별도의 인터페이스 형태로 제공된다.
        - 하위 인터페이스 Deque<E>, BlockingDeque<E>, BlockingQueue<E>, TransferQueue<E>가 있다.
        - 선형 메모리 공간에 데이터를 저장하면서 선입선출의 시멘틱을 따르는 자료구조다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2030.png)
            
    - 제네릭스를 사용하는 이유와 장점
        - 제네릭스는 다양한 타입의 객체들을 다루는 메서드나 컬렉션 클래스에 컴파일 시 타입체크를 해주는 기능이다.
        - 타입 안정성과 형변환의 번거로움을 줄이기 위해 사용한다.
        - 제네릭스를 사용하지 않을 경우 Object로 타입을 지정한다.
        - 런타임 시점에는 타입 안정성을 제공하지 못 한다.
    - 프로세스란?
        - 실행 중인 프로그램 + 프로세스 제어블록.
        - 프로세스는 각각 독립된 메모리 영역(Code, Data, Stack, Heap의 구조)를 할당받는다.
        - 운영체제로부터 자원을 할당받는 작업의 단위
        - 실행될 때 운영체제로부터 프로세서를 할당받고, 운영되기 위해 필요한 주소 공간, 메모리 등 자원을 할당받는다.
        - 컴퓨터에서 연속적으로 실행되고 있는 컴퓨터 프로그램.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2031.png)
            
    - 스레드란?
        - 프로세스가 할당받은 자원을 이용하는 실행의 단위.
        - 프로세스 내의 주소 공간이나 자원들을 같은 프로세스 내의 스레드끼리 공유하면서 실행된다.
        - 프로세스 내에서 각각 stack만 따로 할당받고, Code, Data, Heap 영역은 공유한다.
        - 한 프로세스 내에서 동작되는 여러 실행의 흐름.
        - 같은 프로세스 안의 여러 스레드들은 같은 Heap 공간을 공유한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2032.png)
            
    - 스레드와 프로세스의 차이
        - 할당받는 자료구조의 차이.
        - 하나의 프로세스 안에 여러 개의 스레드가 포함된다.
    - 멀티스레드와 멀티 프로세스
        - 멀티 프로세스 : 각각의 프로세스를 독립적으로 실행한다.
        - 멀티 스레드 : 하나의 프로세스 내에서 여러 스레드가 동시에 작업을 수행한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2033.png)
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2034.png)
            
    - 스레드의 장단점
        - 스레드의 장점 : 
        
        → 사용자에 대한 응답성을 향상시킨다.
        → 프로세스간 자원 공유를 위한 번거로운 작업이 필요 없어 효율적이다. 
        → 작업이 분리되어 코드가 간결하다.
        
        - 스레드의 단점 : 
        
        → 스레드 중 한 스레드만 문제가 있어도 전체 프로세스가 영향을 받는다.
        → 스레드를 많이 생성하면 Context Switching이 많이 일어나 성능이 저하된다.
        
    - 스레드를 구현하는 방법
        - Thread 클래스를 상속받는다. 
        
        → Thread 클래스를 상속 받을 때는 다른 클래스를 상속 받을 수 없다. (단일 상속)
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2035.png)
            
        - Runnable 인터페이스를 구현한다.
        
        → Thread 클래스의 메소드를 직접 호출할 수 없으므로, Thread 클래스의 static 메소드 currentThread()를 통해 참조한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2036.png)
            
        
        - Thread의 호출은 메인 메서드에서 start()를 호출한 뒤, 호출 스택을 생성. 생성된 호출 스택에서 run()을 호출하여 시행한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2037.png)
            
    - 동기화처리란
        - 동기화는 한번에 한 개의 스레드만 프로세스 공유 자원(인스턴스)에 접근할 수 있도록 락(Lock)을 걸어 다른 스레드가 진행중인 작업에 간섭하지 못하도록 하는 것이다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2038.png)
            
    - 동기화처리를 하는 방법
        - synchronized 를 통해 시행한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2039.png)
            
    - 데몬스레드란
        - 다른 스레드의 작업을 돕는 보조적인 역할을 수행하는 스레드다.
        - 데몬 스레드 이외의 스레드들이 모두 종료되면 데몬 스레드는 강제로 종료된다.
        - 주 스레드가 데몬이 될 스레드의 setDaemon(true)를 호출하는 방식으로 구현한다.
        - 주의 점은 start() 메소드 호출 후에 setDaemon(true) 호출 시 liiegalThreadStateException이 발생하므로, start() 메소드 호출 전에 호출해야 한다.
        - 현재 실행 중인 스레드의 데몬 스레드 여부는 isDaemon() 메소드의 리턴값으로 확인 가능하다. (true 반환)
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2040.png)
            
    - 서버와 클라이언트란
        - 클라이언트는 다른 프로그램에게 서비스를 요청하는 프로그램
        - 서버는 위 요청에 대해 응답을 해 주는 프로그램이다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2041.png)
            
    - 소켓 프로그래밍이란
        - 소켓 : 프로그램이 네트워크에서 데이터를 송수신할 수 있도록 네트워크 환경에 연결할 수 있게 만들어진 연결부
        - OSI 7 Layer의 네 번째 계층인 TCP 상에서 동작하는 소켓을 주로 사용한다. 이를 TCP 소켓, 혹은 TCP/IP 소켓이라고 한다.
            
            [Tecotalk - OSI 7 Layer](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Tecotalk%20-%20OSI%207%20Layer%20a7040c0a78ae49eb9f33157d1ba72fe4.md)
            
        - 클라이언트 소켓과 서버 소켓을 이용한 소켓 프로그래밍 :
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2042.png)
            
        - 클라이언트 소켓 : 
        
        → 소켓 생성
        → 서버 측에 연결
        → 서버 소켓에서 연결을 받은 뒤 데이터 송수신
        → 처리 완료 후 소켓 close()
        - 서버 소켓 :
        
        → 소켓 생성
        → 서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 결합
        → 클라이언트로부터 연결 요청이 수신되는지 주시
        → 요청 수신 시 accept 후 소켓 생성
        → 데이터 송수신
        → 소켓  close()
    - TCP
        - TCP : 인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜
        - TCP는 가상회선 패킷 교환 방식을 가진다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2043.png)
            
        - TCP의 특징 : 
        
        → 연결형 서비스로 가상 회선 방식을 제공한다.
        → 3-way-handshaking 과정을 통해 연결을 설정하고, 4-way-handshaking을 통해 해제한다.
        → 흐름 제어 및 혼잡 제어
        → 높은 신뢰성 보장
        → UDP에 비해 느린 속도
        → 전이중(Full-Duplex), 점대점(Point to Point) 방식
        - TCP 서버의 특징 : 
        
        → 서버소켓은 연결만을 담당한다. 
        → 연결과정에서 반환된 클라이언트 소켓은 데이터의 송수신에 사용된다. 
        → 가상 회선 방식을 제공한다.
        → 서버와 클라이언트는 1대 1로 연결된다. 
        → 스트림 전송으로 전송 데이터의 크기가 무제한이다. 
        → 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
        → Streaming 서비스에 불리하다.
    - UDP
        - 데이터를 데이터그램 단위로 처리하는 프로토콜
        → 데이터그램 : 독립적인 관계를 지니는 패킷
        - UDP는 비연결형 프로토콜이다.
        - 데이터그램 패킷 교환 방식 :
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2044.png)
            
        - UDP 특징 : 
        
        → 비연결형 서비스로 데이터그램 방식을 제공한다.
        → 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
        → UDP 헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
        → 신뢰성이 낮다.
        → TCP 보다 속도가 빠르다.
        
        - UDP 서버의 특징 : 
        
        → UDP에는 연결 자체가 없다. 즉, 서버 소켓과 클라이언트 소켓의 구분이 없다. 
        → 소켓 대신 IP를 기반으로 데이터를 전송한다.
        → 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다. 
        → 데이터그램(메세지)단위로 전송되며 그 크기는 65535 바이트다. 크기 초과 시 잘라서 보낸다. 
        → 흐름제어가 없어 패킷이 제대로 전송됐는지, 오류가 없는지 확인이 불가능하다. 
        → 신뢰성보다 성능이 중요시 될 때 사용된다.
    
    [Tecotalk - TCP/UDP ](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Tecotalk%20-%20TCP%20UDP%20035f74dc368e4d51ad37b934fedb8513.md)
    

# DB

- DB
    - DML의 종류
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2045.png)
        
        - 데이터 조작 언어(Data Manipulation Language) : 테이블에 값을 삽입하거나, 수정하거나, 삭제하거나, 조회하는 언어.
    - DDL의 종류
        - 데이터 정의 언어(Data Definition Language) : 객체를 만들고, 수정하고, 삭제하는 구문. 
        → 오라클에서의 객체는 테이블(TABLE), 뷰(VIEW), 시퀸스(SEQUENCE), 인덱스(INDEX), 패키지(PACKAGE), 트리거(TRIGGER), 동의어(SYNONYM), 프로시저(PROCEDURE), 함수(FUNCTION), 사용자(USER)가 있다.
    - SELECT 구문 수행 순서
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2046.png)
        
    - 조인이란
        - 한 데이터베이스 내의 여러 테이블의 레코드를 조합하여 하나의 열로 표현한 것.
        - 조인은 테이블로서 저장되거나, 그 자체로 이용할 수 있는 결과 셋을 만들어 낸다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2047.png)
        
    - 조인을 왜 사용하나
        - 한 개 이상의 테이블을 합쳐서 하나의 결과로 조회하기 위해 사용한다.
        - 관계형 데이터베이스의 구조적 특징으로 정규화를 수행하면 의미 있는 데이터의 집합으로 테이블이 구성되고 각 테이블끼리는 관계(Relationship)을 갖게 된다.
        - 이와 같은 특징으로 관계형 데이터베이스는 저장 공간의 효율성과 확장성이 향상되게 된다.
        - 다른 한편으로는 서로 관계있는 데이터가 여러 테이블로 나뉘어 저장되므로 각 테이블에 저장된 데이터를 효과적으로 검색하기 위해 조인이 필요하다.
    - inner join과 outer join
        - 내부 조인(INNER JOIN) : 
        
        → 여러 애플리케이션에서 사용되는 가장 흔한 결합 방식이며 기본 조인 형식으로 간주된다. 
        → 조인 구문에 기반한 2개의 테이블의 컬럼 값을 결합함으써 새로운 결과 테이블을 생성한다. 
        → 명시적 조인 표현(explicit)과 암시적 조인 표현(implicit) 2개의 다른 조인식 구문이 있다.
        → 맵핑이 되지 않으면 출력하지 않는다. (NULL 값 무시)
        - —> explicit : 테이블에 조인을 한다는 것을 지정하기 위해 JOIN 키워드를 사용하며 그 후 ON 키워드를 통해 조인에 대한 구문을 지정한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2048.png)
            
        - —> implicit : SELECT 구문의 FROM 절에서 컬럼들을 분리하는 컴마를 사용한 뒤, 조인을 위한 여러 테이블을 나열하기만 한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2049.png)
            
        - OUTER JOIN : 
        
        → 맵핑이 되지 않아도 기준값에 따라 출력이 가능하다. 
        → 두 테이블의 지정하는 컬럼 값이 일치하지 않는 행도 조인에 포함시킬 수 있다. LEFT, RIGHT, FULL의 지시어를 통해 OUTER JOIN임을 명시해야 한다. 
        → 조인 대상 테이블에서 특정 테이블의 데이터가 모두 필요한 상황에서 외부 조인을 활용할 수 있다.
        
        - 왼쪽 외부 조인(LEFT OUTER JOIN) : 우측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다.
        → 즉, 좌측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2050.png)
            
        - 오른쪽 외부 조인(RIGHT OUTER JOIN) : 좌측 테이블에 조인할 컬럼의 값이 없는 경우 사용한다. 
        → 즉, 우측 테이블의 모든 데이터를 포함하는 결과 집합을 생성한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2051.png)
            
        - 완전 외부 조인(FULL OUTER JOIN) : 양쪽 테이블 모두 OUTER JOIN이 필요할 때 사용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2052.png)
            
    - equal join과 non-equal join
        - 동등 조인(EQUAL JOIN) : 
        
        → 비교자 기반의 조인이며, 조인 구문에서 동등비교만을 사용한다. 
        → 다른 비교연산자(<와 같은)을 사용하는 것은 동등 조인이 아니다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2053.png)
            
        - 비동등 조인 (NON_EQUAL JOIN) : 
        
        → 두 개의 테이블 간에 컬럼 값들이 서로 정확하게 일치하지 않는 경우에 사용한다. 
        → “=”가 아닌 다른 비교 연산자들을 사용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2054.png)
            
    - natural join이란
        - 동등 조인의 한 유형으로 조인 구문이 조인된 테이블에서 동일한 컬럼명을 가진 2개의 테이블에서 모든 컬럼들을 비교함으로써 암시적으로 일어나는 구문이다.
        - 결과적으로 나온 조인된 테이블은 동일한 이름을 가진 컬럼의 각 쌍에 대한 단 하나의 컬럼만 포함하고 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2055.png)
            
    - cross Join
        - 조인되는 두 테이블에서 곱집합을 반환한다.
        → 두 번째 테이블로부터 각 행과 첫 번째 테이블에서 각 행이 한 번씩 결합된 열을 만든다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2056.png)
            
    - self 조인이란
        - 같은 테이블을 조인하는 경우, 자기 자신인 테이블과 조인을 맺는 것.
        - 특히 테이블에 자체 PRIMARY KEY를 참조하는 FOREIGN EKY가 있을 때 테이블이 자신과 조인되는 조인이다. (단항 관계라고도 한다.)
        - 테이블 자체를 조인한다는 것은 테이블의 각 행이 자체 및 테이블의 다른 모든 행과 결합된다는 것을 의미한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2057.png)
            
    - self 조인 사용 이유
        - 한 행에 있는 값을 같은 행에 있는 다른 값과 비교해야 할 때 주로 사용한다.
        - SELF JOIN은 주로 아래와 같은 상황에서 사용한다.
        → 위계성 데이터를 다룰 때
        → 순차성 데이터를 다룰 때
        → 1개의 테이블 안에 관계성이 명시되어야 할 데이터가 여러 개 존재할 떄
    - 유니온과 조인의 차이점
        - JOIN은 Relation의 속성을 결합하여 결과 튜플을 형성한다.
        - UNION 절은 두 쿼리의 결과를 결합한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2058.png)
            
        - PS. UNION : SQL의 집합 연산으로, 두 개의 쿼리 결과를 결합한다. UNION의 결과는 쿼리에 있는 두 관계의 튜플을 포함한다.
    - SUBQUERY란
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2059.png)
        
        - 하나의 SELECT 문장의 절 안에 포함된 또 하나의 SELECT 문장이다. 메인쿼리가 실행되기 이전에 한 번만 실행되며, 비교연산자의 오른쪽에 기술해야 하며, 반드시 괄호()로 묶어야 한다.
        - SUBQUERY와 비교할 항목은 반드시 서브쿼리의 SELECT 한 항목의 개수와 자료형을 일치시켜야 한다.
        - 단일행 서브쿼리 : 서브쿼리의 유형에 따라 서브쿼리 앞에 붙는 연산자가 다르다. 단일행 서브쿼리 앞에는 일반 비교 연산자, >,<,≥,≤,=,≠,<>,^=가 붙는다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2060.png)
            
        - 다중행 서브쿼리 : 다중행 서브쿼리 앞에는 일반 비교 연산자 사용이 불가능하다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2061.png)
            
        - 다중열 서브쿼리
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2062.png)
            
        - 다중행 다중열 서브쿼리
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2063.png)
            
        - INLINE VIEW : 서브쿼리의 컬럼에 별칭을 달 경우, 메인쿼리에서는 반드시 별칭을 붙여 식별해야 한다. 단, 인라인 뷰의 서브쿼리에 연산식으로 도출된 컬럼이 있다면, 그 때는 반드시 인라인 뷰에서 별칭을 달고, 메인쿼리에서도 해당 별칭으로만 조회 가능하다.
        → TOP-N 분석에도 주로 사용한다. ROWNUM을 통해 활용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2064.png)
            
        - 상(호연)관 서브쿼리 : 메인쿼리가 사용하는 테이블의 값을 서브쿼리가 이용해서 결과를 만든다. 
        → 상관 서브쿼리는 EXISTS 연산자만 사용 가능하다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2065.png)
            
        - 스칼라 서브쿼리 : 상관 서브쿼리의 값이 단일행으로 출력될 때를 스칼라 서브쿼리라고 한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2066.png)
            
    - 기본 select 부터 join, subquery를 이용한 select 구분
        
        ```sql
        SELECT
               TABLE.COLUMN
          FROM TABLE;
        
        SELECT 
               A.COLUMN_A
               B.COLUMN_B
          FROM TABLE_A
          JOIN TABLE_B ON (A.COLUMN_A = B.COLUMN_B);
        
        SELECT
               COLUMN
          FROM TABLE_A
         WHERE COLUMN = (SELECT AVG(COLUMN)
                           FROM TABLE
                        );
        ```
        
    - 오라클에서 사용해 본 객체 종류
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2067.png)
        
    - 제약조건이란
        - 제약조건(CONSTRAINTS)은 컬럼에 대한 속성을 정의하는 것이다.
        - 즉, 테이블이나 속성에 부적절한 데이터가 들어오는 것을 사전에 차단하도록 규칙을 정하는 것.
        - 컬럼의 속성처럼 사용하지만, 데이터베이스의 객체 중 하나이므로 고유의 이름(제약조건 명)을 지정해주어야 한다. 지정하지 않을 경우 ORACLE이 자동으로 부여한다.
    - 제약조건의 사용 이유
        - 데이터 무결성을 보장하기 위한 용도로 사용된다.
    - 제약조건의 종류 및 간단한 설명
        - NOT NULL : 컬럼에만 사용 가능하다. 해당 컬럼에 반드시 데이터를 입력해야 할 때 사용한다.
        - UNIQUE : 해당 컬럼에 들어가는 값이 테이블 전체에서 유일해야 한다. (중복값을 허용하지 않는다.)
        - PRIMARY KEY : 기본키라고 부린다. UNIQUE + NOT NULL의 형태를 가지며, 테이블 당 1개의 기본키만 생성 가능하다. 여러 컬럼을 묶어 하나의 기본키로 만들 수 있으며(최대 32개까지 가능) 기본키는 데이터 무결성을 지켜주는 역할을 한다.
        - FOREIGN KEY : 외래키라고 많이 불리는 제약조건이다. 테이블 간의 참조 데이터 무결성을 보장해준다. 참조 데이터 무결성 보장을 통해 참조 관계가 있는 테이블의 데이터 추가, 삭제, 수정을 통제할 수 있다.
        - CHECK : 컬럼에 입력되는 데이터를 CHECK하여 조건에 맞을 경우에만 입력을 허용한다.
    - 테이블에 왜 primary key를 설정하는지
        - 데이터 무결성을 위해 사용한다.
        - 테이블에 대한 식별자 역할을 한다.
    - foreign key 제약조건은 무엇이며 왜 사용하는지
        - 참조 데이터 무결성 보장을 위해 사용한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2068.png)
            
    - 트랜잭션이란
        - 1개 이상의 명령어들을 하나의 논리 집합으로 묶어놓은 단위.
        - 묶여있는 쿼리문들을 ALL_OR_NOTHING 방식으로 처리하기 위해 사용한다.
        - 데이터베이스의 일관성을 유지하고 안정적인 복구가 가능하다.
        - TCL에는 COMMIT, ROLLBACK, SAVEPOINT가 있다.
        - ACID(원자성, 일관성, 독립성, 영속성)을 모두 보장해야 한다.
    - 트랜잭션과 쓰레드의 차이
        - 스레드는 프로세스에서 할당받은 자원을 이용하는 실행의 단위이며, 트랜잭션은 묶여있는 쿼리문들을 하나의 논리 집합 단위로 수행하기 위한 방법이다.
    - view란 무엇인가
        - SELECT 쿼리문을 저장한 객체로 가상테이블이라고도 불린다.
        - 데이터 딕셔너리(Data Dictionary) 테이블에 뷰에 대한 정의 (SQL문)만 저장되므로 디스크 저장 공간 할당이 이루어지지 않는다.
        - 테이블을 사용하는 것과 동일하게 사용할 수 있다.
        - 뷰에 대한 수정 결과는 뷰를 정의한 기본 테이블에 적용된다.
        - 뷰를 정의한 기본 테이블에서 정의된 무결성 제약조건은 그대로 유지된다.
    - view를 사용하는 목적
        - 보안과 편의성을 위해 사용한다.
        → 사용자마다 특정 객체만 조회할 수 있도록 한다.
        → 복잡한 질의문을 단순화할 수 있다.
        → 데이터 중복성을 최소화할 수 있다.
    - index란 무엇인가
        - 추가적인 쓰기 작업과 저장 공간을 활용하여 데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조다.
        - INDEX 활용 시 데이터를 조회하는 SELECT 외에도 UPDATE나 DELETE의 성능이 함께 향상된다. 그 이유는 해당 연산을 수행하려면 대상을 조회하는 작업이 필요하기 때문이다.
    - index의 장점과 단점
        - DBMS는 INDEX를 최신의 정렬된 상태로 유지해야 원하는 값을 빠르게 탐색할 수 있다. 그렇기에 인덱스가 적용된 컬럼에 INSERT, UPDATE, DELETE가 수행된다면 추가적인 연산이 필요하며 그에 따른 오버헤드가 발생한다.
        
        → INSERT : 새로운 데이터에 대한 인덱스 추가. 
        → DELETE : 삭제하는 데이터의 인덱스를 사용하지 않는다는 작업 수행
        → UPDATE : 기존의 인덱스를 사용하지 않음 처리 후, 갱신된 데이터에 대해 인덱스 추가.
        - 장점 : 테이블을 조회하는 속도와 그에 따른 성능을 향상시킬 수 있다. 전반적인 시스템의 부하를 줄일 수 잇다.
        - 단점 : 인덱스를 관리하기 위해 DB의 약 10%에 해당하는 저장공간 필요, 관리하기 위한 추가 작업 필요, 잘못 사용할 경우 성능 저하의 역효과 발생
        - CREATE, DELETE, UPDATE가 빈번한 속성일 수록 성능 저하의 역효과가 발생한다.
    - index의 종류
        - B-TREE 인덱스
            - B-TREE 인덱스
                
                ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2069.png)
                
            - 루트 블록(ROOT BLOCK) : 분기 값 저장, 인덱스의 다음 단계의 브랜치 블록을 가리키는 항목 포함.
            - 브랜치 블록(BRANCH BLOCK) : 분기 값 저장, <Separator Key, DBA>로 구성, 밑의 러프 블록을 가르킴
            - 리프 블록(LEAF BLOCK) : 인덱스 키  값 + ROWID 저장, <실제 Key값, ROWID>로 구성
            - SELECT, DELETE, INSERT 등의 작업에 효율적이다.
            - 분포도가 낮은 컬럼에 불리하고, OR연산자에 대해 테이블 전체를 FULL SCAN하는 것은 위ㅓㅁ하다.
            - 테이블의 어느 데이터에 접근하더라도 동일한 성능을 보장한다.
            - 더블 링크드 리스트 - 리프 블록간 통신을 의미, 리프 블록의 한 인덱스 값에서 RANGE 스캔을 빠르게 할 수 있게 해 준다.
        - 비트맵 인덱스
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2070.png)
            
            - 비트맵, 0과 1로 인덱스를 관리한다.
            - 비트를 이용하여 컬럼값을 저장하고, ROWID를 자동으로 생성한다.
            - 분포도가 낮은 컬럼에 적용할 때 유용하다.
            - 비트를 직접 관리하므로 저장공간이 크게 감소하고 비트 연산을 수행할 수 있다.
            - 비트맵 인덱스는 인덱스 키값 + 시작 ROWID + 끝 ROWID + 비트맵 엔트리로 구성되어 있다.
            - 시작 ROWID와 끝 ROWID의 RANGE 사이에 있는 모든 row 수 만큼 비트맵이 표현되어야 하지만, 오라클에서는 내부적 압축 알고리즘을 사용하여 비트앱을 생성하기에 모두 표현되지 않는 경우도 있다.
            - 비트맵도 B-TREE처럼 조직되어 있지만, 리프 노드는 ROWID값들 대신 각 키값에 대한 비트맵을 저장한다.
            - OR연산자를 포함하는 여러 개의 WHERE 조건을 자주 사용할 때 유리하다.
            - INSERT, UPDATE, DELETE와 같은 쿼리에서는 무의미하다.
    - 프로시저란, 함수란, 패키지란
        - 프로시저(PROCEDURE) : 데이터베이스에 대한 일련의 작업을 정리한 절차. 영구저장모듈(Persistent Storage Module)이라고도 불린다. 
        → 일련의 쿼리를 하나의 함수처럼 실행하기 위한 쿼리의 집합이다.
        → 즉, 특정 작업을 위한 쿼리들의 블록이다.
        
        - 함수(FUNCTION) : 하나의 특별한 목적의 작업을 수행하기 위해 독립적으로 설계된 코드의 집합. 
        
        → 작업을 정리한 절차이며, 보통 로직을 도와주는 역할을 수행한다.
        → 단일행 함수 : 입력 값이 단일 행이며 결과값 또한 하나를 반환한다.
        → 복수행 함수 : 입력 값이 복수이며 결과값은 하나를 반환한다.
        
        - 패키지(PACKAGE) : 논리적 연관성이 있는 pl/sql타입, 변수, 상수, 서브 프로그램, 커서, 예외 등의 항목을 묶어 놓은 객체. 
        
        → 컴파일 과정을 거쳐 DB에 저장되며, 다른 프로그램에서 패키지의 항목을 참조, 공유, 실행할 수 있다.
        → 모듈화가 가능하다.  (연관성이 있거나 비슷한 기능을 수행하는 타입들을 하나의 패키지로 저장)
        → 프로그램 설계가 용이하다. ( 선언부만 있어도 컴파일 후 저장이 가능하다.)
        → 캡슐화가 가능하다. (선언부는 외부에 공개되지만 본문은 외부에서 볼 수 없다. 즉, 정보 은닉 기능 제공)
        → 보다 나은 성능 : 패키지의 서브프로그램을 호출 시 패키지 전체를 메모리에 올려놓는다. 이후 계속 호출할 때는 메모리의 패키지를 불러오므로 더 나은 성능을 보인다.
    - 트리거란
        - 테이블에 DML에 의해 연결될 때 자동으로 수행 할 내용을 정의하여 지정한 객체.
        - 컴파일 후 DML작업이 실행된 후 작동된다.
        - 행 트리거 : 컬럼의 각각의 행의 데이터에 변화가 생길 때마다 PL/SQL 구문이 실행된다. (FOR EACH ROW문 추가)
        - 문장 트리거 : 트리거 사건에 의해 PL/SQL 구문이 단 한번만 실행된다. (FOR EACH ROW 문 생략)
    

# 화면 내용

- Javascript와 jQuery 차이
    - jQuery는 javascript의 DOM(Document Object Model) 작업을 쉽게 도와주는 라이브러리다. 
    
    → PS. 자바스크립트는 크게 4가지 요소로 구성되어 있다. 
    
    1. 자바스크립트 core 문법
    2. 자바스크립트 core 라이브러리
    3. 자바스크립트 BOM(Browser Object Model)
    4. 자바스크립트 DOM(Document Object Model)
- jQuery의 장점
    - 더 적은 수의 코드로 jQuery를 사용하여 가장 일반적인 JS 작업을 코딩할 수 있다.
    - 다양한 브라우저의 복잡성을 고려하지 않아도 브라우저 전체에서 실행되고 중단되지 않는 코드를 작성할 수 있다.
    - Javascript를 더 빠르고 쉽게 작성할 수 있다.
    - 일반적인 브라우저 오류 방지
    - 일반적으로 복잡한 작업의 단순화 - Ajax 상호 작용, 애니메이션, 이벤트 처리 등과 같은 복잡한 작업은 최상의 코드 라인으로 jQuery에서 처리된다.

# 서블릿 JSP

- Servlet, JSP
    - 클라이언트와 서버에 대해 설명
        - 클라이언트(Client) : 서비스를 사용하는 컴퓨터, 서버와 이어진 모든 기기와 단말기에서 이용하는 웹에 접근하는 SW. 주로 서버에 요청을 보내고 응답을 받는다.
        - 서버(Server) : 서비스를 제공하는 소프트웨어가 실행되는 컴퓨터. 클라이언트의 요청에 응답한다.
    - web서버와 was 서버의 차이
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2071.png)
        
        - Web Server는 소프트웨어와 하드웨어로 구분된다.
        → 하드웨어 : Web 서버가 설치되어 있는 컴퓨터
        → 소프트웨어 : 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html, .jpeg, .css 등)을 제공하는 컴퓨터 프로그램
        - Web Server는 HTTP 프로토콜을 기반으로 클라이언트의 요청을 서비스 하는 기능을 담당한다.
        - Was Server는 DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server다.
        - Was Server는 HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어다.
        - WAS = Web Server + Web Container
        - Was Server는 Web Server의 기능들을 구조적으로 분리하여 처리하고자 하는 목적으로 제시되었다.
        - Web과 Was를 구분하는 이유는 서버의 부담을 줄이고 자원을 효율적으로 관리하는데 그 목적이 있다.
    - web 서버와 was 서버의 장단점
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2072.png)
        
    - 서블릿 컨테이너와 jsp 컨테이너의 역할
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2073.png)
        
        - Servlet Container : 
        → 서블릿들의 생성, 실행, 파괴를 담당한다. 
        → Servlet Container는 Client의 Request를 받아주고 Response할 수 있게 웹 서버와 소켓을 만들어 통신한다.
        → 대표적으로 Tomcat이 있다. 
        
        → 웹 서버와의 통신을 지원한다. 
        → 서블릿 생명주기를 관리한다.
             → 서블릿 클래스를 로딩하여 인스턴스화
             → 초기화 메소드 호출
             → 요청이 들어오면 적절한 서블릿 메소드 호출
             → 서블릿 소멸시 GC 진행
        → 멀티쓰레드를 지원 및 관리한다.
        → 선언적인 보안을 관리한다.
        - JSP Container  : 
        → JSP를 서블릿으로 변환하는 프로그램이다.
        → JSP Container 역시 서블릿으로 구현된 프로그램이다. 
        → 실행 방식은 다음과 같다. 
             → CLient가 요청한 페이지가 Web Container에 없는 동적 페이지일 때 
            1. Translation : 최초 JSP 요청 시 JSP 페이지를 Servlet으로 변환
            2. Compile : [Servlet.java](http://Servlet.java) 파일을 class 파일로 Compile
            3. Load : 생성된 Class 파일을 읽는다. 
            4. Initialization : 서블릿 컨테이너에서 변환된 서블릿을 이용해 인스턴스 생성
            5. run : 매 요청 시마다 기존 JSP 파일 확인 후, 변경된 점이 없다면 생성된(Initialization) 인스턴스를 사용한다. 
                → 변경점이 있다면 Translation 과정부터 다시 시작.
    - 서블릿이란?
        - 클라이언트의 요청을 처리하고, 그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지키 자바 웹 프로그래밍 기술.
        - Servlet 의 특징은 다음과 같다.
        → 클라이언트의 요청에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트
        → html을 사용하여 요청에 응답한다. 
        → Java Thread를 이용하여 동작한다.
        → MVC 패턴에서 Controller로 이용된다. 
        → HTTP 프로토콜 서비스를 지원하는 javax.servlet.http.HttpServlet 클래스를 상속받는다. 
        → UDP보다 처리 속도가 느리다. 
        → HTML 변경 시 Servlet을 재컴파일해야 하는 단점이 있다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2074.png)
        
    - 서블릿 설계 규약
        1. 모든 서블릿은 javax.servlet.Servlet 인터페이스를 상속 받아 구현한다.
        2. 서블릿을 구현 시 Servlet 인터페이스와 ServletConfig 인터페이스를 javax.servlet.GenericServlet에 구현한다.
        3. HTTP 프로토콜을 사용하는 서블릿은 javax.servlet.http.HttpServlet, 클래스는 javax.servlet.GenericServlet을 상속한 클래스로 서블릿은 httpServlet 클래스를 상속받는다.
        4. 서블릿의 Exception을 처리하기 위해서는 javax.servlet.ServletException을 상속 받아야 한다.
    - 서블릿의 동작 구조
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2075.png)
        
        1. 웹 서버에서 사용자가 요청한 페이지가 준비되었는지 판단.
        2. 판단 후 준비되어있지 않다면 사용자가 요청한 정보 Servlet Container로 전송
        3. 서블릿 컨테이너는 요청 단위마다 하나의 스레드로 묶어 서블릿 객체 호출
        4. 서블릿 객체는 사용자가 요청한 정보를 바탕으로 객체 생성
        5. 서블릿 컨테이너는 전송받은 객체로 동적 페이지 생성
        6. 생성된 페이지는 웹 서버로 전송, 사용자에게 반환(응답)한다.
    - web.xml 배포서술자란
        - web.xml 파일은 웹 어플리케이션을 구성하는 웹 컴포넌트에 대한 구성 및 배치 정보를 제공하며, 웹 어플리케이션의 배포서술자 역할을 하는 XML 형식의 파일.
    - 배포서술자에 작성하는 내용
        1. ServeltContext의 초기 파라미터
        2. Session의 유효시간 설정
        3. Servlet/JSP에 대한 정의
        4. Servlet/JSP 매핑
        5. Mime Type 매핑
        6. Welcome File List
        7. Error Pages 처리
        8. 리스터/필터 설정
        9. 보안
    - get과 post의 차이
        - GET : 
        → URL 창의 “?” 뒤에 데이터를 입력하는 쿼리스트링 방식으로 보낸다. 
        → 데이터가 여러 개일 경우 &으로 묶어 보낸다. 
        → 255byte까지 전송 가능하다.  
        → Request 객체의 Head 부분에 담긴다. 
        → 데이터 검색에 많이 사용되며 보안에 취약하다.
        - POST : 
        → HTTP 헤더의 내용으로 보낸다. 
        → 데이터 크기에 제한이 없으며 파일 첨부도 가능하다. 
        → URL에 데이터가 노출되지 않아 보안에 더 적합하다. 
        → GET과는 달리 기본 인코딩 방식이 ISO-8859-1로 되어있어 인코딩 과정이 필요하다.
    - forward와 sendRedirect 차이
        - forward와 sendRedirect 모두 TCP 통신 기반의 3-ways handshake를 기반으로 한다.
        - forward : 
        → forward로 연결되기 전 두 Servlet은 connectless 해서 stateless하다. 
        → forward 이후 두 servlet이 연결된다. 
        → redirect보다 성능 면에서 더 빠르다. 
        → forward() 메소드를 사용하는 동안 요청 및 응답 객체는 하나만 존재한다. 
        → 각각의 Servlet마다 역할을 부여한다. client는 하나의 servlet만 알고, forward된 다른 servlet은 알 수 없다.
        - redirect : 
        → redirect는 client 쪽에서 서로 다른 서블릿에 연결한다. 
        → sendRedirect() 메소드를 이용한다. 
        → sendRedirect() 메소드를 이용하는 동안 객체는 요청과 응답이 두 개씩 존재한다. 첫 번째 Servlet에서 client의 요청을 수신하고, 해당 요청을 다른 서블릿으로 redirect 하면서 두 번째 서블릿에서 새로운 요청돠 응답이 생성, 해당 응답이 client로 응답된다ㅣ. 
        → 다른 서블릿으로 redirect 할 경우 request는 공유되지 않는다. (stateless)
    - 필터란
        - HTTP 요청과 응답 사이에서 전달되는 데이터를 가로채어 서비스에 맞게 변경하고 걸러내는 필터링 작업을 수행할 수 있는 클래스다.
        - 일반적으로 아래와 같은 기능에 사용한다. 
        1. 사용자 인증 필터
        2. 로깅 및 감시(Audit) 필터
        3. 이미지 변환 및 데이터 압축 필터
        4. 암호화 필터
        5. XML 컨텐츠를 변형하는 XSLT 필터
        6. URL 및 기타 정보들을 캐싱하는 필터.
        - 생성, 초기화, 필터 ,종료의 4단계 라이프 사이클을 가진다.
    - (서블릿) 래퍼란
        - 관련 클래스(ServletRequest, ServletResponse, HttpServletRequest, HttpServletResponse)를 내부에 보관, 내부에 있는 클래스가 구현하고 있는 메소드로 위임하여 모든 메소드를 구현한다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2076.png)
            
        - 서블릿 요청 / 응답 래퍼 클래스를 이용함으로써 클라이언트의 요청 정보를 변경, 최종 자원인 Servlet / JSP / 기타 자원에 전달할 수 있으며, 최종 자원으로부터의 응답 결과를 변경하여 새로운 응답 정보를 클라이언트에게 보낼 수 있게 된다.
    - session과 cookie에 대해
        - Session : 일정 시간 동안 같은 사용자(브라우저)로부터 들어오는 일련의 요구를 하나의 상태로 보고, 그 상태를 유지시키는 기술.
        - 일정 시간은 방문자가 웹 브라우저를 통해 웹 서버에 접속한 시점부터 웹 브라우저를 종료하여 연결을 끝내는 시점 까지.
        - 즉, 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고, 그것을 세션이라고 한다.
        - 세션의 동작 순서는 다음과 같다.
        
        1.  클라이언트가 페이지에 요청
        2. 서버는 접근한 클라이언트의 Request-Header의 Cookie 확인, 클라이언트의 Session-Id를 확인한다.
        3. Session-Id가 존재하지 않는다면 서버는 Session-ID를 생성하여 클라이언트에게 반환
        4. 서버에서 클라이언트로 반환한 Session-Id를 쿠키를 이용해 서버에 저장
        5. 클라이언트는 재접속 시 해당 쿠키를 이용하여 Session_id 값을 서버에 전달.
        - 세션의 특징은 다음과 같다. 
        
        1. 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
        2. 웹 서버에 저장되는 쿠키
        3. 브라우저를 닫거나 서버에서 세션을 삭제했을 때만 삭제되므로 쿠키보다 보안이 좋다. 
        4. 저장 데이터에 제한이 없다. (서버 용량 안에서)
        5. 각 클라이언트에 고유 Session-ID를 부여한다. 해당 ID로 클라이언트를 구분한다.
        - Cookie : HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문할 경우 사이트를 사용하는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일. HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장 후 필요시 정보를 참조 혹은 재사용할 수 있다
        - 쿠키의 동작 순서는 다음과 같다. 
        
        1. 클라이언트가 페이지를 요청
        2. 웹 서버는 쿠키를 생성한다. 
        3. 생성한 쿠키에 정보를 담아 HTTP 화면을 돌려줄 때, 같이 클라이언트에게 반환한다. 
        4. 넘겨받은 쿠키는 클라이언트가 로컬 PC에 저장하고 있다가, 다시 서버에 요청할 때 요청과 함께 쿠키를 전송한다. 
        5. 동일 사이트 재방문 시 클라이언트의 PC에 쿠키가 있을 경우, 요청 페이지와 함께 쿠키를 전송한다.
        - 쿠키의 특징은 다음과 같다. 
        
        1. 이름, 값, 만료일(저장기간), 경로 정보로 구성. 
        2. 클라이언트에 총 300개의 쿠키를 저장할 수 있다. 
        3. 하나의 도메인 당 20개의 쿠키를 가질 수 있다.
        4. 하나의 쿠키는 4KB까지 저장 가능하다.
    - 세션과 쿠키의 차이
        - 쿠키는 서버의 자원을 사용하지 않고, 세션은 서버의 자원을 사용한다.
        - 보안 면에서는 세션이 더 우수하다.
        - 쿠키의 만료기간은 브라우저 종료 후에도 유지될 수 있지만, 세션은 브라우저 종료시 만료기간에 상관 없이 삭제된다.
        - 속도 면에서 쿠키가 더 우수하다.
    - jsp란
        - Java Server Page, Java 언어를 기반으로 하는 Server Side Script 언어.
        - HTML 코드에 java 코드를 넣어 동적인 웹 페이지를 생성하는 웹 애플리케이션 도구.
        - JSP 기술의 목표는 Servlet의 비지니스 로직(java)로부터 화면 로직(HTML)을 분리하는 것에 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2077.png)
            
        - 자바 기능을 그대로 사용할 수 있다.
        - WAS가 이미 만들어놓은 객체를 사용한다.
    - 서블릿과 jsp의 차이
        - JSP는 구동 방식 중 Servlet으로 변환된다. JSP는 Servlet의 한 부분으로 볼 수 있다.
            
            ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2078.png)
            
    - jsp의 특징
        - 최초 서블릿으로 컴파일 된 후에는 메모리에서 처리되기에 많은 사용자 접속도 원활하게 처리 가능하다.
        - JSP 또한 다른 Servlet간 데이터 곻유가 가능하다.
        - 자바를 기반으로 하고 있으므로 플랫폼에 독립적이다.
        - 빈즈 자바 컴포넌트를 사용할 수 있다.
        - EJB(Enterprise Java Bean)기술과 완벽하게 호환된다.
        - 사용자 정의 태그를 만들어 사용할 수 있다. (JSTL 같은)
        - HTTP와 같은 프로토콜에 따라 클라이언트의 요청을 처리하고 응답한다.
        - HTML, XML 등 웹 서비스와 관련된 문서를 생성하는 데 주로 사용된다.
        - JDBC API를 사용하여 웹 어플리케이션에서 DB로 연결할 수 있다.
        - Servlet Container가 필요하다.
    - jsp tag element 5가지
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2079.png)
        
    - jsp 내장객체란
        - JSP 페이지 내에서 제공하는 특수한 레퍼런스 타입의 변수다.
        - 객체 생성 없이 바로 사용할 수 있는 JSP의 객체다.
        - 스크립트릿 (<% %>) 안에서만 사용 가능하다.
        - 스크립트릿에 내장 객체와 같은 이름의 변수를 선언할 수 없다.
        - 서블릿 컨테이너가 해당 JSP 페이지 실행 시 자동으로 생성한다.
    - jsp 내장객체 9가지
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2080.png)
        
    - jsp 내장 객체의 영역 구분하여 설명
        - Page 영역 : 하나의 JSP 페이지를 처리할 때 사용되는 영역
        - Request 영역 : 하나의 요청을 처리할 때 사용되는 영역
        - Session 영역 : 하나의 브라우저와 관련된 영역
        - Application 영역 : 하나의 웹 어플리케이션과 관련된 영역
    - el로 값을 바로 출력하지 않고 jstl c:out을 이용해야 하는 이유
        - 보안성의 이유가 가장 크다.
        - <c:out>을 이용하여 XSS 공격을 방지할 수 있다.
        - 엄격한 태그 규칙을 위한 목적도 있다.
        - 개행문자 파싱의 차이 때문에 사용한다.

# ajax

- ajax란 무엇인가
    - JavaScript의 라이브러리 중 하나이며 Asynchronous Javascript And Xml의 약자이다.
    - 브라우저가 가지고 있는 XMLHttpRequest 객체를 이용해서 전체 페이지를 새로 고치지 않아도 페이지의 일부만을 위한 데이터를 로드하는 기법이다.
    - Javascript를 이용한 비동기 통신, 클라이언트와 서버 간에 XML 데이터를 주고받는 기술이다.
- 동기 방식과 비동기 방식의 차이점
    - 동기식 처리모델 : 페이지가 로드 되는 동안 브라우저는 Script 문이 실행되면 그 실행이 종료될 때까지 나머지 페이지를 로드하지 않고 기다리고 있다가 해당 script문 처리가 종료되면 나머지 부분을 로드한다. (Blocking)
    - 비동기식 처리 모델 : 페이지가 로드 되는 동안 브라우저는 먼저 서버에 데이터를 요청한다. Script 문이 시행된 후 페이지의 나머지를 계속 로드하고, 페이지와 사용자의 상호작용을 처리하며, 브라우저는 요청한 데이터를 계속 기다리지 않는다. 이후 요청한 데이터가 도착하면 그 때 이벤트가 발생하며 지정된 함수가 호출되어 싱행된다. (Non Blocking)
- ajax의 장단점
    - 장점 : 
    
    → 웹 페이지의 속도 향상
    → 서버의 처리가 완료될 때까지 기다리지 않아도 처리 가능
    → 서버에서 Data만 전송하면 되므로 전체적인 코딩의 양 감소
    → 기존 웹에서는 불가능했던 다양한 UI를 가능하게 해 준다.
    - 단점 : 
    
    → 히스토리 관리가 되지 않는다. 
    → 페이지 이동 없는 통신으로 인한 보안성 문제
    → 연속으로 데이터 요청 시 서버 부하 증가
    → XMLHttpRequest를 통해 통신하는 경우 사용자에게 진행 정보가 주어지지 않는다. 
    → Ajax를 사용할 수 없는 브라우저가 존재한다.
    → HTTP 클라이언트의 기능이 한정되어 있다. 
    → 지원하는 Charset이 한정되어 있다. 
    → Script로 작성되므로 디버깅이 어렵다. 
    → 동일출처 정책으로 인해 다른 도메인과는 통신이 불가능하다.
    

# Framework

- 프레임워크란 무엇인가
    - 프레임워크는 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합이다.
    - ex) Spring, Django, Flask, Android 등
- 프레임워크와 라이브러리의 차이
    - 프레임워크와 라이브러리의 가장 큰 차이점은 제어 흐름의 권한이 어디에 있는가에 있다.
    - 라이브러리는 사용자가 애플리케이션 코드의 흐름을 직접 제어해야 하며, 개발 시 필요한 기능이 있을 경우 능동적으로 라이브러리를 호출하여 사용하거나 기존에 구성된 함수나 코드를 가져와야 한다.
    - 반면 프레임워크는 애플리케이션의 코드가 프레임워크에 의해 사용된다. 애플리케이션 코드는 프레임워크가 짜 놓은 틀에서 수동적으로 동작하기 때문에 제어의 흐름은 사용자가 아닌 프레임워크가 가지고 있다. 즉, 프레임워크는 제어의 역전(IoC, Inversion of Control)이 적용된다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2081.png)
        
- 프레임워크의 특징
    - 모듈화(modularity) : 프레임워크는 구현을 인터페이스 뒤에 감추는 캡슐화를 통해서 모듈화를 강화한다. 또한 프레임워크 모듈화는 설계와 구현의 변경에 따르는 영향을 최소화시킴으로써 쉽게 소프트웨어의 품질을 향상시킬 수 있다.
    - 재사용성(reusability) : 프레임워크가 제공하는 인터페이스는 여러 애플리케이션에서 반복적으로 사용할 수 있는 일반적인 컴포넌트를 정의할 수 있게 함으로써 재사용성을 높여준다. 재사용성은 도메인 지식과 경험이 있는 개발자들의 노력을 활용하여, 애플리케이션의 요구사항과 소프트웨어 설계에 대한 공통의 솔루션을 반복적으로 재개발하고, 그에 대한 유효성을 다시 확인하는데 소요되는 시간을 줄여준다. 또한 소프트웨어의 품질, 성능, 신뢰성, 사호 운용성을 향상시킬뿐만 아니라, 프로그래머의 생상성을 상당히 높여준다.
    - 확장성(extensibility) : 프레임워크는 다형성을 통해 애플리케이션의 프레임워크의 인터페이스를 확장할 수 있게 한다. 새로운 애플리케이션 서비스와 특성을 커스터마이징하는 것을 보장하는데 필수적인 사항이며, 애플리케이션의 가변성으로부터 분리함으로써 재사용의 이점을 얻게 된다.
    
    - 제어의 역흐름(inversion of Control) : 일반적으로 어떤 모듈을 호출함으로써 해당 모듈을 재사용하게 되는데, 프레임워크에서는 이와는 반대되는 제어 흐름으로 재사용성을 지원한다. 프레임워크 코드가 전체 애플리케이션의 처리흐름을 제어하며, 특정한 이벤트가 발생할 때 다형성을 통해 애플리케이션이 확장한 메서드를 호출함으로써 제어가 프레임워크로부터 애플리케이션으로 거꾸로 흐르게 된다. 이러한 제어의 역흐름을 통해 프레임워크가 외부의 이벤트에 대해 애플리케이션이 어떠한 메소드들을 수행해야 하는지 결정할 수 있다.
    
- 프레임워크의 장단점
    - 장점 : 
    
    → 체계적인 코드관리로 유지보수가 용이하다.
    → 기본설계 및 기능 라이브러리를 제공하여 개발 생산성이 높다. 
    → 코드에 대한 재사용성이 높다. 
    → 추상화된 코드 제공을 통해 확장성이 좋다.
    - 단점 :
    
    → 학습 난이도가 높다.
    → 기본 설계된 구조에 의해 자유로운 개발에 한계가 있다. 
    → 사용하지 않는 기능에 대한 라이브러리가 포함될 수 있다. 
    → 제공되는 기능만큼 프로젝트의 용량이 증가한다.
- 프레임워크의 종류
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2082.png)
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2083.png)
    
    - 전자정부 표준 프레임워크(eGovFrame), 스프링(Spring), 스트럿츠(Struts), 아이바티스(iBatis), 마이바티스(Mybatis), 하이버네이트(Hibernate), 닷넷(.NET), 등…
- 마이바티스란
    - 아이바티스를 포크하여 새로 업그레이드한 오픈소스 기반의 개발 표준 프레임워크. 개발자가 작성한 SQL 명령어와 자바 객체를 매핑해주는 기능을 제공하며, 기존에 사용하던 SQL 명령어를 재사용한다.
    - 영속성 프레임워크 중 하나로 데이터의  CRUD를 보다 편하게 하기 위해 xml로 구조화한 Mapper 설정 파일을 통해 JDBC를 구현한 프레임워크.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2084.png)
        
- 마이바티스의 장점
    - SQL문이 코드로부터 완전히 분리 : 기존에 DAO 파일에 모든 SQL문을 작성하였던 것과는 달리, MyBatis에서는 Mapper 파일에 SQL 코드를 입력한 뒤 DAO 파일에서 필요할 때마다 가져와서 사용할 수 있다.
    - 생산성 : JDBC와 SQL을 유지하면서도 훨씬 더 적은 코드로도 JDBC처럼 작동한다. 자바 코드의 20%를 사용하여 JDBC 기능의 80%를 제공하는 간단한 프레임워크이며, 작성할 필요가 없는 JDBC 코드로 인한 분량 문제가 현저하게 줄어든다.
    - 성능 : 성능 최적화 기법을 지원한다. 페이징 처리된 데이터 리스트를 읽어와서 사용할 떄 불필요한 수천 개의 행을 한꺼번에 데이터베이스로부터 가져오는 것이 아니기에 애플리케이션의 성능을 향상시킬 수 있다.
    - SQL 문장과 프로그래밍 코드의 분리 
    
    → 작업의 분배 : 팀을 세분화하는 것을 돕는다. SQL문과 자바 코드와의 분리만으로도 자바 개발자는 Query문을 신셩 쓰지 않아도 된다. SQL문이 변경되더라도 파라미터 값만 변경되지 않는다면 자바 소스에서 수정할 부분이 없기 때문이다. 
    
    → 이식성 : 자바, C#, Ruby등 어떠한 프로그래밍 언어로도 구현 가능하다. 데이터베이스 접근 클래스와 비지니스 로직을 담은 클래스의 분리, 이른바 DAO(Data Access Object)패턴이 이러한 일을 담당한다. 
    
    → 트랜잭션과 스레드 관리 : 트랜잭션 처리 역시 용이하다.
- 메이븐이란
    - 자바용 프로젝트 관리 도구이다. 자바 기반 프로젝트의 컴파일과 빌드를 동시에 수행, 테스트를 병행하거나 서버 측 디플로이(Deploy) 자원을 관리할 수 있는 환경을 제공한다. 프로젝트 객체 모델, 표준들, 프로젝트 생명주기, 의존성 관리 시스템, 생명주기에 정의된 단계에서 플러그인 goal을 실행하는 로직을 포함하는 프로젝트 관리 도구이며, 프로젝트의 전체적인 라이프사이클을 관리하는 도구이다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2085.png)
        
    - 라이프 사이클 순서 : 
    1. Default(Build) : 일반적인 빌드 프로세스를 위한 모델
    2. Clean : 빌드 시 생성되었던 파일들을 삭제하는 단계
    3. Validate : 프로젝트가 올바른지 확인하고 필요한 모든 정보를 사용할 수 있는지 확인하는 단계
    4. Compile : 프로젝트의 소스코드를 컴파일 하는 단계
    5. Test : 유닛(단위) 테스트를 수행 하는 단계 (테스트 실패시 빌드 실패로 처리, 스킵 가능)
    6. package: 실제 컴파일된 소스 코드와 리소스들을 jar, war 등의 배포를 위한 패키지로 만드는 단계
    7. Verify : 통합 테스트 결과에 대한 검사를 싱행하여 품질 기준을 충족하는지 확인하는 단계
    8. Install : 패키지를 로컬 저장소에 설치하는 단계
    9. Site : 프로젝트 문서와 사이트 작성, 생성하는 단계
    10. Deploy : 만들어진 package를 원격 저장소에 release 하는 단계
- 메이븐의 장점
    - 컴파일과 빌드를 동시에 수행할 수 있다.
    - 서버의 디플로이 자원을 관리할 수 있다.
    - pom.xml 파일을 통해 관리하므로 개발, 유지보수 측면에서 오픈소스 라이브러리, 프로젝트 등의 관리가 용이하다.
    - IDE에 종속된 부분을 제거할 수 있다.
    - maven Profile 기능을 통해 배포 설정 파일을 관리, 생성할 수 있다.
- 스프링 프레임워크란
    - 자바 기반의 응용 프로그램 개발을 지원하는 오픈소스 표준 프레임워크이다.
    - 엔터프라이즈급 애플리케이션을 개발하기 위한 모든 기능을 종합적으로 제공하는 경량화된 솔루션이다.
- 스프링의 특징
    - 경량 컨테이너로서 자바 객체를 직접 관리한다. 각각의 객체 생성, 소멸과 같은 라이프 사이클을 관리하며 스프링으로부터 필요한 객체를 얻어올 수 있다.
    - 스프링은 POJO(Plain Old Java Object) 방식의 프레임워크로, 일반적인 J2EE 프레임워크에 비해 구현을 위해 특정한 인터페이스를 구현하거나 상속 받을 필요가 없어 기존에 존재하는 라이브러리 등을 지원하기에 용이하며 객체가 가볍다.
    - 스프링은 제어 반전(IoC)를 지원한다. 컨트롤의 제어권이 사용자가 아니라 프레임워크에 있어 필요에 따라 스프링에서 사용자의 코드를 호출한다.
    - 스프링은 의존성 주입(DI)를 지원한다. 각각의 계층이나 서비스들 간에 의존성이 존재할 경우 프레임워크가 서로 연결시켜준다.
    - 스프링은 관점 지향 프로그래밍(AOP, Aspect Oriented Programming)을 지원한다. 따라서 트랜잭션이나 로깅, 보안과 같이 여러 모듈에서 공통적으로 사용하는 기능의 경우 해당 기능을 분리하여 관리할 수 있다.
    - PSA(Portable Service Abstraction), 스프링은 영속성과 관련된 다양한 서비스를 지원한다. iBatis나 하이버네이트 등 이미 완성도가 높은 데이터베이스 처리 라이브러리와 연결할 수 있는 인터페이스를 제공한다.
    - 스프링은 확장성이 높다. 스프링 프레임워크에 통합하기 위해 간단하게 기존 라이브러리를 감싸는 정도로 스프링에서 사용이 가능하기 때문에 수많은 라이브러리가 이미 스프링에서 지원되고 있고 스프링에서 사용되는 라이브러리를 별도로 분리하기도 용이하다.
- 스프링 MVC의 흐름(요청 처리 과정)
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2086.png)
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2087.png)
    
    1. 클라이언트의 요청을 Dispatcher Servlet이 받는다. 
    2. Handler Mapping에서 요청 정보를 통해 요청을 위임할 컨트롤러 탐색
    3. 요청을 컨트롤러로 위임할 Handler Adapter를 찾아 전달
    4. Handler Adapter가 Controller로 요청 위임
    5. 비지니스 로직 처리
    6. 컨트롤러 결과값 반환
    7. Handler Adapter가 반환값 처리
    8. 서버의 응답을 클라이언트로 반환
- IoC란 무엇인가
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2088.png)
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2089.png)
    
    - 객체를 직접 생성하는 것이 아닌, 외부에서 생성한 후 주입 시켜주는 방식. (단, 개발자가 직접 객체를 생성할 수 없는 것은 아니다.)
    - 제어의 역전이라고 말하며, 제어의 흐름을 바꾸는 것이다.
    - 즉, 객체의 의존성을 역전시켜 객체 간의 결합도를 줄이고 유연한 코드를 작성할 수 있게 하며, 가독성 및 코드 중복, 유지 보수를 편하게 할 수 있게 한다.
    - 은닉과 낮은 결합도를 통한 유지보수성 증가.
- IoC 컨테이너란
    - 오브젝트의 생성과 관계설정, 사용, 제거 등의 작업을 대신 해주는 컨테이너. IoC Container는 Bean을 저장하는 역할을 하기에 BeanFactory라고도 불린다. Application Context의 구현체이다.
    - StaticApplicationContext : 코드를 통해 빈 메타정보를 등록하기 위해 사용한다. 실질적으로 사용되는 일은 학습용 외에는 없다.
    - GenericApplicationContext : 실전에서 사용될 수 있는 모든 기능을 갖추고 있는 ApplicationContext. XML파일과 같은 외부 리소스에 있는 설정 메타정보를 리더를 통해 읽어들인 후 메타정보로 전환하여 사용한다.
    - GenericXmlApplicationContext : GenericApplicationContext에서 XmlBeanDefinitionReader를 내장하고 있는 Context
    - WebApplicationContext : 스프링 애플리케이션에서 가장 많이 사용되는 컨테이너로, Xml 설정 파일을 사용하는 경우에는 XmlWebApplicationContext를, Annotation을 사용하면 AnnotationConfigWebApplicationContext를 사용한다.
        
        ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2090.png)
        
- IoC 컨테이너의 역할
    - IoC 컨테이너는 객체의 생성을 책임지고 의존성을 관리한다.
    - POJO의 생성, 초기화, 서비스, 소멸에 대한 권한을 가진다.
    - Bean을 만들고 그들 사이의 의존성을 엮어주며 Container가 가지고 있는 Bean들을 제공해주는 역항을 한다.
- DI란 무엇인가
    - 의존성 주입, DI(Dependency Injection). 어떤 객체가 사용하는 의존 객체를 주입 받아 사용하는 방법.
- DI의 장점
    - 클래스 간 의존 관계를 최소화함으로써 느슨한 결합을 통해 유연한 구조를 가진다.
    - 유지보수가 용이하다.
    - 코드의 중복을 방지한다.
- DI의 종류
    - Field Injection (필드 주입)
    - Setter Injection(수정자 주입)
    - Constructor Injection(생성자 주입)
- xml을 이용한 bean 관리와 어노테이션을 이용한 bean 관리의 장단점
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2091.png)
    
    - XML : 분리 
    → 결합도를 낮추고 유지보수성을 높이기 위해 XML로 설정한다. 
    —> 그러나 XML이 많아질수록 유지보수성이 낮아진다.
    → 유지보수성에 중점을 둔다. 
    → 시스템 전체에 영향을 주고 이후 변경가능성이 있으면 XML이 권장된다.
    - Annotation : 결합
    → 직관적인 메타데이터 설정이 가능하다. 
    → 생산성에 중점을 둔다. 
    → 설계시 확정된 부분은 Annotation 기반 설정으로 개발 생산성을 높이는 것이 권장된다.
- 의존성 주입 시 사용하는 어노테이션과 그 밖에 스프링에서 사용한 어노테이션
    - 컴포넌트 계열 Annotation : 
    
    → 기본 스트레오타입 Annotation. 이 Annotation을 붙인 클래스는 빈 객체가 된다. 클래스에 붙여 해당 클래스가 Component Scan의 대상이고, 스프링에 의해 관리될 것을 표시한다. 
    
    —> @Repository : 영속성 계층에서 사용
    
    —> @Service : 비지니스 계층에서 사용
    
    —> @Controller : 프리젠테이션 계층에서 사용
    
    —> @Component : 계층 구조가 명확하지 않을 경우 사용
    - 의존성 주입 Annotation(Dependency Injection) :
    
    → @Autowired : 의존대상 객체를 타입으로 검색해서 주입한다. 만약 동일한 타입의 객체가 여러개일 경우 Exception이 발생한다.
    
    → @Resource : 의존 대상 객체를 타입으로 검색해서 주입한다. 
    
    → @Resource(name = “bean id”) : 의존 대상 객체를 이름으로 주입. Autowired의 단점 보완 가능
    
    → @Inject : 의존 대상 객체를 타입으로 검색해 주입. 
    —> @Named(”bean id”) : @Inject와 @Named를 함께 명시하면 이름으로 주입한다. 
    
    → @Primary : @Autowired를 통해 생성된 Bean 객체가 다수일 때 우선순위를 지정하기 위해 주입한다. 
    
    → @Qualifier : @Primary와 유사. 우선순위가 더 높다. 
    
    → @Collection : @Autowired를 통해 생성된 모든 Bean 객체를 List 혹은 Map에 담아 모두 꺼내오는 방식.
    
    → @Resource : 개개의 @Bean으로 생성한 객체를 Collection으로 출력
    
    그 외 다수
- 가장 인상 깊게 사용한 어노테이션과 그 이유
    - @SpringBootApplication
    - @EnableAutoConfiguration Annotation을 통해 사전에 정의된 라이브러리들을 Bean으로 등록 해주며, 관리하는 방식이 Spring의 핵심인 IoC 개념에 가장 적합한 Annotation이라고 생각했기 때문
- AOP란
    - 관점 지향 프로그래밍, (Aspect Oriented Programmin) : PointCut에 Advice를 Weaving. 즉, 관점에 개입하는 방법론.
    - 어떤 로직을 기준으로 핵심적인 관점, 부가적인 관점으로 나누어서 보고 그 관점을 기준으로 각각 모듈화하겠다는 것.
    - 흩어진 관심사(Crosscutting Concerns)를 Aspect로 모듈화하고 핵심적인 비지니스 로직에서 분리하여 재사용하겠다는 것. 
    → 흩어진 관심사 : 소스 코드 상에서 다른 부분에 계속 반복해서 쓰는 코드들
- 스프링 AOP의 특징
    - 프록시 패턴 기반의 AOP 구현체
    
    → Spring은 대상 객체(Target Object)에 대한 프록시를 만들어 제공하며, 타겟을 감싸는 Proxy는 서버 Runtime 시에 생성된다. 생성된 Proxy는 대상 객체를 호출할 때 먼저 호출되어 어드바이스의 로직 처리 후 대상 객체를 호출한다.
    - 스프링 빈에만 AOP 적용 가능
    - 모든 AOP 기능을 제공하는 것이 아닌 스프링 IoC와 연동하여 엔터프라이즈 애플리케이션에서 가장 흔한 문제에 대한 해결책을 지원하는 것이 목적.
    - Method Join Point만 지원한다. 
    
    →  Spring은 동적 Proxy를 기반으로 AOP를 구현하기에 Method Join Point만 지원한다. 즉, 핵심 기능의 Method가 호출되는 런타임 시점에만 Advice를 적용할 수 있다. 
    —> 단, AspectJ 같은 별도의 AOP 프레임워크를 사용하면 객체의 생성, 필드값의 조회와 조작, static Method 호출 및 초기화 등의 다양한 작업 도중에도 Advice 수행 가능하다.
- Advice의 종류 및 설명
    
    ![Untitled](%E1%84%86%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%A5%E1%86%B8%20%E1%84%83%E1%85%A2%E1%84%87%E1%85%B5%20ac07e00912cc4f7db59b2052e54ea661/Untitled%2092.png)
    
- AOP에 사용하는 어노테이션
    - @Component : 컴포넌트 Annotation을 명시해 스프링 컨테이너가 객체를 생성하도록 한다.
    - @Aspect : 스프링 컨테이너에 AOP 담당 객체임을 알린다.
    - @Around : 횡단관심사항의 대상 지점과 적용 시점을 지정한다.
    - @Pointcut : 횡단관심사가 적용될 JoinPoint들을 정의한 것. 
    → execution(접근제어자, 반환형 패키지를 포함한 클래스 경로 메소드 파라미터)
    → within(Class의 경로)
    → Bean(bean id)
- MVC 아키텍쳐의 각 계층별 역할
    - Dispatcher Servlet : 프론트 컨트롤러의 개념으로 HTTP 프로토콜로 들어오는 클라이언트의 모든 요청을 가장 먼저 받아 적합한 컨트롤러에 위임한다. 또한, 컨트롤러가 리턴한 결과값을 적합한 View에 전달하여 알맞은 response를 생성한다.
    - Handler Mapping : request에 담긴 URL에 따라 어떤 Controller로 request를 보낼지 결정하는 계층
    - Controller : 클라이언트의 요청을 처리한 뒤 결과를 Dispatcher Servlet으로 리턴
    - ModelAndView : 컨트롤러가 처리한 결과 정보 및 뷰 선택에 필요한 정보를 담는 객체.
    - ViewResolver : 컨트롤러의 처리 결과를 생성할 View 결정
    → 논리 View 이름을 실제 View에 매핑하는 과정으로 이루어진다.
    - View : 컨트롤러의 처리 결과 화면을 생성, JSP 등의 탬플릿 파일을 View로 사용
- 스프링의 장점 3가지
    1. Spring Container : Spring은 Spring Container 또는 Application Context라고 불리는 런타임 엔진을 제공한다. Spring Container는 설정 정보를 참고하여 애플리케이션을 구성하는 오브젝트(빈)을 생성하고 관리한다. 그리고 의존성을 갖는 객체에 대해 의존성 주입(DI)를 통해 두 객체의 결합도를 낮춘다. 
    2. 공통 프로그래밍 모델 : 프레임워크는 애플리케이션을 구성하는 객체(Bean)가 생성되고 동작하는 틀을 제공해줄 뿐만 아니라, 애플리케이션 코드를 어떻게 작성해야 하는가에 대한 기준도 제공한다. 스프링에서는 3가지 핵심 프로그래밍 모델을 지원하며, 이에 맞춰 개발할 것을 권장한다. 
    → 3가지 핵심 프로그래밍 모델은 다음과 같다.
    —> IoC/DI
    —> PSA (Portable Service Abstraction, 포터블 서비스 추상화)
    —> AOP
    3. API : 스프링은 엔터프라이즈 애플리케이션을 개발할 때, 다양한 영역에 바로 활용할 수 있는 API를 제공한다. UI 작성부터 웹 프레젠테이션 계층, 비지니스 서비스 게층, 데이터 엑세스 계층 등에서 필요한 주요 기술을 일관된 방식으로 사용할 수 있도록 기능과 클래스 등을 제공한다. 그 외에 다양한 오픈소스 기술도 이용할 수 있도록 지원해주고 있다.