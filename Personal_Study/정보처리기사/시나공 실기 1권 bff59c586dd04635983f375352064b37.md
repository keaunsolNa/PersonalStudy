# 시나공 실기 1권

# 요구사항 확인

- 소프트웨어 생명 주기 B
    - 소프트웨어 생명 주기(Software Life Cycle)
        - 소프트웨어 생명 주기는 소프트웨어를 개발하기 위한 설계, 운용, 유지보수 등의 과정을 각 단계별로 나눈 것이다.
        - 소프트웨어 생명 주기는 소프트웨어 개발 단계와 각 단계별 주요 활동 그리고 활동의 결과에 대한 산출물로 표현한다.
        - 대표적인 생명 주기 보형
            - 폭포수 모형
            - 프로토타입 모형
            - 나선형 모형
            - 애자일 모형
    - 폭포수 모형(Waterfall Model)
        - 폭포수 모형은 이전 단계로 돌아갈 수 없다는 전제하에 각 단계를 확실히 매듭짓고 그 결과를 철저하게 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론이다.
        - 가장 오래되고 가장 폭넓게 사용된 전통적인 소프트웨어 생명 주기 모형이다.
        - 고전적 생명 주기 모형이라고도 한다
        - 모형을 적용한 경험과 성공 사례가 많다
        - 각 단계가 끝난 후에는 다음 단계를 수행하기 위한 결과물이 명확하게 산출되어야 한다.
    - 프로토타입 모형(Prototype Model, 원형 모형)
        - 프로토타입 모형은 사용자의 요구사항을 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측하는 모델이다.
        - 견본품은 사용자와 시스템 사이의 인터페이스에 중점을 두어 개발한다.
    - 나선형 모형(Spiral Model, 점진적 모형)
        - 나선형 모형은 나선을 따라 돌듯이 여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 완벽한 최종 소프트웨어를 개발하는 모형이다
        - 보헴(Boehm)이 제안하였다
        - 폭포수 모형과 프로토타입 모형의 장점에 위험 분석 기능을 추가한 모형이다.
        - 누락되거나 추가된 요구사항을 첨가할 수 있다.
        - 유지보수 과정이 필요 없다
    - 애자일 모형(Agile Model)
        - 애자일은 ‘민첩한’, ‘기민한’이라는 의미로, 고객의 요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형이다
        - 어느 특정 개발 방법론이 아니라 좋은 것을 빠르고 낭비 없게 만들기 위해 고객과의 소통에 초점을 맞춘 방법론을 통칭한다
        - 폭포수 모형과 대조적이다
        - 기업 활동 전반에 걸쳐 사용된다.
        - 대표적인 개발 모형
            - 스크럼(Scrum)
            - XP(eXtreme Programming)
            - 칸반(Kanban)
            - Lean
            - 기능 중심 개발(FDD; Feature Driven Development)
    - 애자일 개발 4가지 핵심 가치
        - 프로세스와 도구보다는 개인과 상호작용에 더 가치를 둔다.
        - 방대한 문서보다는 실행되는 SW에 더 가치를 둔다
        - 계약 협상보다는 고객과 협업에 더 가치를 둔다
        - 계획을 따르기 보다는 변화에 반응하는 것에 더 가치를 둔다
    - 소프트웨어 공학
        - 소프트웨어 공학(SE; Software Engineering)은 소프트웨어의 위기를 극복하기 위한 방안으로 연구된 학문이다.
        - 여러 가지 방법론과 도구, 관리 기법들을 통하여 소프트웨어의 품질과 생산성 향상을 목적으로 한다
        - 소프트웨어 공학의 기본 원칙
            - 현대적인 프로그래밍 기술을 계속적으로 적용해야 한다
            - 개발된 소프트웨어의 품질이 유지되도록 지속적으로 검증해야 한다
            - 소프트웨어 개발 관련 사항 및 결과에 대한 명확한 기록을 유지해야 한다
- 스크럼(Scrum) 기법 C
    - 스크럼(Scrum)
        - 스크럼은 팀이 중심이 되어 개발의 효율성을 높이는 기법이다
        - 팀원 스스로가 스크럼 팀을 구성하고 개발 작업에 관한 모든 것을 스스로 해결할 수 있어야 한다 .
    - 스크럼 팀
        
        
        | 구성원 | 역할 |
        | --- | --- |
        | 제품 책임자
        (PO; Product Owner) | - 요구사항이 담긴 백로그(Backlog)를 작성하는 주체 
        - 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 요구사항을 책임지고 의사를 결정할 사람으로 선정 |
        | 스크럼 마스터
        (SM; Scrum Master) | - 스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행 |
        | 개발팀 
        (DT; Development Team) | - 제품 책임자와 스크럼 마스터를 제외한 모든 팀원으로 제품 개발을 수행함 |
    - 스크럼 개발 프로세스
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled.png)
        
        | 프로세스 | 내용 |
        | --- | --- |
        | 스프린트 계획 회의
        (Sprint Planning 
        Meeting) | - 제품 백로그 중 이번 스프린트에서 수행할 작업을 대상으로 단기 일정을 수립하는 회의 |
        | 스프린트(Sprint) | - 실제 개발 작업을 진행하는 과정으로, 보통 2 ~ 4주 정도의 기간 내에서 진행함 |
        | 일일 스크럼 회의
        (Daily Scrum Meeting) | - 모든 팀원이 매일 약속된 시간에 약 15분 동안 진행 상황을 점검하는 회의 
        
        - 남은 작업 시간은 소멸 차트(Burn-down Chart)에 표시함 |
        | 스프린트 검토 회의
        (Sprint Review) | - 부분 또는 전체 완성 제품이 요구사항에 잘 부합하는지 테스팅하는 회의 |
        | 스프린트 회의
        (Sprint Retrospective) | - 정해놓은 규칙 준수 여부 및 개선할 점을 확인하고 기록하는 것 |
- XP(eXtreme Programming) 기법 B
    - XP(eXtream Programming)
        - XP는 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법이다 .
        - 짧고 반복적인 개발 주기, 단순한 설계, 고객의 적극적인 참여를 통해 소프트웨어를 빠르게 개발하는 것을 목적으로 한다.
        - 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
        - XP의 5가지 핵심 가치
            - 의사소통(Communication)
            - 단순성(Simplicity)
            - 용기(Courage)
            - 존중(Respect)
            - 피드백(Feedback)
    - XP 개발 프로세스
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%201.png)
        
        | 프로세스 | 내용 |
        | --- | --- |
        | 릴리즈 계획 수립
        (Release Planning) | - 부분 혹은 전체 개발 완료 시점에 대한 일정을 수립하는 것
        
        - 몇 개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 제공하는 것을 릴리즈라고 함 |
        | 이터레이션
        (Iteration, 주기) | - 실제 개발 작업을 진행하는 과정으로, 보통 1 ~ 3주 정도의 기간으로 진행됨 |
        | 승인 검사
        (Acceptance Test, 
        인수 테스트) | - 하나의 이터레이션 안에서 부분 완료 제품이 구현되면 수행하는 테스트 |
        | 소규모 릴리즈
        (Small Release) | - 요구사항에 유연하게 대응할 수 있도록 릴리즈의 규모를 축소한 것 |
    - XP의 주요 실천 방법(Practice)
        
        
        | 실천 방법 | 내용 |
        | --- | --- |
        | Pair Programming
        (짝 프로그래밍) | - 다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성함 |
        | Collective Ownership
        (공동 코드 소유) | - 개발 코드에 대한 권한과 책임을 공동으로 소유함 |
        | Test-Driven 
        Development
        (테스트 주도 개발) | - 개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악함
        
        - 테스트가 지속적으로 진행될 수 있도록 자동화된 테스팅 도구(구조, 프레임워크)를 사용함 |
        | Whole Team
        (전체 팀) | - 개발에 참여하는 모든 구성원(고객 포함)들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함 |
        | Continuous Integration
        (계속적인 통합) | - 모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리될 때마다 지속적으로 통합됨 |
        | Refactoring
        (리팩토링) | - 프로그램 기능의 변경 없이 시스템을 재구성함
        
        - 목적 : 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함 |
        | Small Releases
        (소규모 릴리즈) | - 릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음 |
- 개발 기술 환경 파악 C
    - 개발 기술 환경 파악의 개요
        - 개발하고자 하는 소프트웨어와 관련된 운영체제(OS), 데이터베이스 관리 시스템(DBMS), 미들웨어 등을 선정할 때 고려해야 할 사항을 기술하고, 오픈 소스를 사용할 때 주의해야 할 내용을 제시한다.
    - 운영체제(OS, Operating System)
        - 운영체제는 컴퓨터 시스템의 자원을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어이다.
        - 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종이다
        - 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다
        - 운영체제 관련 요구사항 식별 시 고려사항
            - 가용성
            - 성능
            - 기술 지원
            - 주변 기기
            - 구축 비용
    - 데이터베이스 관리 시스템(DBMS; DataBase Management System)
        - 데이터베이스 관리 시스템은 사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어이다.
        - 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다.
        - 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리한다
        - DBMS 관련 요구사항 식별 시 고려사항
            - 가용성
            - 성능
            - 기술 지원
            - 상호 호환성
            - 구축 비용
    - 웹 애플리케이션 서버(WAS; Web Application Server)
        - 웹 애플리케이션 서버는 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어이다.
        - 데이터 접근, 세션 관리, 트랜잭션 관리 등을 위한 라이브러리를 제공한다
        - 주로 데이터베이스 서버와 연동해서 사용한다
        - 웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항
            - 가용성
            - 성능
            - 기술 지원
            - 구축 비용
    - 오픈 소스(Open Source)
        - 오픈 소스는 누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어이다
        - 오픈 소스 라이선스를 만족한다
        - 오픈 소스 관련 요구사항 식별 시 고려사항
            - 라이선스의 종류
            - 사용자 수
            - 기술의 지속 가능성
- 요구 사항 정의 A
    - 요구 사항
        - 요구사항은 소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건이다
        - 소프트웨어 개발이나 유지 보수 과정에서 필요한 기준과 근거를 제공한다.
        - 개발에 참여하는 이해관계자들 간의 의사소통을 원활하게 하는 데 도움을 준다
        - 요구사항의 유형
            - 기능 요구 사항(Functional requirements)
            - 비기능 요구 사항(Non-functional requirements)
            - 사용자 요구 사항(User requirements)
            - 시스템 요구 사항(System requirements)
    - 기능 요구 사항(Functional requirements)
        - 기능 요구 사항은 시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구 사항이다.
        - 시스템의 입력이나 출력으로 무엇이 포함되어야 하는지에 대한 사항
        - 시스템이 어떤 데이터를 저장하거나 연산을 수행해야 하는지에 대한 사항
        - 시스템이 반드시 수행해야 하는 기능
        - 사용자가 시스템을 통해 제공받기를 원하는 기능
    - 비기능 요구 사항(Non-functional requirements)
        - 비기능 요구 사항은 품질이나 제약 사항과 관련된 요구 사항이다
        - 시스템 장비 구성 요구 사항
        - 성능 요구 사항
        - 인터페이스 요구 사항
        - 데이터를 구축하기 위해 필요한 요구 사항
        - 테스트 요구 사항
        - 보안 요구 사항
        - 품질 요구 사항 : 가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성 등
        - 제약 사항
        - 프로젝트 관리 요구 사항
        - 프로젝트 자원 요구 사항
    - 사용자 요구 사항(User requirements)
        - 사용자 요구 사항은 사용자 관점에서 본 시스템이 제공해야 할 요구 사항이다
        - 사용자를 위한 것으로 친숙한 표현으로 이해하기 쉽게 작성된다.
    - 시스템 요구 사항(System requirements)
        - 시스템 요구 사항은 개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에 제공해야 할 요구 사항이다
        - 사용자 요구 사항에 비해 전문적이고 기술적인 용어로 표현된다
        - 소프트웨어 요구 사항이라고도 한다
- 요구 사항 개발 프로세스 B
    - 요구 사항 개발 프로세스
        - 요구 사항 개발 프로세스는 개발 대상에 대한 요구 사항을 체계적으로 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 일련의 구조화된 활동이다.
        - 요구 사항 개발 프로세스가 진행되기 전에 타당성 조사(Feasibility Study)가 선행되어야 한다.
        - 요구 사항 개발은 요구 공학(Requirement Engineering)의 한 요소이다.
    - 요구 사항 도출(Requirement Elicitation, 요구 사항 수집)
        - 요구 사항 도출은 시스템, 사용자, 개발자 등 시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구 사항을 어떻게 수집할 것인지를 식별하고 이해하는 과정이다.
        - 개발자와 고객 사이의 관계가 만들어지고 이해관계자(Stakeholder)가 식별 된다.
        - 소프트웨어 개발 생명 주기(SDLC) 동안 지속적으로 반복된다.
        - 요구 사항 도출 주요 기법
            - 청취와 인터뷰
            - 설문
            - 브레인스토밍
            - 워크샵
            - 프로토타이핑
            - 유스케이스
    - 요구 사항 분석(Requirement Analysis)
        - 요구 사항 분석은 개발 대상에 대한 사용자의 요구 사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정이다.
        - 요구 사항의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다.
        - 서로 상충되는 요구 사항이 있으면 이를 중재하는 과정이다.
        - 요구 사항 분석에 사용되는 대표적인 도구
            - 자료 흐름도(DFD)
            - 자료 사전(DD)
    - 요구 사항 명세(Requirement Specification)
        - 요구 사항 명세는 분석된 요구 사항을 바탕으로 모델을 작성하고 문서화하는 것을 의미한다.
        - 기능 요구 사항을 빠짐없이 기술한다
        - 비기능 요구 사항은 필요한 것만 기술한다
        - 구체적인 명세를 위해 소단위 명세서(Mini-Spec)가 사용될 수 있다.
    - 요구 사항 확인(Requirement Validation, 요구 사항 검증)
        - 요구 사항 확인은 개발 자원을 요구 사항에 할당하기 전에 요구 사항 명세서가 정확하고 완전하게 작성 되었는지를 검토하는 활동이다.
        - 요구 사항 관리 도구를 이용하여 요구 사항 정의 문서들에 대해 형상 관리(SCM)를 수행한다.
    - 요구 공학(Requirement Engineering)
        - 요구 공학은 무엇을 개발해야 하는지 요구 사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문이다.
        - 요구 사항 변경의 원인과 처리 방법을 이해하고 요구 사항 관리 프로세스의 품질을 개선하여 소프트웨어 프로젝트 실패를 최소화하는 것을 목표로 한다.
    - 요구 사항 명세 기법
        
        
        | 구분 | 정형 명세 기법 | 비정형 명세 기법 |
        | --- | --- | --- |
        | 기법 | - 수학적 원리 기반, 모델 기반 | - 상태 / 기능 / 객체 중심 |
        | 작성 방법 | - 수학적 기호, 정형화된 표기법 | - 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성 |
        | 특징 | - 요구 사항을 정확하고 간결하게 표현할 수 있음
        
        - 요구 사항에 대한 결과가 작성자에 관계 없이 일관성이 있으므로 완전성 검증이 가능함 
        
        - 표기법이 어려워 사용자가 이해하기 어려움 | - 자연어의 사용으로 인해 요구 사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지고, 해석이 달라질 수 있다. 
        
        - 내용의 이해가 쉬워 의사소통이 용이하다 |
        | 종류 | - VDM, Z, Petri-net, CSP 등 | - FSM, Decision Table, ER Modeling, State Chart(SADT) 등 |
- 요구 사항 분석 B
    - 요구 사항 분석(Requirement Analysis)
        - 요구 사항 분석은 소프트웨어 개발의 실제적인 첫 단계로, 개발 대상에 대한 사용자의 요구 사항을 이해하고 문서화 하는 활동을 의미한다.
        - 사용자 요구의 타당성을 조사하고 비용과 일정에 대한 제약을 설정한다
        - 사용자의 요구를 정확하게 추출하여 목표를 정한다.
    - 구조적 분석 기법
        - 구조적 분석 기법은 자료의 흐름과 처리를 중심으로 하는 요구 사항 분석 방법이다.
        - 도형 중심의 분석용 도구와 분석 절차를 이용하여 사용자의 요구 사항을 파악하고 문서화한다.
        - 하향식 방법을 사용하여 시스템을 세분화할 수 있다.
        - 분석의 중복을 배제할 수 있다.
        - 주요 구조적 분석 기법 도구
            - 자료 흐름도(DFD)
            - 자료 사전(DD)
            - 소단위 명세서(Mini-Spec.)
            - 개체 관계도(ERD)
            - 상태 전이도(STD)
            - 제어 명세서
    - 자료 흐름도(DFD; Data Flow Diagram)
        - 자료 흐름도는 요구 사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법이다.
        - 자료 흐름 그래프, 버블 차트라고도 한다.
        - 자료 흐름과 처리를 중심으로 하는 구조적 분석 기법에 이용된다.
    - 자료 흐름도 기본 기호
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%207.png)
        
    - 자료 사전(DD; Data Dictionary)
        - 자료 사전은 자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다
        - 데이터를 설명하는 데이터로, 데이터의 데이터 또는 메타 데이터(Meta Data)라고도 한다.
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%208.png)
            
- 요구 사항 분석 CASE와 HIPO C
    - 요구 사항 분석용 CASE(자동화 도구)
        - 요구 사항 분석용 CASE는 요구 사항을 자동으로 분석하고, 요구 사항 분석 명세서를 기술하도록 개발된 도구를 의미한다.
        - 대표적인 요구 사항 분석용 CASE
            
            
            | SADT | - 시스템 정의, 소프트웨어 요구 사항 분석, 시스템/소프트웨어 설계를 위한 도구
            
            - SoftTech 사에서 개발
            
            - 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구 |
            | --- | --- |
            | SREM =
            RSL/REVS | - TRW 사가 실시간 처리 소프트웨어 시스템에서 요구 사항을 명확히 기술하도록 할 목적으로 개발한 도구
            
            - RSL 과 REVS 를 사용하는 자동화 도구 |
            | PSL/PSA | - PSL 과 PSA 를 사용하는 자동화 도구
            
            - 미시간 대학에서 개발 |
            | TAGS | - 시스템 공학 방법 응용에 대한 자동 접근 방법 
            
            - 개발 주기의 전 과정에 이용할 수 있는 통합 자동화 도구 |
    - HIPO(Hierachy Input Process Output)
        - HIPO는 시스템의 분석 및 설계, 또는 문서화에 사용되는 기법으로, 시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 것이다
        - 하향식 소프트웨어 개발을 위한 문서화 도구이다
        - 기능과 자료의 의존 관계를 동시에 표현할 수 있다
        - 기호, 도표 등을 사용하므로 보기 쉽고 이해하기도 쉽다
        - 시스템의 기능을 여러 개의 고유 모듈로 분할하여 이들 간의 인터페이스를 계층 구조로 표현한 것을 HIPO Chart라고 한다
        - HIPO Chart의 종류
            - 가시적 도표(Visual Table of Contents, 도식 목차)
            - 총체적 도표(Overview Diagram, 총괄 도표, 개요 도표)
            - 세부적 도표(Detail Diagram, 상세 도표)
- UML(Unified Modeling Language)의 개요 B
    - UML(Unified Modeling Language)
        - UML은 시스템 분석, 설계, 구현 등 시스템 개발 과정에서 시스템 개발자와 고객 또는 개발자 상호 간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어이다.
        - Rumbaugh(OMT), Booch, Jacobson 등의 객체지향 방법론의 장점을 통합하였다
        - OMG(Object Management Group)에서 표준으로 지정하였다
        - UML의 구성 요소
            - 사물(Things)
            - 관계(Relationships)
            - 다이어그램(Diagram)
    - 사물(Things)
        - 사물은 다이어그램 안에서 관계가 형성될 수 있는 대상들을 말한다.
        - 모델을 구성하는 가장 중요한 기본 요소이다.
            
            
            | 사물 | 내용 |
            | --- | --- |
            | 구조 사물
            (Structural Things) | - 시스템의 개념적, 물리적 요소를 표현 
            
            - 클래스(Class), 유스케이스(Use Case), 컴포넌트(Component), 인터페이스(Interface), 노드(Node) 등 |
            | 행동 사물
            (Behavioral  Things) | - 시간과 공간에 따른 요소들의 행위를 표현 
            
            - 상호작용(Interaction), 상태 머신(State Machine) 등 |
            | 그룹 사물
            (Grouping  Things) | - 요소들을 그룹으로 묶어서 표현 
            
            - 패키지(Packae) |
            | 주해 사물
            (Annotation  Things) | - 부가적인 설명이나 제약조건 등을 표현
            
            - 노트(Note) |
- UML - 관계(Relationship) A
    - 관계(Relationships)
        - 관계는 사물과 사물 사이의 연관성을 표현하는 것이다
        - 관계의 종류
            - 연관 관계
            - 집합 관계
            - 포함 관계
            - 일반화 관계
            - 의존 관계
            - 실체화 관계
    - 연관(Association) 관계
        - 연관 관계는 2개 이상의 사물이 서로 관련되어 있는 관계이다
        - 사물 사이를 실선으로 연결하여 표현한다
        - 방향성은 화살표로 표현한다
        - 양방향 관계의 경우 화살표를 생략하고 실선으로만 연결한다
        - 다중도를 선 위에 표시한다
            
            
            | 다중도 | 의미 |
            | --- | --- |
            | 1 | 1개의 객체가 연관되어 있다. |
            | n | n개의 객체가 연관되어 있다. |
            | 0..1 | 연관된 객체가 없거나 1개만 존재한다. |
            | 0..* 또는 * | 연관된 객체가 없거나 다수일 수 있다. |
            | 1..* | 연관된 객체가 적어도 1개 이상이다. |
            | n..* | 연관된 객체가 적어도 n개 이상이다. |
            | n..m | 연관된 객체가 최소 n개에서 최대 m개이다. |
    - 집합(Aggregation) 관계
        - 집합 관계는 하나의 사물이 다른 사물에 포함되어 있는 관계이다
        - 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립적이다
        - 포함되는 쪽(부분, Part)에서 포함하는 쪽(전체, Whole)으로 속이 빈 마름모를 연결하여 표현한다.
    - 포함(Composition) 관계
        - 포함 관계는 집합 관계의 특수한 형태로, 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계
        - 포함하는 쪽(전체, Whole)과 포함되는 쪽(부분, Part)은 서로 독립될 수 없고 생명주기를 함께한다.
        - 포함되는 쪽(부분, part)에서 포함하는 쪽(전체, Whole)으로 속이 채워진 마름모를 연결하여 표현한다.
    - 일반화(Generalization) 관계
        - 일반화 관계는 하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계이다.
        - 보다 일반적인 개념을 상위(부모), 보다 구체적인 개념을 하위(자식)라고 부른다.
        - 구체적(하위)인 사물에서 일반적(상위)인 사물 쪽으로 속이 빈 화살표를 연결하여 표현한다.
    - 의존(Dependency) 관계
        - 의존 관계는 연관 관계와 같이 사물 사이에 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계이다
        - 하나의 사물과 다른 사물이 소유 관계는 아니지만 사물의 변화가 다른 사물에도 영향을 미치는 관계이다
        - 영향을 주는 사물(이용자)이 영향을 받는 사물(제공자) 쪽으로 점선 화살표를 연결하여 표현한다
    - 실체화(Realization) 관계
        - 실체화 관계는 사물이 할 수 있거나 해야 하는 기능으로, 서로를 그룹화 할 수 있는 관계이다
        - 사물에서 기능 쪽으로 속이 빈 점선 화살표를 연결하여 표현한다
- UML - 다이어그램 A
    - 다이어그램(Diagram)
        - 다이어그램은 사물과 관계를 도형으로 표현한 것이다
        - 여러 관점에서 시스템을 가시화한 뷰(View)를 제공함으로써 의사소통에 도움을 준다
        - 정적 모델링에서는 주로 구조적 다이어그램을 사용한다
        - 동적 모델링에서는 주로 행위 다이어그램을 사용한다
    - 구조적(Structural) 다이어그램의 종류
        
        
        | 클래스 다이어그램
        (Class Diagram) | - 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한다. 
        
        - 시스템의 구조를 파악하고 구조상의 문제점을 도출할 수 있다. |
        | --- | --- |
        | 객체 다이어그램
        (Object Diagram) | - 클래스에 속한 사물(객체)들, 즉 인스턴스(Instance)를 특정 시점의 객체와 객체 사이의 관계로 표현한다. 
        
        - 럼바우(Rumbaugh) 객체지향 분석 기법에서 객체 모델링에 활용된다. |
        | 컴포넌트 다이어그램
        (Component Diagram) | - 실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현한다. 
        
        - 구현 단계에서 사용되는 다이어그램이다. |
        | 배치 다이어그램
        (Deployment Diagram) | - 결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현한다. 
        
        - 노드와 의사소통(통신) 경로로 표현한다. 
        
        - 구현 단계에서 사용되는 다이어그램이다.  |
        | 복합체 구조 다이어그램
        (Composite Structure Diagram) | - 클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현한다. |
        | 패키지 다이어그램
        (Package Diagram) | - 유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현한다. |
    - 행위(Behavioral) 다이어그램의 종류
        
        
        | 유스케이스 다이어그램
        (Use Case Diagram) | - 사용자의 요구를 분석하는 것으로 기능 모델링 작업에 사용한다. 
        
        - 사용자(Actor)와 사용 사례(Use Case)로 구성되며, 사용 사례 간에는 여러 형태의 관계로 이루어진다. |
        | --- | --- |
        | 순차 다이어그램
        (Sequence Diagram) | - 상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현한다. |
        | 커뮤니케이션 다이어그램
        (Communication Diagram) | - 순차 다이어그램과 같이 동작에 참여하는 객체들이 주고받는 메시지를 표현하는데, 메시지뿐만 아니라 객체들 간의 연관까지 표현한다.  |
        | 상태 다이어그램
        (State Diagram) | - 하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지를 표현한다. 
        
        - 럼바우(Rumbaugh) 객체지향 분석 기법에서 동적 모델링에 활용된다. |
        | 활동 다이어그램
        (Activity Diagram) | - 시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현한다. |
        | 상호작용 개요 다이어그램
        (Interaction Overview Diagram) | - 상호작용 다이어그램 간의 제어 흐름을 표현한다.  |
        | 타이밍 다이어그램
        (Timing Diagram) | - 객체 상태 변화와 시간 제약을 명시적으로 표현한다. |
    - 스테레오 타입(Stereotype)
        - 스테레오 타입은 UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것이다.
        - 길러멧(Guilemet)이라고 부르는 겹화살괄호(<<>>( 사이에 표현할 형태를 기술한다
            
            
            | 표현 형태 | 의미 |
            | --- | --- |
            | <<Include>> | 연결된 다른 UML 요소에 대해 포함 관계에 있는 경우 |
            | <<extend>> | 연결된 다른 UML 요소에 대해 확장 관계에 있는 경우 |
            | <<interface>> | 인터페이스를 정의하는 경우 |
            | <<exception>> | 예외를 정의하는 경우 |
            | <<constructor>> | 생성자 역할을 수행하는 경우 |
- 유스케이스(Use Case) 다이어그램 C
    - 기능 모델링
        - 기능 모델링은 사용자의 요구 사항을 분석하여 개발될 시스템이 갖춰야 할 기능을 정리한 후 사용자와 함께 정리된 내용을 공유하기 위해 그림으로 표현하는 것이다
        - 개발될 시스템의 전반적인 형태를 기능에 초점을 맞춰 표현한다
        - 기능 모델링의 종류
            - 유스케이스(Use Case) 다이어그램
            - 액티비티(Activity) 다이어그램
    - 유스케이스(Use Case) 다이어그램
        - 유스케이스 다이어그램은 사용자와 다른 외부 시스템들이 개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현한 것이다.
        - 외부 요소와 시스템 간의 상호 작용을 확인할 수 있다
        - 사용자의 요구 사항을 분석하기 위한 위반 도구로 사용된다
        - 시스템의 범위를 파악할  수 있다.
    - 유스케이스(Use Case) 다이어그램의 구성 요소
        
        
        | 시스템(System) / 
        시스템 범위(System Scope) | - 시스템 내부에서 수행되는 기능들을 외부 시스템과 구분하기 위해 시스템 내부의 유스케이스들을 사각형으로 묶어 시스템의 범위를 표현함 |
        | --- | --- |
        | 액터(Actor) | - 시스템과 상호작용을 하는 모든 외부 요소로, 사람이나 외부 시스템을 의미한다.
        
        - 주액터 : 시스템을 사용함으로써 이득을 얻는 대상으로, 주소 사람이 해당한다.
        
        - 부액터 : 주액터의 목적 달성을 위해 시스템에 서비스를 제공하는 외부 시스템으로, 조직이나 기관 등이 될 수 있다. |
        | 유스케이스(Use Case) | - 사용자가 보는 관점에서 시스템이 액터에게 제공하는 서비스 또는 기능을 표현한 것 |
        | 관계(Relationship) | - 유스케이스 다이어그램에서 관계는 액터와 유스케이스, 유스케이스와 유스케이스 사이에서 나타날 수 있으며, 연관 관계, 포함 관계, 확장 관계, 일반화 관계를 표현할 수 있다. |
- 활동(Activity) 다이어그램 D
    - 활동(Activity) 다이어그램
        - 활동 다이어그램은 사용자의 관점에서 시스템이 수행하는 기능을 처리 흐름에 따라 순서대로 표현한 것
        - 하나의 유스케이스 안에서 혹은 유스케이스 사이에 발생하는 복잡한 처리의 흐름을 명확하게 표현할 수 있다
        - 자료 흐름도와 유사하다
    - 활동 다이어그램의 구성 요소
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%202.png)
        
        | 구성 요소 | 내용 |
        | --- | --- |
        | 액션(Action) /
        액티비티
        (Activity) | - 액션 : 더 이상 분해할 수 없는 단일 작업
        
        - 액티비티 : 몇 개의 액션으로 분리될 수 있는 작업 |
        | 시작 노드 | - 액션이나 액티비티가 시작됨을 표현한 것 |
        | 종료 노드 | - 액티비티 안의 모든 흐름이 종료됨을 표현한 것 |
        | 조건(판단) 
        노드 | - 조건에 따라 제어의 흐름이 분리됨을 표현한 것 
        
        - 들어오는 제어 흐름은 한 개이고 나가는 제어 흐름은 여러 개 |
        | 병합 노드 | - 여러 경로의 흐름이 하나로 합쳐짐을 표현한 것
        
        - 들어오는 제어 흐름은 여러 개이고 나가는 제어 흐름은 한 개 |
        | 포크(Fork) 노드 | - 액티비티의 흐름이 분리되어 수행됨을 표현한 것
        
        - 들어오는 액티비티 흐름은 한 개이고 나가는 액티비티 흐름은 여러 개 |
        | 조인(Join) 노드 | - 분리되어 수행되던 액티비티의 흐름이 다시 합쳐짐을 표현한 것
        
        - 들어오는 액티비티 흐름은 여러 개이고 나가는 액티비티 흐름은 한 개  |
        | 스윔레인
        (Swim Lane) | - 액티비티 수행을 담당하는 주체를 구분하는 선
        
        - 가로 또는 세로 실선을 그어 구분함 |
- 클래스(CLass) 다이어그램 A
    - 정적 모델링
        - 정적 모델링은 사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것
        - 시스템에 의해 처리되거나 생성될 객체들 사이에 어떤 관련이 있는지를 구조적인 관점(View)에서 표현한다
        - 정적 모델링은 객체(Object)들을 클래스(Class)로 추상화하여 표현
        - UML을 이용한 정적 모델링의 대표적인 것이 클래스 다이어그램
    - 클래스(Class) 다이어그램
        - 클래스 다이어그램은 클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현한 것
        - 시스템을 구성하는 요소에 대해 이해할 수 있는 구조적 다이어그램이다
        - 시스템 구성 요소를 문서화하는 데 사용된다.
    - 클래스 다이어그램의 구성 요소
        
        
        | 클래스(Class) | - 클래스는 각각의 객체들이 갖는 속성과 오퍼레이션(동작)을 표현한다. 
        
        - 일반적으로 3개의 구획(Compartment)으로 나눠 클래스의 이름, 속성, 오퍼레이션을 표기한다.
        
        - 속성(Attribute) : 클래스의 상태나 정보를 표현
        
        -오퍼레이션(Operation) : 클래스가 수행할 수 있는 동작으로, 함수(메소드, Method)라고도 한다. |
        | --- | --- |
        | 제약조건 | - 속성에 입력될 값에 대한 제약조건이나 오퍼레이션 수행 전후에 지정해야 할 조건이 있다면 이를 적는다. |
        | 관계(Relationships) | - 관계는 클래스와 클래스 사이의 연관성을 표현한다. 
        
        - 클래스 다이어그램에 표현하는 관계에는 연관 관계, 집합 관계, 포함 관계, 일반화 관계, 의존 관계가 있다. |
    - 연관 클래스
        - 연관 클래스는 연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스
        - 두 클래스의 연관 관계를 나타내는 선의 가운데로부터 점선을 연관 클래스로 이어 표시한다
        - 연관 클래스의 이름은 연관 관계의 이름을 이용해 지정한다
- 순차(Sequence) 다이어그램 B
    - 동적 모델링
        - 동적 모델링은 시스템의 내부 구성 요소들의 상태 변화 과정과 과정에서 발생하는 상호 작용을 표현한 것
        - 시스템 내구 구성 요소들 간에 이루어지는 동작이라는 관점(View)에서 표현한다
        - 시스템이 실행될 때 구성 요소들 간의 메시지 호출, 즉 오퍼레이션을 통한 상호 작용에 초점을 둔다
        - 동적 모델링의 종류
            - 순차 다이어그램
            - 커뮤니케이션 다이어그램
            - 상태 다이어그램
    - 순차(Sequence) 다이어그램
        - 순차 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정을 그림으로 표현한 것
        - 시스템이나 객체들의 상호 작용 과정에서 주고받는 메시지를 표현한다
        - 각 동작에 참여하는 시스템이나 객체들의 수행 기간을 확인할 수 있다
        - 클래스 내부에 있는 객체들을 기본 단위로 하여 그들의 상호 작용을 표현한다
    - 순차 다이어그램의 구성 요소
        
        
        | 액터(Actor) | - 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미한다. |
        | --- | --- |
        | 객체(Object) | - 메시지를 주고받는 주체 |
        | 생명선(Lifeline) | - 객체가 메모리에 존재하는 기간으로, 객체 아래쪽에 점선을 그어 표현한다.
        
        - 객체 소멸이 표시된 기간까지 존재한다.  |
        | 실행 상자(Active Box
        , 활성 상자) | - 객체가 메시지를 주고받으며 구동되고 있음을 표현 |
        | 메시지(Message) | - 객체가 상호 작용을 위해 주고받는 메시지 |
        | 객체 소멸 |  - 해당 객체가 더 이상 메모리에 존재하지 않음을 표현한 것 |
        | 프레임(Frame) | - 다이어그램의 전체 또는 일부를 묶어 표현한 것  |
- 커뮤니케이션(Communication) 다이어그램 D
    - 커뮤니케이션(Communication) 다이어그램
        - 커뮤니케이션 다이어그램은 시스템이나 객체들이 메시지를 주고받으며 상호 작용하는 과정과 객체들 간의 연관을 그림으로 표현한 것
        - 동작에 참여하는 객체들 사이의 관계를 파악하는 데 사용
        - 클래스 다이어그램에서 관계가 제대로 표현됐는지 점검하는 용도로도 사용
        - 초기에는 협업(Collaboration) 다이어그램이라고 불렸다
    - 커뮤니케이션 다이어그램의 구성 요소
        
        
        | 구성 요소 | 의미 |
        | --- | --- |
        | 액터(Actor) | - 시스템으로부터 서비스를 요청하는 외부 요소로, 사람이나 외부 시스템을 의미  |
        | 객체(Object) | - 메시지를 주고받는 주체 |
        | 링크(Link) | - 객체들 간의 관계를 표현한 것 
        
        - 액터와 객체, 객체와 객체 간의 실선을 그어 표현함  |
        | 메시지
        (Message) | - 객체가 상호 작용을 위해 주고받는 내용 
        
        - 화살표의 방향은 메시지를 받는 쪽으로 향하게 표현 
        
        - 일정한 순서에 의해 처리되는 메시지의 경우 숫자로 순서를 표시  |
- 상태(State) 다이어그램 D
    - 상태(State) 다이어그램
        - 상태 다이어그램은 객체들 사이에 발생하는 이벤트에 의한 객체들의 상태 변화를 그림으로 표현한 것
        - 객체의 상태란 객체가 갖는 속성 값의 변화를 의미한다
        - 특정 객체가 어떤 이벤트에 의해 상태 변환 과정이 진행되는지 확인하는 용도로 사용
        - 시스템에서 상태 변환 이벤트를 확인할 필요가 있는 객체만을 대상으로 그린다
    - 상태 다이어그램의 구성 요소
        
        
        | 구성 요소 | 의미 |
        | --- | --- |
        | 상태(State) | - 객체의 상태를 표현한 것 |
        | 시작 상태 | - 상태의 시작을 표현한 것 |
        | 종료 상태 | - 상태의 종료를 표현한 것 |
        | 상태 전환 | - 상태 사이의 흐름, 변화를 화살표로 표현한 것 |
        | 이벤트(Event) | - 상태에 변화를 주는 현상
        
        - 이벤트에는 조건, 외부 신호, 시간의 흐름 등이 있다. |
        | 프레임(Frame) | - 상태 다이어그램의 범위를 표현한 것  |
- 패키지(Package) 다이어그램 B
    - 패키지(Package) 다이어그램
        - 패키지 다이어그램은 유스케이스나 클래스 등의 요소들을 그룹화한 패키지 간의 의존 관계를 표현한 것
        - 패키지는 또 다른 패키지의 요소가 될 수 있다
        - 대규모 시스템에서 주요 요소 간의 종속성을 파악하는 데 사용한다
    - 패키지 다이어그램의 구성 요소
        
        
        | 구성 요소 | 의미 |
        | --- | --- |
        | 패키지
        (Package) | - 객체들을 그룹화한 것
        
        - 단순 표기법 : 패키지 안에 패키지 이름만 표현 
        
        - 확장 표기법 : 패키지 안에 요소까지 표현 |
        | 객체
        (Object) | - 유스케이스, 클래스, 인터페이스, 테이블 등 패키지에 포함될 수 있는 다양한 요소들 |
        | 의존 관계
        (Dependency) | - 패키지와 패키지, 패키지와 객체 간을 점선 화살표로 연결하여 표현
        
        - 스트레오타입을 이용해 의존 관계를 구체적으로 표현할 수 있음 
        
        - 의존 관계의 표현 형태는 사용자가 임의로 지정할 수 있으며, 대표적으로 import와 access가 사용됨 
          - <<import>> : 패키지에 포함된 객체들을 직접 가져와서 이용하는 관계
          - <<access>> : 인터페이스를 통해 패키지 내의 객체에 접근하여 이용하는 관계  |
- 소프트웨어 개발 방법론 C
    - 소프트웨어 개발 방법론
        - 소프트웨어 개발 방법론은 소프트웨어 개발, 유지보수 등에 필요한 여러 가지 일들의 수행 방법과 이러한 일들을 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화한 것이다
        - 소프트웨어 개발 방법론의 목적은 소프트웨어의 생산성과 품질 향상이다
        - 주요 소프트웨어 개발 방법론
            - 구조적 방법론
            - 정보공학 방법론
            - 객체지향 방법론
            - 컴포넌트 기반 방법론
            - 제품 계열 방법론
            - 애자일 방법론
    - 구조적 방법론
        - 구조적 방법론은 정형화된 분석 절차에 따라 사용자 요구사항을 파악하여 문서화하는 처리(Process) 중심의 방법론이다.
        - 1960년대까지 가장 많이 적용되었던 소프트웨어 개발 방법론이다
        - 쉬운 이해 및 검증이 가능한 프로그램 코드를 생성하는 것이 목적이다
        - 복잡한 문제를 다루기 위해 분할과 정복(Divide and Conquer) 원리를 적용한다
        - 구조적 방법론 개발 절차
            - 타당성 검토 단계 ⇒ 계획 단계 ⇒ 요구사항 단계 ⇒ 설계 단계 ⇒ 구현 단계 ⇒ 시험 단계 ⇒ 운용/유지보수 단계
    - 정보공학 방법론
        - 정보공학 방법론은 정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 상호 연관성 있게 통합 및 적용하는 자료 중심의 방법론이다
        - 정보 시스템 개발 주기를 이용하여 대규모 정보 시스템을 구축하는데 적합하다
        - 정보공학 방법론 개발 절차
            - 정보 전략 계획 수립 단계 ⇒ 업무 영역 분석 단계 ⇒ 업무 시스템 설계 단계 ⇒ 업무 시스템 구축 단계
    - 객체지향 방법론
        - 객체지향 방법론은 현실 세계의 개체(Entitiy)를 기계의 부품처럼 하나의 객체(Object)로 만들어, 소프트웨어를 개발할 때 기계의 부품을 조립하듯이 객체들을 조립해서 필요한 소프트웨어를 구현하는 방법론이다
        - 객체지향 방법론은 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되었다
        - 객체지향 방법론의 구성 요소 : 객체, 클래스, 메시지 등
        - 객체지향 방법론의 기본 원칙 : 캡슐화, 정보 은닉, 추상화, 상속성, 다형성 등
        - 객체지향 방법론의 개발 절차
            - 요구 분석 단계 ⇒ 설계 단계 ⇒ 구현 단계 ⇒ 테스트 및 검증 단계 ⇒ 인도 단계
    - 컴포넌트 기반(CBD; Component Based Design) 방법론
        - 컴포넌트 기반 방법론은 기존의 시스템이나 소프트웨어를 구성하는 컴포넌트를 조합하여 하나의 새로운 애플리케이션을 만드는 방법론이다
        - 컴포넌트의 재사용(reusability)이 가능하여 시간과 노력을 절감할 수 있다
        - 새로운 기능을 추가하는 것이 간단하여 확장성이 보장된다
        - 유지 보수 비용을 최소화하고 생산성 및 품질을 향상 시킬 수 있다
        - 컴포넌트 기반 방법론의 개발 절차
            - 개발 준비 단계 ⇒ 분석 단계 ⇒ 설계 단계 ⇒ 구현 단계 ⇒ 테스트 단계 ⇒ 전개 단계 ⇒ 인도 단계
    - 제품 계열 방법론
        - 제품 계열 방법론은 특정 제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론이다
        - 임베디드 소프트웨어를 만드는데 적합하다
        - 제품 계열 방법론은 영역공학과 응용공학으로 구분된다
            - 영역공학 : 영역 분석, 영역 설계, 핵심 자산을 구현하는 영역
            - 응용공학 : 제품 요구 분석, 제품 설계, 제품을 구현하는 영역
        - 영역공학과 응용공학의 연계를 위해 제품의 요구사항, 아키텍처, 조립 생산이 필요하다
- S/W 공학의 발전적 추세 B
    - 소프트웨어 재사용(Software Reuse)
        - 소프트웨어 재사용은 이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것
        - 소프트웨어 개발의 품질과 생산성을 높이기 위한 방법
        - 기존에 개발된 소프트웨어와 경험, 지식 등을 새로운 소프트웨어에 적용한다
        - 소프트웨어 재사용 방법
            - 합성 중심(Composition-Based) : 전자 칩과 같은 소프트웨어 부품, 즉 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법으로, 블록 구성 방법이라고도 한다
            - 생성 중심(Generation-Based) : 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법으로, 패턴 구성 방법이라고도 한다
    - 소프트웨어 재공학(Software Reengineering)
        - 소프트웨어 재공학은 새로운 요구에 맞도록 기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것이다
        - 유지보수 비용이 소프트웨어 개발 비용의 대부분을 차지하기 때문에 유지보수의 생산성 향상을 통해 소프트웨어 위기를 해결하는 방법
        - 기존 소프트웨어의 데이터와 기능들의 개조 및 개선을 통해 유지보수성과 품질을 향상시킨다
        - 소프트웨어 재공학의 이점
            - 소프트웨어의 품질 향상
            - 소프트웨어의 생산성 증가
            - 소프트웨어의 수명 연장
            - 소프트웨어의 오류 감소
    - CASE(Computer Aided Software Engineering)
        - CASE는 소프트웨어 개발 과정에서 사용되는 요구 분석, 설계, 구현, 검사 및 디버깅 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것이다
        - 객체지향 시스템, 구조적 시스템 등 다양한 시스템에서 활용되는 자동화 도구(CASE Tool)이다
        - 소프트웨어 생명 주기의 전체 단계를 연결하고 자동화하는 통합된 도구를 제공한다
        - 소프트웨어 개발 도구와 방법론이 결합되었으며, 정형화된 구조 및 방법을 소프트웨어 개발에 적용하여 생산성 향상을 구현한다
        - CASE의 주요 기능
            - 소프트웨어 생명 주기 전 단계의 연결
            - 다양한 소프트웨어 개발 모형 지원
            - 그래픽 지원
- 비용 산정 기법 - 하향식 D
    - 하향식 비용 산정 기법
        - 하향식 비용 산정 기법은 과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 비과학적인 방법이다
        - 프로젝트의 전체 비용을 산정한 후 각 작업별로 비용을 세분화한다
        - 하향식 비용 산정 기법
            - 전문가 감정 기법
            - 델파이 기법
    - 전문가 감정 기법
        - 전문가 감정 기법은 조직 내에 있는 경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법
        - 가장 편리하고 신속하게 비용을 산정할 수 있다
        - 의뢰자로부터 믿음을 얻을 수 있다
        - 개인적이고 주관적일 수 있다
    - 델파이 기법
        - 델파이 기법은 전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법
        - 전문가들의 편견이나 분위기에 지배되지 않도록 한 명의 조정자와 여러 전문가로 구성된다.
- 비용 산정 기법 - 상향식 A
    - 상향식 비용 산정 기법
        - 상향식 비용 산정 기법은 프로젝트의 세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법이다
        - 주요 상향식 비용 산정 기법
            - LOC 기법
            - 개발 단계별 인월수 기법
            - 수학적 산정 기법
    - LOC(원시 코드 라인 수, source Line Of Code) 기법
        - LOC 기법은 소프트웨어 각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법
        - 측정이 용이하고 이해하기 쉬워 가장 많이 사용된다
        - 예측치를 이용하여 생산성, 노력, 개발 기간 등의 비용을 산정한다
            - 예측치 = 낙관치 + (4 * 기대치[중간치]) + 비관치 / 6
        - 산정 공식
            - 노력(인월) = 개발 기간 X 투입 인원
                              = LOC / 1인당 월평균 생산 코드 라인 수
            - 개발 비용 = 노력(인월) X 단위 비용(1인당 월평균 인건비)
            - 개발 기간 = 노력(인월) / 투입 인원
            - 생산성 = LOC / 노력(인월)
    - 개발 단계별 인월수(Effort Per Task) 기법
        - 개발 단계별 인월수 기법은 LOC 기법을 보완하기 위한 기법으로, 각 기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정한다
        - LOC 기법보다 더 정확하다
- 수학적 산정 기법 B
    - 수학적 산정 기법
        - 수학적 산정 기법은 상향식 비용 산정 기법으로, 경험적 추정 모형, 실험적 추정 모형이라고도 한다
        - 수학적 산정 기법은 개발 비용 산정의 자동화를 목표로 한다
        - 비용의 자동산정을 위해 사용되는 공식은 과거의 유사한 프로젝트를 기반으로 유도된 것이다
        - 주요 수학적 산정 기법
            - COCOMO 모형
            - Putnam 모형
            - 기능 점수(FP) 모형
    - COCOMO(COnstructive COst MOdel) 모형
        - COCOMO 모형은 원시 프로그램의 규모인 LOC(원시 코드 라인 수)에 의한 비용 산정 기법
        - 개발할 소프트웨어의 규모(LOC)를 예측한 후 이를 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 비용을 산정한다
        - 비용 산정 결과는 프로젝트를 완성하는 데 필요한 노력(Man-Month)으로 나타난다
        - 보헴(Boehm)이 제안하였다
    - COCOMO의 소프트웨어 개발 유형
        
        
        | 유형 | 특징 |
        | --- | --- |
        | 조직형
        (Organic Mode) | - 기관 내부에서 개발된 중,소 규모의 소프트웨어 
        
        - 일괄 자료 처리나 과학기술 계산용, 비즈니스 자료 처리용 등 
        
        - 사무 처리용, 업무용, 과학용 응용 소프트웨어 개발에 적합 |
        | 반분리형
        (Semi-Detached
        Mode) | - 조직형과 내장형의 중간형 소프트웨어 
        
        - 트랜잭션 처리 시스템이나 운영체제, 데이터베이스 관리 시스템 등의 30만(300KDSI) 라인 이하의 소프트웨어를 개발하는 유형 
        
        - 컴파일러, 인터프리터와 같은 유틸리티 개발에 적합  |
        | 내장형
        (Embedded Mode) | - 초대형 규모의 소프트웨어 
        
        - 트랜잭션 처리 시스템이나 운영체제 등의 30만(300KDSI) 라인 이상의 소프트웨어를 개발하는 유형 
        
        - 신호기 제어 시스템, 미사일 유도 시스템, 실시간 처리 시스템 등의 시스템 프로그램 개발에 적합 |
    - COCOMO 모형의 종류
        
        
        | 종류 | 특징 |
        | --- | --- |
        | 기본형(Basic)
        COCOMO | - 소프트웨어의 크기와 개발 유형만을 이용하여 비용 산정  |
        | 중간형
        (Intermediate)
        COCOMO | - 기본형 COCOMO의 공식을 토대로 사용하나, 다음 4가지 특성에 의해 비용 산정 
        
        ⇒ 제품의 특성 
        ⇒ 컴퓨터의 특성
        ⇒ 개발 요원의 특성
        ⇒ 프로젝트 특성 |
        | 발전형(Detailed)
        COCOMO | - 중간형 COCOMO를 보완하여 만들어진 모형
        
        - 개발 공정별로 보다 자세하고 정확하게 노력을 산출하여 비용 산정 
        
        - 소프트웨어 환경과 구성 요소가 사전에 정의되어 있어야 하며, 개발 과정의 후반부에 주로 적용 |
    - Putnam 모형
        - Putnam 모형은 소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형
        - 푸트남(Putnam)이 제안한 것으로, 생명 주기 예측 모형이라고도 한다
        - 시간에 따른 함수로 표현되는 Rayleigh-Norden 곡선의 노력 분포도를 기초로 한다
        - 대형 프로젝트의 노력 분포 산정에 이용된다
        - 개발 기간이 늘어날수록 프로젝트 적용 인원의 노력이 감소한다
    - 기능 점수(FP; Function Point) 모형
        - 기능 점수 모형은 소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여 하고, 요인별 가중치를 합산하여 총 기능 점수를 산출하며, 총 기능 점수와 영향도를 이용하여 기능 점수(FP)를 구한 후 이를 이용해서 비용을 산정하는 기법
        - 알브레히트(Albrecht)가 제안
        - 소프트웨어 기능 증대 요인
            - 자료 입력(입력 양식)
            - 정보 출력(출력 보고서)
            - 명령어(사용자 질의수)
            - 데이터 파일
            - 필요한 외부 루틴과의 인터페이스
    - 비용 산정 자동화 추정 도구
        - SLIM : Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구
        - ESTIMACS : 다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구
- 프로젝트 일정 계획 B
    - 프로젝트 일정(Scheduling) 계획
        - 프로젝트 일정 계획은 프로젝트의 프로세스를 이루는 소작업을 파악하고 예측된 노력을 각 소작업에 분배하여 소작업의 순서와 일정을 정하는 것
        - 프로젝트 일정 계획에 사용되는 기능 : WBS, PERT/CPM, 간트 차트 등
    - PERT(Program Evaluation and Review Technique, 프로그램 평가 및 검토 기술)
        - PERT는 프로젝트에 필요한 전체 작업의 상호 관계를 표시하는 네트워크
        - 각 작업별로 다음과 같이 단계를 나누어 종료시기를 결정
            - 낙관적인 경우
            - 가능성이 있는 경우
            - 비관적인 경우
        - 개발 경험이 없어 소요 기간 예측이 어려운 프로젝트 일정 계획에 사용
        - 노드와 간선으로 구성되며 원 노드에는 작업을, 간선에는 낙관치, 기대치, 비관치를 표시한다
        - 결정 경로, 작업에 대한 경계 시간, 작업 간의 상호 관련성 등을 알 수 있다
        - 작업 예측치 계산 공식
            - 작업 예측치 = 비관치 + 4 X 기대치 + 낙관치 / 6
            - 평방 편차 = [(비관치 - 낙관치) / 6]²
    - CPM(Critical Path Method, 임계 경로 기법)
        - CPM은 프로젝트 완성에 필요한 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법
        - CPM은 노드와 간선으로 구성된 네트워크로 노드는 작업을, 간선은 작업 사이의 전후 의존 관계를 나타낸다
        - 원형 노드는 각각의 작업을 의미하며, 작업 이름과 소요 기간을 표시한다
        - 박스 노드는 이정표를 의미하며, 이정표 이름과 예상 완료 시간을 표시한다
        - 간선을 나타내는 화살표의 흐름에 따라 각 작업이 진행되며, 전 작업이 완료 되어야 다음 작업을 진행할 수 있다
    - 간트 차트
        - 간트 차트는 프로젝트의 각 작업들이 언제 시작하고 언제 종료되는지에 대한 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표
        - 시간선(Time-Line) 차트라고도 한다
        - 중간 목표 미달성 시 그 이유와 기간을 예측할 수 있게 한다
        - 사용자와의 문제점이나 예산의 초과 지출 등도 관리할 수 있게 한다
        - 자원 배치와 인원 계획에 유용하게 사용된다
        - 이정표, 작업 일정, 작업 기간, 산출물로 구성되어 있다
        - 수평 막대의 길이는 각 작업(Task)의 기간을 나타낸다
- 소프트웨어 개발 방법론 결정 C
    - 소프트웨어 개발 방법론 결정
        - 소프트웨어 개발 방법론을 결정하는 것은 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영하고, 확정된 소프트웨어 생명 주기와 개발 방법론에 맞춰 소프트웨어 개발 단계, 활동, 작업, 절차 등을 정의하는 것
        - 소프트웨어 개발 방법론 결정 절차
            - 프로젝트 관리와 재사용 현황을 소프트웨어 개발 방법론에 반영
            - 개발 단계별 작업 및 절차를 소프트웨어 생명 주기에 맞춰 수립
            - 결정된 소프트웨어 개발 방법론의 개발 단계별 활동 목적, 작업 내용, 산출물에 대한 매뉴얼 작성
    - 프로젝트 관리(Project Management)
        - 프로젝트 관리는 주어진 기간 내에 최소의 비용으로 사용자를 만족시키는 시스템을 개발하기 위한 전반적인 활동이다.
            
            
            | 관리 유형 | 주요 내용 |
            | --- | --- |
            | 일정 관리 | 작업 순서, 작업 기간 산정, 일정 개발, 일정 통제 |
            | 비용 관리 | 비용 산정, 비용 예산 편성, 비용 통제 |
            | 인력 관리 | 프로젝트 팀 편성, 자원 산정, 프로젝트 조직 정의, 프로젝트 팀 개발, 자원 통제, 프로젝트 팀 관리 |
            | 위험 관리 | 위험 식별, 위험 평가, 위험 대체, 위험 통제 |
            | 품질 관리 | 품질 계획, 품질 보증 수행, 품질 통제 수행 |
- 소프트웨어 개발 표준 B
    - 소프트웨어 개발 표준
        - 소프트웨어 개발 표준은 소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준을 의미한다
        - 주요 소프트웨어 개발 표준
            - ISO/IEC 12207
            - CMMI(능력 성숙도 통합 모델)
            - SPICE(소프트웨어 처리 개선 및 능력 평가 기준)
    - ISO/IEC 12207
        - ISO/IEC 12207은 ISO(국제표준화기구)에서 만든 표준 소프트웨어 생명 주기 프로세스이다
        - 소프트웨어의 개발, 운영, 유지보수 등을 체계적으로 관리하기 위한 소프트웨어 생명 주기 표준을 제공한다.
        - ISO/IEC 12207 구분
            - 기본 생명 주기 프로세스 : 획득, 공급, 개발, 운영, 유지보수 프로세스
            - 지원 생명 주기 프로세스 : 품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결 프로세스
            - 조직 생명 주기 프로세스 : 관리, 기반 구조, 훈련, 개선 프로세스
    - CMMI(Capability Maturity Model Integration)
        - CMMI는 소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델
        - 미국 카네기멜론 대학교의 소프트웨어 공학연구소(SEI)에서 개발
        - CMMI의 소프트웨어 프로세스 성숙도
            
            
            | 단계 | 프로세스  | 특징 |
            | --- | --- | --- |
            | 초기(Inital) | 정의된 프로세스 없음 | 작업자 능력에 따라 성공 여부 결정 |
            | 관리(Managed) | 규칙화된 프로세스 | 특정한 프로젝트 내의 프로세스 정의 및 수행 |
            | 정의(Defined) | 표준화된 프로세스 | 조직의 표준 프로세스를 활용하여 업무 수행 |
            | 정량적 관리
            (Quantitatively
            Managed) | 예측 가능한 프로세스 | 프로젝트를 정량적으로 관리 및 통제 |
            | 최적화
            (Optimizing) | 지속적 개선 프로세스 | 프로세스 역량 향상을 위해 지속적인 프로세스 개선 |
    - SPICE(Software Process Improvement and Capability dEtermination)
        - SPICE는 정보 시스템 분야에서 소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준이다
        - 공식 명칭은 ISO/IEC 15504이다
    - SPICE의 구성
        
        
        | 범주 | 특징 |
        | --- | --- |
        | 고객-공급자
        (Customer-Supplier)
        프로세스 | - 소프트웨어를 개발하여 고객에게 전달하는 것을 지원하고, 소프트웨어의 정확한 운용 및 사용을 위한 프로세스로 구성된다. 
        
        - 구성 요소 : 인수, 공급, 요구 도출, 운영
        
        - 프로세스 수 : 10개 |
        | 공학(Engineering)
        프로세스 | - 시스템과 소프트웨어 제품의 명세화, 구현, 유지보수를 하는데 사용되는 프로세스로 구성된다. 
        
        - 구성 요소 : 개발, 소프트웨어 유지보수
        
        - 프로세스 수 : 9개 |
        | 지원(Support)
        프로세스 | - 소프트웨어 생명 주기에서 댜른 프로세스에 의해 이용되는 프로세스로 구성된다.
        
        - 구성 요소 : 문서화, 형상, 품질 보증, 검증, 확인, 리뷰, 감사, 품질 문제 해결
        
        - 프로세스 수 : 8개 |
        | 관리(Management)
        프로세스 | - 소프트웨어 생명 주기에서 프로젝트 관리자에 의해 사용되는 프로세스로 구성된다. 
        
        - 구성 요소 : 관리, 프로젝트 관리, 품질 및 위험 관리
        
        - 프로세스 수 : 4개 |
        | 조직(Organization)
        프로세스 | - 조직의 업무 목적 수립과 조직의 업무 목표 달성을 위한 프로세스로 구성된다. 
        
        - 구성 요소 : 조직 배치, 개선 활동 프로세스, 인력 관리, 기반 관리, 측정 도구, 재사용
        
        - 프로세스 수 : 9개 |
    - SPICE의 프로세스 수행 능력 단계
        
        
        | 단계 | 특징 |
        | --- | --- |
        | Level 0 - 불완전(Imcomplete) | 프로세스가 구현되지 않았거나 목적을 달성하지 못한 단계 |
        | Level 1 - 수행(Performed) | 프로세스가 수행되고 목적이 달성된 단계 |
        | Level 2 - 관리(Managed) | 정의된 자원의 한도 내에서 그 프로세스가 작업 산출물을 인도하는 단계 |
        | Level 3 - 확립(Established) | 소프트웨어 공학 원칙에 기반하여 정의된 프로세스가 수행되는 단계 |
        | Level 4 - 예측(Predictable) | 프로세스가 목적 달성을 위해 통제되고, 양적인 측정을 통해 일관되게 수행되는 단계 |
        | Level 5 - 최적화(Optimizing) | 프로세스 수행을 최적화하고, 지속적인 개선을 통해 업무 목적을 만족시키는 단계 |
- 소프트웨어 개발 방법론 테일러링 C
    - 소프트웨어 개발 방법론 테일러링
        - 소프트웨어 개발 방법론 테일러링은 프로젝트 상황 및 특성에 맞도록 정의된 소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업
        - 소프트웨어 개발 방법론 테일러링 수행 절차
            - 프로젝트 특징 정의 ⇒ 표준 프로세스 선정 및 검증 ⇒ 상위 수준의 커스터마이징 ⇒ 세부 커스터마이징 ⇒ 테일러링 문서화
    - 소프트웨어 개발 방법론 테일러링 고려사항
        
        
        | 기준 | 내용 |
        | --- | --- |
        | 내부적 기준 | - 목표 환경 : 시스템의 개발 환경과 유형이 서로 다른 경우 테일러링이 필요하다
        
        - 요구사항 : 프로젝트의 생명 주기 활동에서 개발, 운영, 유지보수 등 프로젝트에서 우선적으로 고려할 요구사항이 서로 다른 경우 테일러링이 필요하다.
        
        - 프로젝트 규모 : 비용, 인력, 기간 등 프로젝트의 규모가 서로 다른 경우 테일러링이 필요하
        다
        - 보유 기술 : 프로세스, 개발 방법론, 산출물, 구성원의 능력 등이 서로 다른 경우 테일러링이 필요하다 |
        | 외부적 기준 | - 법적 제약사항 : 프로젝트별로 적용될 IT Compliance가 서로 다른 경우 테일러링이 필요하다
        
        - 표준 품질 기준 : 금융, 제도 등 분야별 표준 품질 기준이 서로 다른 경우 테일러링이 필요하다 |
- 소프트웨어 개발 프레임워크 B
    - 소프트웨어 개발 프레임워크
        - 프레임워크(Framework)는 소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 손쉽게 구현할 수 있도록 여러 가지 기능들을 제공해주는 반제품 형태의 소프트웨어 시스템
        - 선행 사업자의 기술에 의존하지 않은 표준화된 개발 기반으로 인해 사업자 종속성이 해소된다.
        - 소프트웨어 개발 프레임워크의 주요 기능
            - 예외 처리
            - 트랜잭션 처리
            - 메모리 공유
            - 데이터 소스 관리
            - 서비스 관리
            - 쿼리 서비스
            - 로깅 서비스
            - 사용자 인증 서비스
        - 소프트웨어 개발 프레임워크의 종류
            - 스프링 프레임워크
            - 전자정부 프레임워크
            - 닷넷 프레임워크
    - 스프링 프레임워크(Spring Framework)
        - 스프링 프레임워크는 자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크이다.
            - 동적인 웹 사이트의 개발을 위해 다양한 서비스를 제공한다
            - 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다
    - 전자정부 프레임워크
        - 전자정부 프레임워크는 우리나라의 공공부문 정보화 사업 시 효율적인 정보 시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크이다
            - 전자정부 프레임워크는 개발 프레임워크의 표준 정립으로 응용 소프트웨어의 표준화, 품질 및 재사용성의 향상을 목적으로 한다.
            - 오픈 소스 기반의 범용화를 이룰 수 있다
            - 공개된 기술을 활용함으로써 특정 업체의 종속성을 배제하고 사업별 공통 컴포넌트의 중복 개발을 방지한다
    - 닷넷 프레임워크(.NET Framework)
        - 닷넷 프레임워크는 Windows 프로그램의 개발 및 실행 환경을 제공하는 프레임워크
        - Microsoft 사에서 통합 인터넷 전략을 위해 개발
        - 코드 실행을 관리하는 CLR(Common Language Runtime, 공용 언어 런타임)이라는 이름의 가상머신 상에서 작동
    - 소프트웨어 개발 프레임워크의 특성
        
        
        | 특성 | 내용 |
        | --- | --- |
        | 모듈화
        (Modularity) | - 프레임워크는 캡슐화를 통해 모듈화를 강화하고 설계 및 구현의 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시킴
        
        - 프레임워크는 개발 표준에 의한 모듈화로 인해 유지 보수가 용이 |
        | 재사용성
        (Reusability) | - 프레임워크는 재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능함 |
        | 확장성
        (Extensibility) | - 프레임워크는 다형성(Polymorphism)을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능 |
        | 제어의 역흐름
        (Inversion of 
        Control) | - 개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상  |

# 데이터 입,출력 구현

- 데이터베이스 개요 B
    - 데이터저장소
        - 데이터저장소는 데이터들을 논리적인 구조로 조직화하거나, 물리적인 공간에 구축한 것을 의미한다
        - 논리 데이터저장소는 데이터 및 데이터 간의 연관성, 제약조건을 식별하여 논리적인 구조로 조직화한 것이다
        - 물리 데이터저장소는 논리 데이터저장소를 소프트웨어가 운용될 환경의 물리적 특성을 고려하여 실제 저장장치에 저장한 것을 의미한다.
    - 데이터베이스(DataBase)
        - 데이터베이스는 여러 사람에 의해 공동으로 사용될 데이터를 중복을 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터이다.
        - 데이터베이스는 다음과 같이 구분하여 정의할 수 있다
            - 통합된 데이터(Integrated Data) : 자료의 중복을 배제한 데이터의 모임
            - 저장된 데이터(Stored Data) : 컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료
            - 운영 데이터(Operational Data) : 조직의 고유한 업무를 수행하는 데 반드시 필요한 자료
            - 공용 데이터(Shared Data) : 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료
    - DBMS(DataBase Management System; 데이터베이스 관리 시스템)
        - DBMS는 사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어이다.
        - 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템이다
        - DBMS의 필수 기능
            
            
            | 정의(Definition) 기능 | 데이터의 형(Type)과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능 |
            | --- | --- |
            | 조직(Manipulation) 기능 | 데이터 검색, 갱신, 삽입, 삭제 등을 위해 인터페이스 수단을 제공하는 기능 |
            | 제어(Control) 기능 | 데이터의 무결성, 보안, 권한 검사, 병행 제어를 제공하는 기능 |
    - 데이터의 독립성
        
        
        | 논리적 독립성 | 응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음 |
        | --- | --- |
        | 물리적 독립성 | 응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않음 |
    - 스키마(Schema)
        - 스키나는 데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것
        
        | 종류 | 내용 |
        | --- | --- |
        | 외부 스키마 | -사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것 |
        | 개념 스키마 | - 데이터베이스의 전체적인 논리적 구조 
        
        - 모든 응용 프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스로, 하나만 존재함 |
        | 내부 스키마 | - 물리적 저장장치의 입장에서 본 데이터베이스 구조 
        
        - 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타낸다.  |
- 데이터베이스 설계 A
    - 데이터베이스 설계
        - 데이터베이스 설계는 사용자의 요구를 분석하여 그것들을 컴퓨터에 저장할 수 있는 데이터베이스의 구조에 맞게 변형한 후 DBMS로 데이터베이스를 구현하여 일반 사용자들이 사용하게 하는 것이다.
    - 데이터베이스 설계 시 고려사항
        
        
        | 항목 | 내용 |
        | --- | --- |
        | 무결성 | 삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 한다. |
        | 일관성 | 데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 한다. |
        | 회복 | 시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 한다. |
        | 보안 | 불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 한다. |
        | 효율성 | 응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 한다. |
        | 데이터베이스 확장 | 데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 한다. |
    - 데이터베이스 설계 순서
        - 요구 조건 분석 : 요구 조건 명세서 작성
        - 개념적 설계 : 개념 스키마, 트랜잭션 모델링, E-R 모델
        - 논리적 설계 : 목표 DBMS에 맞는 논리 스키마 설계, 트랜잭션 인터페이스 설계
        - 물리적 설계 : 목표 DBMS에 맞는 물리적 구조의 데이터로 변환
        - 구현 : 목표 DBMS의 DDL(데이터 정의어)로 데이터베이스 생성, 트랜잭션 작성
    - 요구 조건 분석
        - 요구 조건 분석은 데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것이다.
            - 데이터베이스 사용자에 따른 수행 업무와 필요한 데이터의 종류, 용도, 처리 형태, 흐름, 제약 조건 등을 수집한다.
            - 수집된 정보를 바탕으로 요구 조건 명세를 작성한다.
    - 개념적 설계(정보 모델링, 개념화)
        - 개념적 설계란 정보의 구조를 얻기 위하여 현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정이다.
            - 개념적 설계 단게에서는 개념 스키마 모델링과 트랜잭션 모델링을 병행 수행한다.
            - 개념적 설계 단게에서는 요구 분석 단계에서 나온 결과인 요구 조건 명세를 DBMS에 독립적인 E-R 다이어그램으로 작성한다.
            - DBMS에 독립적인 개념 스키마를 설계한다.
    - 논리적 설계(데이터 모델링)
        - 논리적 설계 단계란 현실 세계에서 발생하는 자료를 컴퓨터가 이해하고 처리할 수 있는 물리적 저장장치에 저장할 수 있도록 변환하기 위해 특정 DBMS가 지원하는 논리적 자료 구조로 변환(mapping)시키는 과정이다.
            - 개념 세계의 데이터를 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계로 표현되는 논리적 구조의 데이터로 모델화한다.
            - 개념적 설계가 개념 스키마를 설계하는 단계라면 논리적 설계에서는 개념 스키마를 평가 및 정제하고 DBMS에 따라 서로 다른 논리적 스키마를 설계하는 단계이다.
            - 트랜잭션의 인터페이스를 설계한다.
    - 물리적 설계(데이터 구조화)
        - 물리적 설계란 논리적 설계 단계에서 논리적 구조로 표현된 데이터를 디스크 등의 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정이다.
        - 물리적 설계에서는 다양한 데이터베이스 응용에 대해 처리 성능을 얻기 위해 데이터베이스 파일의 저장 구조 및 액세스 경로를 결정한다
        - 저장 레코드의 양식, 순서, 접근 경로, 조회가 집중되는 레코드와 같은 정보를 사용하여 데이터가 컴퓨터에 저장되는 방법을 묘사한다.
    - 데이터베이스 구현
        - 데이터베이스 구현 단계란 논리적 설계 단계와 물리적 설계 단계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정이다.
            - 사용하려는 특정 DBMS의 DDL(데이터 정의어)을 이용하여 데이터베이스 스키마를 기술한 후 컴파일하여 빈 데이터베이스 파일을 생성한다.
            - 응용 프로그램을 위한 트랜잭션을 작성한다.
            - 데이터베이스 접근을 위한 응용 프로그램을 작성한다.
- 데이터 모델의 개념 B
    - 데이터 모델
        - 데이터 모델은 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
        - 데이터 모델은 데이터, 데이터의 관계, 데이터의 의미 및 일관성, 제약 조건 등을 기술하기 위한 개념적 도구들로 구성되어 있다
        - 데이터베이스 설계 과정에서 데이터의 구조(Schema)를 논리적으로 표현하기 위해 지능적 도구로 사용된다.
        - 데이터 모델 구성 요소 : 개체, 속성, 관계
        - 데이터 모델 종류 : 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델
        - 데이터 모델에 표시할 요소 : 구조, 연산, 제약 조건
    - 개념적 데이터 모델
        - 개념적 데이터 모델은 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
        - 개념적 데이터 모델은 속성들로 기술된 개체 타입과 이 개체 타입들 간의 관계를 이용하여 현실 세계를 표현한다
        - 개념적 데이터 모델은 현실 세계에 존재하는 개체를 인간이 이해할 수 있는 정보 구조로 표현하기 때문에 정보 모델이라고도 한다
        - 대표적인 개념적 데이터 모델로는 E-R 모델이 있다
    - 논리적 데이터 모델
        - 논리적 데이터 모델은 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정이다
        - 논리적 데이터 모델은 필드로 기술된 데이터 타입과 이 데이터 타입들 간의 관계를 이용하여 현실 세계를 표현한다
        - 단순히 데이터 모델이라고 하면 논리적 데이터 모델을 의미한다
        - 특정 DBMS는 특정 논리적 데이터 모델 하나만 선정하여 사용한다
        - 논리적 데이터 모델은 데이터 간의 관계를 어떻게 표현하는냐에 따라 관계 모델, 계층 모델, 네트워크 모델로 구분한다
    - 데이터 모델에 표시할 요소
        
        
        | 요소 | 내용 |
        | --- | --- |
        | 구조(Structure) | 논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현 |
        | 연산(Operation) | 데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구 |
        | 제약 조건(Constraint) | 데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건 |
- 데이터 모델의 구성 요소 D
    - 개체(Entity)
        - 개체는 데이터베이스에 표현하려는 것으로, 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
        - 개체는 실세계에 독립적으로 존재하는 유형, 무형의 정보로서 서로 연관된 몇 개의 속성으로 구성된다
        - 독립적으로 존재하거나 그 자체로서도 구별이 가능하며, 유일한 식별자(Unique Identifier)에 의해 식별된다
        - 다른 개체와 하나 이상의 관계(Relationship)가 있다.
    - 속성(Attribute)
        - 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위
        - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
        - 속성은 개체를 구성하는 항목으로 개체의 특성을 기술한다
        - 속성의 수를 디그리(Degree) 또는 차수라고 한다
        - 속성은 속성의 특성과 개체 구성 방식에 따라 분류한다
    - 속성의 특성에 따른 분류
        
        
        | 분류 | 내용 |
        | --- | --- |
        | 기본 속성
        (Basic Attribute) | - 업무 분석을 통해 정의한 속성
        
        - 속성 중 가장 많고 일반적
        
        - 업무로부터 분석한 속성이라도 업무상 코드로 정의한 속성은 기본 속성에서 제외 |
        | 설계 속성
        (Designed Attribute) | - 원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성
        
        - 업무에 필요한 데이터 외에 데이터 모델링을 위해 업무를 규칙화하려고 속성을 새로 만들거나 변형하여 정의하는 속성 |
        | 파생 속성
        (Derived Attribute) | - 다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성 
        
        - 파생 속성은 되도록 적은 수를 정의하는 것이 좋다. |
    - 속성의 개체 구성 방식에 따른 분류
        
        
        | 분류 | 내용 |
        | --- | --- |
        | 기본키 속성
        (Primary Key Attribute) | 개체를 유일하게 식별할 수 있는 속성 |
        | 외래키 속성
        (Foreign Key Attribute) | 다른 개체와의 관계에서 포함된 속성 |
        | 일반 속성 | 개체에 포함되어 있고 기본키, 외래키에 포함되지 않은 속성 |
    - 관계(Relationship)
        - 관계는 개체와 개체 사이의 논리적인 연결을 의미한다
        - 관계에는 개체 간의 관계와 속성 간의 관계가 있다
    - 관계의 형태
        
        
        | 형태 | 내용 |
        | --- | --- |
        | 일 대 일 (1 : 1) | 개체 집합 A의 각 원소가 개체 집합 B의 원소 한 개와 대응하는 관계 |
        | 일 대 다 (1 : N) | 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고 있지만, 개체 집합 B의 각 원소는 개체 집합 A의 원소 한 개와 대응하는 관계 |
        | 다 대 다 (N : M) | 개체 집합 A의 각 원소는 개체 집합 B의 원소 여러 개와 대응하고, 개체 집합 B의 각 원소도 개체 집합 A의 원소 여러 개와 대응하는 관계  |
    - 관계의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 종속 관계
        (Dependent Relationship) | - 두 개체 사이의 주, 종 관계를 표현한 것 
        
        - 식별 관계와 비식별 관계 존재 |
        | 중복 관계
        (Redundant  Relationship) | - 두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계 |
        | 재귀 관계
        (Recursive  Relationship) | - 개체가 자기 자신과 관계를 갖는 것으로, 순환 관계(Recursive Relationship)라고도 한다 |
        | 배타 관계
        (Exclusive  Relationship) | - 개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계로, 배타 AND 관계와 배타 OR 관계로 구분 |
- E-R(개체-관계) 모델 B
    - E-R(Entity-Relationship, 개체-관계) 모델
        - E-R 모델은 개체와 개체 간의 관계를 기본 요소로 이용하여 현실 세계의 무질서한 데이터를 개념적인 논리 데이터로 표현하기 위한 방법이다
        - E-R 모델은 1976년 피터 첸(Peter Chen)에 의해 제안되고 기본적인 구성 요소가 정립되었다
        - E-R 모델은 개념적 데이터 모델의 가장 대표적인 것이다
        - E-R 모델은 개체 타입(Entity Type)과 이들 간의 관계 타입(Relationship Type)을 이용해 현실 세계를 개념적으로 표현한다
        - E-R 모델에서는 데이터를 개체(Entity), 관계(Relationship), 속성(Attribute)으로 묘사한다
        - E-R 다이어그램으로 표현하며, 1:1, 1:N, N:M 등의 관계 유형을 제한 없이 나타낼 수 있다
    - E-R 다이어그램
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%2047.png)
        
- 관계형 데이터베이스의 구조 / 관계형 데이터 모델 A
    - 관계형 데이터베이스
        - 관계형 데이터베이스는 2차원적인 표(Table)를 이용해서 데이터 상호 관계를 정의하는 데이터베이스이다
        - 1970년 IBM에 근무하던 코드(E. F. Codd)에 의해 처음 제안
        - 개체(Entity)와 관계(Relationship)를 모두 릴레이션(Relation)이라는 표(Table)로 표현하기 때문에 개체를 표현하는 개체 릴레이션과 관계를 표현하는 관계 릴레이션이 존재한다
        - 장점 : 간결하고 보기 편리하며, 다른 데이터베이스로의 변환이 용이하다
        - 단점 : 성능이 다소 떨어진다
    - 관계형 데이터베이스의 릴레이션 구조
        - 릴레이션은 데이터들을 표의 형태로 표현한 것으로, 구조를 나타내는 릴레이션 스키마와 실제 값들인 릴레이션 인스턴스로 구성된다.
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%2049.png)
            
    - 튜플(Tuple)
        - 튜플은 릴레이션을 구성하는 각각의 행을 말한다
        - 튜플은 속성의 모임으로 구성된다
        - 파일 구조에서 레코드와 같은 의미이다
        - 튜플의 수를 카디널리티(Cardinality) 또는 기수, 대응수라고 한다
    - 속성(Attribute)
        - 속성은 데이터베이스를 구성하는 가장 작은 논리적 단위
        - 파일 구조상의 데이터 항목 또는 데이터 필드에 해당
        - 속성은 개체의 특성을 기술
        - 속성의 수를 디그리(Degree) 또는 차수라고 한다
    - 도메인(Domain)
        - 도메인은 하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자(Atomic)값들의 집합
        - 도메인은 실제 애트리뷰트 값이 나타날 때 그 값의 합법 여부를 시스템이 검사하는데에도 이용된다.
    - 릴레이션의 특징
        - 한 릴레이션에는 똑같은 튜플이 포함될 수 없으므로 릴레이션에 포함된 튜플들은 모두 상이하다
        - 한 릴레이션에 포함된 튜플 사이에는 순서가 없다
        - 튜플들의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다
        - 릴레이션 스키마를 구성하는 속성들 간의 순서는 중요하지 않다
        - 속성의 유일한 식별을 위해 속성의 명칭은 유일해야 하지만, 속성을 구성하는 값은 동일한 값이 있을 수 있다
        - 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합을 키(Key)로 설정한다
        - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자값만을 저장한다
    - 관계형 데이터 모델(Relational Data Model)
        - 관계형 데이터 모델은 2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 DB 구조
        - 가장 널리 사용되는 데이터 모델
        - 파일 구조처럼 구성한 테이블들을 하나의 DB로 묶어서 테이블 내에 있는 속성들 간의 관계(Relationship)를 설정하거나 테이블 간의 관계를 설정하여 이용한다
        - 기본키(Primary Key)와 이를 참조하는 외래키(Foreign Key)로 데이터 간의 관계를 표현한다
        - 계층 모델과 망 모델의 복잡한 구조를 단순화시킨 모델
        - 관계형 모델의 대표적인 언어는 SQL
        - 1:1, 1:N, N:M 관계를 자유롭게 표현 가능
- 관계형 데이터베이스의 제약 조건 - 키(Key) A
    - 키(Key)
        - 키는 데이터베이스에서 조건에 만족하는 튜플을 찾거나 순서대로 정렬할 때 기준이 되는 속성을 말한다
        - 키의 종류
            - 후보키(Candidate Key)
            - 기본키(Primary Key)
            - 대체키(Alternate Key)
            - 슈퍼키(Super Key)
            - 외래키(Foreign Key)
    - 후보키(Candidate Key)
        - 후보키는 릴레이션을 구성하는 속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합이다
        - 기본키로 사용할 수 있는 속성들을 말한다
        - 후보키는 유일성(Unique)과 최소성(Minimality)을 모두 만족시켜야 한다
            - 유일성 (Unique) : 하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 한다
            - 최소성(Minimality) : 키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 한다
    - 기본키(Primary Key)
        - 기본키는 후보키 중에서 특별히 선정된 주키(Main Key)이다
        - 기본키는 중복된 값을 가질 수 없다
        - 기본키는 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다
        - 기본키는 NULL값을 가질 수 없다. 즉 튜플에서 기본키로 설정된 속성에는 NULL 값이 있어선 안 된다.
    - 대체키(Alternate Key)
        - 대체키는 후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키를 의미한다
        - 대체키를 보조키라고도 한다
    - 슈퍼키(Super Key)
        - 슈퍼키는 한 릴레이션 내에 있는 속성들의 집합으로 구성된 키를 말한다
        - 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값은 나타나지 않는다
        - 슈퍼키는 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다
    - 외래키(Foreign Key)
        - 외래키는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다
        - 한 릴레이션에 속한 속성 A와 참조 릴레이션의 기본키인 B가 동일한 도메인 상에서 정의되었을 때의 속성 A를 외래키라고 한다
        - 외래키로 지정되면 참조 릴레이션의 기본키에 없는 값은 입력할 수 없다
- 관계형 데이터베이스의 제약 조건 - 무결성(Integrity) B
    - 무결성(Integrity)
        - 무결성은 데이터베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 의미한다
        - 무결성 제약 조건은 데이터베이스에 들어 있는 데이터의 정확성을 보장하기 위해 부정확한 자료가 데이터베이스 내에 저장되는 것을 방지하기 위한 제약 조건
    - 무결성의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 개체 무결성 | 기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다  |
        | 참조 무결성 | 외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 한다. |
        | 도메인 무결성 | 주어진 속성 값이 정의된 도메인에 속한 값이어야 한다 |
        | 사용자 정의 무결성 | 속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다 |
        | NULL 무결성 | 릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정 |
        | 고유 무결성 | 릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다 |
        | 키 무결성 | 하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다 |
        | 관계 무결성 | 릴레이션에 어느 한 튜플의 삽입 가능 여부 또는 한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정 |
    - 데이터 무결성 강화
        - 데이터 무결성은 데이터 품질에 직접적인 영향을 미치므로 데이터 특성에 맞는 적절한 무결성을 정의하고 강화해야 한다
        - 데이터 무결성은 애플리케이션, 데이터베이스 트리거, 제약 조건을 이용하여 강화할 수 있다
            
            
            | 애플리케이션 | 데이터 생성, 수정, 삭제 시 무결성 조건을 검증하는 코드를 프로그램 내에 추가 |
            | --- | --- |
            | 데이터베이스 
            트리거 | 트리거 이벤트에 무결성 조건을 실행하는 절차형 SQL을 추가 |
            | 제약 조건 | 데이터베이스에 제약 조건을 설정하여 무결성 유지 |
- 관계대수 및 관계해석 A
    - 관계대수
        - 관계대수는 관계형 데이터베이스에서 원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어
        - 관계대수는 릴레이션을 처리하기 위해 연산자와 연산규칙을 제공하며, 피연산자와 연산 관계과 모두 릴레이션
        - 관계대수는 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시
        - 관계 데이터베이스에 적용하기 위해 특별히 개발한 순수 관계 연산자와 수학적 집합 이론에서 사용하는 일반 집합 연산자 존재
    - 순수 관계 연산자
        
        
        | 종류 | 특징 | 기호 |
        | --- | --- | --- |
        | Select | - 릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산 
        
        - 릴레이션의 행에 해당하는 튜플(Tuple)을 구하는 것이므로 수평 연산이라고도 한다 | σ |
        | Project | - 주어진 릴레이션에서 속성 리스트(Attribute List)에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산
        
        - 연산 결과에 중복이 발생하면 중복이 제거 
        
        - 릴레이션의 열에 해당하는 속성을 추출하는 것이므로 수직 연산자로고도 한다  | π |
        | Join | - 공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산
        
        - Join의 결과는 Cartesian Product(교차곱)를 수행한 다음 Select를 수행한 것과 같다 | ⋈ |
        | Division | - X⊃Y인 두 개의 릴레이션 R(X)와 S(Y)가 있을 때, R의 속성이 S의 속성 값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산. | ÷ |
    - 일반 집합 연산자
        - 일반 집합 연산자는 수학적 집합 이론에서 사용하는 연산자
        - 일반 집합 연산자 중 합집합(UNION), 교집합(INTERSECTION), 차집합(DIFFERENCE)를 처리하기 위해서는 합병 조건을 만족해야 한다.
        - 합병 가능한 두 릴레이션 R과 S가 있을 때 각 연산의 특징을 요약하면 다음과 같다.
            
            
            | 연산자 | 기능 및 수학적 표현 | 카디널리티 |
            | --- | --- | --- |
            | 합집합
            UNION
            U | - 두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산이다.
            
            - R∪S={t|t∈R ∨ t∈S}
            
            - t는 릴레이션 R 또는 S에 존재하는 튜플이다. | • |R∪S| ≤ |R| + |S|
            • 합집합의 카디널리티는 두 릴레이션 카디널리티의 합보다 크지 않다. |
            | 교집합 INTERSECTION 
            ∩ | - 두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산이다.
            - R∩S={t|t∈R ∧ t∈S}
            
            - t는 릴레이션 R 그리고 S에 동시에 존재하는 튜플 | - |R∩S| ≤ Min{|R|, |S|}
            
            - 교집합의 카디널리티는 두 릴레이션 중 카디널리티가 적은 릴레이션의 카디널리티보다 크지 않다. |
            | 차집합 DIFFERENCE 
            - | - 두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산
            
            - R-S={t|t∈R ∧ t∉S}
            
            - t는 릴레이션 R에는 존재하고 S에 없는 튜플이다. | - |R-S| ≤ |R|
            
            - 차집합의 카디널리티는 릴레이션 R의 카디널리티 보다 크지 않다. |
            | 교차곱 CARTESIAN PRODUCT 
            X | - 두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산
            
            - R×S={r · s|r∈R ∧ s∈S}
            
            - r은 R에 존재하는 튜플이고, s는 S에 존재하는 튜플이다. | - |R×S| = |R|×|S|
            
            - 교차곱의 디그리는 두 릴레이션의 디그리를 더한 것과 같고, 카디널리티는 두 릴레이션의 카디널리티를 곱한 것과 같다. |
    - 관계해석(Relational Calculus)
        - 관계해석은 관계 데이터의 연산을 표현하는 방법
        - 관계 데이터 모델의 제안자인 코드(E. F. Codd)가 수학의 Predicate Calculus(술어 해석)에 기반을 두고 관계 데이터베이스를 위해 제안
        - 관계해석은 원하는 정보가 무엇이라는 것만 정의하는 비절차적 특성을 가짐
        - 원하는 정보를 정의할 때는 계산 수식 사용
- 이상 / 함수적 종속 A
    - 이상(Anomaly)
        - 이상이란 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복(Redundancy)으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미
        - 이상의 종류에는 테이블 조작 중에 발생하는 삽입 이상(Insertion Anomaly), 삭제 이상(Deletion Anomaly), 갱신 이상(Update Anomaly)이 있다.
            - 삽입 이상(Insertion Anomaly) : 테이블에 데이터를 삽입할 때 의도와는 상관 없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
            - 삭제 이상(Deletion Anomaly) : 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상
            - 갱신 이상(Update Anomaly) : 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상
    - 함수적 종속(Functional Dependency)
        - 어떤 테이블 R에서 X와 Y를 각각 R의 속성 집합의 부분 집합이라 할 때. 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 한다. X → Y로 표기한다
        - 함수적 종속은 데이터의 의미를 표현하는 것으로, 현실 세계를 표현하는 제약 조건이 되는 동시에 데이터베이스에서 항상 유지되어야 할 조건이다.
- 정규화(Normalization) B
    - 정규화(Normalization)
        - 정규화는 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이요하여 테이블을 무손실 분해 하는 과정이다
        - 정규화의 목적은 가능한 한 중복을 제거하여 삽입, 삭제, 갱신 이상의 발생 가능성을 줄이는 것
        - 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF이 있으며, 순서대로 정규화의 정도가 높아진다.
    - 정규화 과정
        
        ### 제 1정규형
        
        - 제 1 정규형은 테이블 R에 속한 모든 속성의 도메인(Domain)이 원자 값(Atomic Value)만으로 되어 있는 정규형이다. 즉, 테이블의 모든 속성 값이 원자 값으로만 되어 있는 정규형
        
        ### 제 2정규형
        
        - 제 2정규형은 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형
        
        ### 제 3정규형
        
        - 제 3정규형은 테이블 R이 제 2정규형이고 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속(Transitive Functional Dependency)를 만족하지 않는 정규형
        
        ### BCNF
        
        - BCNF는 테이블 R에서 모든 결정자가 후보키(Candidate Key)인 정규형이다
        - 일반적으로 제 3정규형에 후보키가 여러 개 존재하고, 이러한 후보키들이 서로 중첩되어 나타나는 경우에 적용 가능
        
        ### 제 4정규형
        
        - 제 4정규형은 테이블 R에 다중 값 종속(MVD; Multi Valued Dependency) A→>B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형
        
        ### 제 5정규형
        
        - 제 5정규형은 테이블 R의 모든 조인 종속(JD; Join Dependency)이 R의 후보키를 통해서만 성립되는 정규형
- 반정규화(Denormalization) A
    - 반정규화(=비정규화)
        - 반정규화는 시스템의 성능을 향상하고 개발 및 운영의 편의성 등을 높이기 위해 정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위
        - 반정규화를 수행하면 시스템의 성능이 향상되고 관리 효율성은 증가하지만 데이터의 일관성 및 정합성이 저하될 수 있다
        - 과도한 반정규화는 오히려 성능을 저하시킬 수 있다
        - 반정규화의 방법
            - 테이블 통합
            - 테이블 분할
            - 중복 테이블 추가
            - 중복 속성 추가
    - 테이블 통합
        - 테이블 통합은 두 개의 테이블이 조인(Join)되어 사용되는 경우가 많을 경우 성능 향상을 위해 아예 하나의 테이블로 만들어 사용하는 것
        - 테이블 통합을 고려하는 경우
            - 두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우
            - 항상 두 개의 테이블을 이용하여 조회를 수행하는 경우
        - 테이블 통합의 종류
            - 1:1 관계 테이블 통합
            - 1:N 관계 테이블 통합
            - 슈퍼타입/서브타입 테이블 통합
    - 테이블 분할
        - 테이블 분할은 테이블을 수직 또는 수평으로 분할하는 것이다 .
            
            
            | 방법 | 내용 |
            | --- | --- |
            | 수평 분할 | - 레코드(Record)를 기준으로 테이블을 분할
            
            - 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할 |
            | 수직 분할 | - 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것 
            
            - 종류 : 갱신 위주의 속성 분할, 자주 조회되는 속성 분할, 크기가 큰 속성 분할, 보안을 적용해야 하는 속성 분할  |
    - 중복 테이블 추가
        - 중복 테이블 추가는 작업의 효율성을 향상시키기 위해 테이블을 추가하는 것이다
        - 중복 테이블을 추가하는 경우
            - 여러 테이블에서 데이터를 추출해서 사용해야 할 경우
            - 다른 서버에 저장된 테이블을 이용해야 하는 경우
        - 중복 테이블 추가 방법
            
            
            | 집계 테이블의 추가 | 집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거(Trigger)를 설정하여 사용 |
            | --- | --- |
            | 진행 테이블의 추가 | 이력 관리 등의 목적으로 추가하는 테이블 |
            | 특정 부분만을 포함
            하는 테이블의 추가 | 데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성 |
    - 중복 속성 추가
        - 중복 속성 추가는 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것
        - 중복 속성을 추가하면 데이터의 무결성 확보가 어렵고, 디스크 공간이 추가로 필요하다
        - 중복 속성을 추가하는 경우
            - 조인이 자주 발생하는 속성인 경우
            - 접근 경로가 복잡한 속성인 경우
            - 액세스의 조건으로 자주 사용되는 속성인 경우
            - 기본키의 형태가 적절하지 않거나 여러 개의 속성으로 구성된 경우
- 시스템 카탈로그  C
    - 시스템 카탈로그(System Catalog)
        - 시스템 카탈로그는 시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스이다
        - 시스템 카탈로그 내의 각 테이블은 사용자를 포함하여 DBMS에서 지원하는 모든 데이터 객체에 대한 정의나 명세에 관한 정보를 유지 관리하는 시스템 테이블이다
        - 카탈로그들이 생성되면 데이터 사전(Data Dictionary)에 저장되기 때문에 좁은 의미로는 카탈로그를 데이터 사전이라고도 한다
    - 메타 데이터(Meta-Data)
        - 메타 데이터는 시스템 카탈로그에 저장된 정보를 의미한다
        - 메타 데이터의 유형
            - 데이터베이스 객체 정보 : 테이블(Table), 인덱스(Index), 뷰(View) 등의 구조 및 통계 정보
            - 사용자 정보 : 아이디, 패스워드, 접근 권한 등
            - 테이블의 무결성 제약 조건 정보 : 기본키, 외래키, NULL값 허용 여부 등
            - 함수, 프로시저, 트리거 등에 대한 정보
    - 데이터 디렉터리(Data Directory)
        - 데이터 디렉터리는 데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템
        - 시스템 카탈로그는 사용자와 시스템 모두 접근할 수 있지만 데이터 디렉터리는 시스템만 접근 가능
- 트랜잭션 분석 / CRUD 분석 A
    - 트랜잭션(Transaction)
        - 트랜잭션은 데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들을 의미한다
        - 트랜잭션은 데이터베이스 시스템에서 병행 제어 및 회복 작업 시 처리되는 작업의 논리적 단위로 사용된다
        - 트랜잭션은 사용자가 시스템에 대한 서비스 요구 시 시스템이 응답하기 위한 상태 변환 과정의 작업 단위로 사용된다.
    - 트랜잭션의 특성
        
        
        | 특성 | 의미 |
        | --- | --- |
        | Atomicity(원자성) | 트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit) 되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 한다 |
        | Consistency(일관성) | 트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환 |
        | Isolation
        (독립성, 격리성, 순차성) | 둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어들 수 없음 |
        | Durability(영속성, 지속성) | 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함 |
    - CRUD 분석
        - CRUD 분석은 프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것
        - CRUD 분석을 통해 많은 트랜잭션이 몰리는 테이블을 파악할 수 있으므로 디스크 구성 시 유용한 자료로 활용할 수 있다
        - CRUD 매트릭스
            - 2차원 형태의 표로서, 행(Row)에는 프로세스를, 열(Column)에는 테이블을, 행과 열이 만나는 위치에는 프로세스가 테이블에 발생시키는 변화를 표시하여 프로세스와 데이터 간의 관계를 분석하는 분석표
            - CRUD 매트릭스를 통해 트랜잭션이 테이블에 수행하는 작업을 검증한다
            - CRUD 매트릭스의 각 셀에는 Create, Read, Update, Delete의 앞 글자가 들어가며, 복수의 변화를 줄 때는 기본적으로 C > D > U > R 의 우선순위를 적용하여 한 가지만 적지만, 활용 목적에 따라 모두 기록할 수 있다
            - CRUD 매트릭스가 완성되었다면 C, R, U, D 중 어느 것도 적히지 않은 행이나 열, C나 R이 없는 열을 확인하여 불필요하거나 누락된 테이블 또는 프로세스를 찾는다
    - 트랜잭션 분석
        - 트랜잭션 분석은 CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB의 용량 산정 및 구조의 최적화를 목적으로 한다
        - 트랜잭션 분석은 업무 개발 담당자가 수행한다
        - 트랜잭션 분석을 통해 프로세스가 과도하게 접근하는 테이블을 확인할 수 있으며, 이러한 집중 접근 테이블을 여러 디스크에 분산 배치함으로써 디스크 입, 출력 향상을 통한 성능 향상을 가져올 수 있다
        - 트랜잭션 분석서
            - 단위 프로세스와 CRUD 매트릭스를 이용하여 작성
            - 구성 요소 : 단위 프로세스, CRUD 연산, 테이블명, 컬럼명, 테이블 참조 횟수, 트랜잭션 수, 발생 주기 등
- 인덱스  C
    - 인덱스(Index)
        - 인덱스는 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
        - 인덱스는 레코드가 저장된 물리적 구조에 접근하는 방법을 제공
        - 인덱스를 통해 파일의 레코드에 빠르게 액세스 할 수 있다
        - 레코드의 삽입과 삭제가 수시로 일어나는 경우에는 인덱스의 개수를 최소로 하는 것이 효율적
    - 인덱스의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 트리 기반 인덱스 | 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 인덱스 |
        | 비트맵 인덱스 | 인덱스 컬럼의 데이터를 Bit 값인 0 또는 1로 변환하여 인덱스 키로 사용 |
        | 함수 기반 인덱스 | 컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용 |
        | 비트맵 조인 인덱스 | 다수의 조인된 객체로 구성된 인덱스 |
        | 도메인 인덱스 | 개발자가 필요한 인덱스를 직접 만들어 사용 |
    - 클러스터드/넌클러스터드 인덱스
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 클러스터드 인덱스
        (Clustered Index) | - 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
        
        - 실제 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 검색 가능 |
        | 넌클러스터드 인덱스
        (Non-Clustered Index) | - 인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식
        
        - 데이터 삽입, 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬 해야 함 |
- 뷰 / 클러스터 B
    - 뷰(View)
        - 뷰는 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블이다
        - 뷰는 저장장치 내에 물리적으로 존재하지 않지만, 사용자에게는 있는 것처럼 간주된다
        - 뷰를 통해서만 데이터에 접근하게 하면 뷰에 나타나지 않는 데이터를 안전하게 보호하는 효율적인 기법으로 사용할 수 있다
        - 뷰가 정의된 기본 테이블이나 뷰를 삭제하면 그 테이블이나 뷰를 기초로 정의된 다른 뷰도 자동으로 삭제된다
        - 뷰를 정의할 때는 CREATE문, 제거할 때는 DROP 문을 사용한다
    - 뷰의 장,단점
        
        
        | 장점 | 단점 |
        | --- | --- |
        | - 논리적 데이터 독립성 제공 
        
        - 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용이나 요구를 지원 
        
        - 사용자의 데이터 관리를 간단하게 해줌
        
        - 접근 제어를 통한 자동 보안 제공 | - 독립적인 인덱스를 가질 수 없음
        
        - 뷰의 정의를 변경할 수 없음 
        
        - 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름 |
    - 클러스터(Cluster)
        - 클러스터는 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
        - 클러스터링 된 테이블은 데이터 조회 속도를 향상시키지만 입력, 수정, 삭제에 대한 작업 성능을 저하시킨다
        - 클러스터는 데이터의 분포도가 넓을수록 유리하다
        - 데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간을 절약할 수 있다
        - 처리 범위가 넓은 경우에는 단일 테이블 클러스터링을, 조인이 많이 발생하는 경우에는 다중 테이블 클러스터링을 사용한다
- 파티션 B
    - 파티션(Partition)
        - 데이터베이스에서 파티션은 대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것을 의미
        - 대용량 DB의 경우 몇 개의 중요한 테이블에만 집중되어 데이터가 증가되므로, 이런 테이블들을 작은 단위로 나눠 분산시키면 성능 저하를 방지할 뿐만 아니라 데이터 관리도 쉬워진다
        - 데이터 처리는 테이블 단위로 이뤄지고, 데이터 저장은 파티션별로 수행
    - 파티션의 장,단점
        
        
        | 장점 | - 데이터 접근 시 액세스 범위를 줄여 쿼리 성능 향상 
        
        - 파티션별로 데이터가 분산되어 저장되므로 디스크의 성능 향상 
        
        - 파티션별로 백업 및 복구를 수행하므로 속도가 빠름 
        
        - 시스템 장애 시 데이터 손상 정도 최소화 가능 
        
        - 데이터 가용성이 향상 
        
        - 파티션 단위로 입, 출력을 분산시킬 수 있음 |
        | --- | --- |
        | 단점 | - 하나의 테이블을 세분화하여 관리하므로 세심한 관리 요구 
        
        - 테이블 간 조인에 대한 비용이 증가 
        
        - 용량이 작은 테이블에 파티셔닝을 수행하면 오히려 성능이 저하됨 |
    - 파티션의 종류
        
        
        | 범위 분할
        (Range Partitioning) | - 지정한 열의 값을 기준으로 분할 |
        | --- | --- |
        | 해시 분할
        (Hash  Partitioning) | - 해시 함수가 적용된 결과 값에 따라 데이터를 분할 
        
        - 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것으로, 데이터를 고르게 분산할 때 유용
        
        - 특정 데이터가 어디에 있는지 판단할 수 없음 
        
        - 고객번호, 주민번호 등과 같이 데이터가 고른 컬럼에 효과적 |
        | 조합 분할
        (Composite
         Partitioning) | - 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할 
        
        - 범위 분할한 파티션이 너무 커서 관리가 어려울 때 유용 |
- 분산 데이터베이스 설계 C
    - 데이터베이스 용량 설계
        - 데이터베이스 용량 설계는 데이터가 저장될 공간을 정의하는 것
        - 데이터베이스 용량을 설계할 때는 테이블에 저장될 데이터양과 인덱스, 클러스터 등이 차지하는 공간 등을 예측하여 반영해야 한다
        - 데이터베이스 용량 설계의 목적
            - 데이터베이스의 용량을 정확히 산정하여 디스크의 저장 공간을 효과적으로 사용하고 확장성 및 가용성을 높인다
            - 디스크의 특성을 고려하여 설계함으로써 디스크의 입, 출력 부하를 분산시키고 채널의 병목 현상을 최소화
    - 분산 데이터베이스 설계
        - 분산 데이터베이스는 논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트(Site)에 분산된 데이터베이스
        - 분산 데이터베이스는 데이터의 처리나 이용이 많은 지역에 데이터베이스를 위치시킴으로써 데이터의 처리가 가능한 해당 지역에서 해결될 수 있도록 한다
        - 분산 데이터베이스 설계는 애플리케이션이나 사용자가 분산되어 저장된 데이터에 접근하게 하는 것을 목적으로 한다
    - 분산 데이터베이스의 목표
        - 위치 투명성(Location Transparency) : 액세스하려는 데이터베이스의 실제 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있다
        - 중복 투명성(Replication  Transparency) : 동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하고, 시스템은 자동으로 여러 자료에 대한 작업을 수행
        - 병행 투명성(Concurrency  Transparency) : 분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는다
        - 장애 투명성(Failure  Transparency) : 트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리
    - 분산 설계 방법
        
        
        | 방법 | 설명 |
        | --- | --- |
        | 테이블 위치 분산 | - 데이터베이스의 테이블을 각기 다른 서버에 분산시켜 배치하는 방법 |
        | 분할
        (Fragmentation) | - 테이블의 데이터를 분할하여 분산시키는 것 
        
        - 분할 규칙 : 완전성(Completeness), 재구성(Reconstruction), 상호 중첩 배제(Disjointness)
        
        - 주요 분할 방법
           - 수평 분할 : 특정 속성의 값을 기준으로 행 단위 분할
           - 수직 분할 : 데이터 컬럼(속성) 단위로 분할 |
        | 할당
        (Allocation) | - 동일한 분할을 여러 개의 서버에 생성하는 분산 방법 
        
        - 중복이 없는 할당과 중복이 있는 할당으로 나뉨 |
- 데이터베이스 이중화 / 서버 클러스터링 B
    - 데이터베이스 이중화(Database Replication)
        - 데이터베이스 이중화는 시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터베이스를 복제하여 관리하는 것
        - 데이터베이스 이중화를 수행하면 하나 이상의 데이터베이스가 항상 같은 상태를 유지하므로 데이터베이스에 문제가 발생하면 복제된 데이터베이스를 이용하여 즉시 문제 해결 가능
        - 여러 개의 데이터베이스를 동시에 관리하므로 사용자가 수행하는 작업은 데이터베이스 이중화 시스템에 연결된 다른 데이터베이스에도 동일하게 적용
        - 애플리케이션을 여러 개의 데이터베이스에서 분산 처리하므로 데이터베이스의 부하를 줄일 수 있다
        - 데이터베이스 이중화를 이용하면 손쉽게 백업 서버를 운영할 수 있다
    - 데이터베이스 이중화의 분류
        
        
        | Eager 기법 | - 트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법  |
        | --- | --- |
        | Lazy 기법 | - 트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법 
        
        - 데이터베이스마다 새로운 트랜잭션이 수행되는 것으로 간주 |
    - 데이터베이스 이중화 구성 방법
        
        
        | 활동 - 대기
        (Active-Standby)
        방법 | - 한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고, 활동 DB에 장애 발생 시 대기 상태에 있던 DB가 자동으로 모든 서비스 대신 수행 
        
        - 구성 방법과 관리가 쉬워 많은 기업에서 이용 |
        | --- | --- |
        | 활동-활동
        (Active-Active)
        방법 | - 두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공
        
        - 두 DB 모두 처리를 하기에 처리율이 높지만 구성 방법 및 설정이 복잡 |
    - 클러스터링(Clustering)
        - 클러스터링은 두 대 이상의 서버를 하나의 서버처럼 운영하는 기술
        - 클러스터링은 서버 이중화 및 공유 스토리지를 사용하여 서버의 고가용성 제공
            
            
            | 고가용성
            클러스터링 | - 하나의 서버에 장애가 발생하면 다른 노드(서버)가 받아 처리하여 서비스 중단을 방지하는 방식 
            
            - 일반적으로 언급되는 클러스터링이 고가용성 클러스터링 |
            | --- | --- |
            | 병렬 처리
            클러스터링 | - 전체 처리율을 높이기 위해 하나의 작업을 여러 개의 서버에서 분산하여 처리하는 방식 |
    - RTO/RPO
        
        
        | RTO(Recovery Time Objective, 목표 복구 시간) | - 비상사태 또는 업무 중단 시점으로부터 복구되어 가동될 때까지의 소요 시간을 의미  |
        | --- | --- |
        | RPO(Recovery Point Objective, 목표 복구 시점) | - 비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점 |
- 데이터베이스 보안 B
    - 데이터베이스 보안
        - 데이터베이스 보안이란 데이터베이스의 일부 또는 전체에 대해 권한이 없는 사용자가 액세스하는 것을 금지하기 위해 사용되는 기술
        - 보안을 위한 데이터 단위는 테이블 전체로부터 특정 테이블의 특정 행과 열에 있는 데이터 값에 이르기까지 다양하다
    - 암호화(Encryption)
        - 암호화는 데이터를 보낼 때 송신자가 지정한 수신자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것
        - 암호화(Encryption) 과정 : 평문을 암호문으로 변환
        - 복호화(Decryption) 과정 : 암호문을 평문으로 변환
        - 암호화 기법
            - 개인키 암호 방식(Private Key Encryption)
            - 공개키 암호 방식(Public Key Encryption)
    - 접근통제
        - 접근통제는 데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보 흐름을 제한하는 것
        - 접근통제 3요소
            - 접근통제 정책
            - 접근통제 메커니즘
            - 접근통제 보안모델
        - 접근통제 기술
            
            
            | 정책 | 특징 |
            | --- | --- |
            | 임의 접근통제(DAC,
            Discretionary
            Access Control) | - 데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식
            
            - 데이터 소유자가 접근통제 권한을 지정하고 제어 
            
            - 객체를 생성한 사용자가 생성된 객체에 대한 모든 권한을 부여받고, 부여된 권한을 다른 사용자에게 허가 가능 |
            | 강제 접근통제(MAC,
            Mandatory Access
            Control) | - 주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식
            
            - 시스템이 접근통제 권한을 지정 
            
            - 데이터베이스 객체별로 보안 등급 부여 가능 
            
            - 사용자별로 인가 등급 부여 가능 |
            | 역할기반 접근통제
            (RBAC, Role Based
            Access Control) | - 사용자의 역할에 따라 접근 권한을 부여하는 방식
            
            - 중앙관리자가 접근통제 권한 지정
            
            - 임의 접근통제와 강제 접근통제의 단점 보완
            
            - 다중 프로그래밍 환경에 최적화된 방식 |
    - 접근통제 정책
        - 접근통제 정책은 어떤 주체가 언제 어디서 어떤 객체에게 어떤 행위에 대한 허용 여부를 정의하는 것
        - 접근통제 정책의 종류
            
            
            | 종류 | 특징 |
            | --- | --- |
            | 신분 기반 정책 | - 주체나 그룹의 신분에 근거하여 객체의 접근을 제한하는 방법 
            
            - IBP(Individual-Based Policy) : 최소 권한 정책, 단일 주체에게 하나의 객체에 대한 허가 부여 
            
            - GBP(Group-Based Policy) : 복수 주체에 하나의 객체에 대한 허가 부여 |
            | 규칙 기반 정책 | - 주체가 갖는 권한에 근거하여 객체의 접근을 제한하는 방법 
            
            -MLP(Multi-Level Policy) : 사용자나 객체별로 지정된 기밀 분류에 따른 정책
            
            - CBP(Compartment-Based Policy) : 집단별로 지정된 기밀 허가에 따른 정책 |
            | 역할 기반 정책 | - GBP의 변형된 정책으로, 주체의 신분이 아니라 주체가 맡은 역할에 근거하여 객체의 접근을 제한하는 방법 |
    - 접근통제 매커니즘
        - 접근통제 매커니즘은 정의된 접근통제 정책을 구현하는 기술적인 방법
        - 접근통제 매커니즘에는 접근통제 목록, 능력 리스트, 보안 등급, 패스워드, 암호화 등이 있다
    - 접근통제 보안 모델
        - 접근통제 보안 모델은 보안 정책을 구현하기 위한 정형화된 모델
            
            
            | 종류 | 특징 |
            | --- | --- |
            | 기밀성 모델 | - 군사적인 목적으로 개발된 최초의 수학적 모델
            
            - 기밀성 보장이 최우선
            
            - 군대 시스템 등 특수 환경에서 주로 사용 |
            | 무결성 모델 | - 기밀성 모델에서 발생하는 불법적인 정보 변경을 방지하기 위해 무결성을 기반으로 개발된 모델 |
            | 접근통제 모델 | - 접근통제 메커니즘을 보안 모델로 발전시킨 것 
            
            - 대표적으로 접근통제 행렬(Access Control Matrix)이 있다 
            
            - 접근통제 행렬 : 임의적인 접근통제를 관리하기 위한 보안 모델로, 행은 주체, 열은 객체 즉, 행과 열로 주체과 객체의 권한 유형 표시 |
    - 접근통제 조건
        - 접근통제 조건은 접근통제 매커니즘의 취약점을 보안하기 위해 접근통제 정책에 부가하여 적용할 수 있는 조건
        - 값 종속 통제(Value-Dependent Control) : 일반적으로는 객체에 저장된 값에 상관없이 접근통제를 동일하게 허용하지만, 값 종속 통제는 객체에 저장된 값에 따라 다르게 접근통제를 허용해야 하는 경우에 사용
        - 다중 사용자 통제(Multi-User Control) : 지정된 객체에 다수의 사용자가 동시에 접근을 요구하는 경우에 사용
        - 컨텍스트 기반 통제(Context-Based Control)
            - 특정 시간, 네트워크 주소, 접근 경로, 인증 수준 등에 근거하여 접근을 제어하는 방법
            - 다른 보안 정책과 결합하여 보안 시스템의 취약점을 보완할 때 사용
    - 감사 추적
        - 감사 추적은 사용자나 애플리케이션이 데이터베이스에 접근하여 수행한 모든 활동을 기록하는 기능
        - 감사 추적은 오류가 발생한 데이터베이스를 복구하거나 부적절한 데이터 조작을 파악하기 위해 사용
- 데이터베이스 백업 B
    - 데이터베이스 백업
        - 데이터베이스 백업은 전산 장비의 장애에 대비하여 데이터베이스에 저장된 데이터를 보호하고 복구하기 위한 작업
        - 치명적인 데이터 손실을 막기 위해서는 데이터베이스를 정기적으로 백업해야 한다
    - 로그 파일
        - 로그 파일은 데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일
        - 데이터베이스의 복구를 위해 필요한 가장 기본적인 자료
        - 로그 파일을 기반으로 데이터베이스를 과거 상태로 복귀(UNDO) 시키거나 현재 상태로 재생(REDO) 시켜 데이터베이스 상태를 일관성 있게 유지 가능
        - 로그 파일은 트랜잭션 시작 시점, Rollback 시점, 데이터 입력, 수정 삭제 시점 등에서 기록
    - 데이터베이스 복구 알고리즘
        
        
        | NO-UNDO/
        REDO | - 데이터베이스 버퍼의 내용을 비동기적으로 갱신한 경우의 복구 알고리즘
        
        - NO-UNDO : 트랜잭션 완료 전에는 변경 내용이 데이터베이스에 기록되지 않으므로 취소할 필요가 없다. 
        
        - REDO : 트랜잭션 완료 후 데이터베이스 버퍼에는 기록되어 있고, 저장매체에는 기록되지 않았으므로 트랜잭션 내용을 다시 실행해야 한다. |
        | --- | --- |
        | UNDO/
        NO-REDO | - 데이터베이스 버퍼의 내용을 동기적으로 갱신한 경우의 복구 알고리즘
        
        - UNDO : 트랜잭션 완료 전에 시스템이 파손되었다면 변경된 내용을 취소한다. 
        
        - NO-REDO : 트랜잭션 완료 전에 데이터베이스 버퍼 내용을 이미 저장 매체에 기록했으므로 트랜잭션 내용을 다시 실행할 필요가 없다. |
        | UNDO/
        REDO | - 데이터베이스 버퍼의 내용을 동기/비동기적으로 갱신한 경우의 복구 알고리즘
        
        - 데이터베이스 기록 전에 트랜잭션이 완료될 수 있으므로 완료된 트랜잭션이 데이터베이스에 기록되지 못했다면 다시 실행해야 한다. |
        | NO-UNDO/
        NO-REDO | - 데이터베이스 버퍼의 내용을 동기적으로 저장 매체에 기록하지만 데이터베이스와는 다른 영역에 기록한 경우의 복구 알고리즘 
        
        - NO-UNDO : 변경 내용은 데이터베이스와 다른 영역에 기록되어 있으므로 취소할 필요가 없다. 
        
        - NO-REDO : 다른 영역에 이미 기록되어 있으므로 트랜잭션을 다시 실행할 필요가 없다. |
    - 백업 종류
        - 백업 종류는 복구 수준에 따라 운영체제를 이용하는 물리 백업과 DBMS 유틸리티를 이용하는 논리 백업으로 나뉜다
        - 물리 백업
            - 데이터베이스 파일을 백업하는 방법
            - 백업 속도가 빠르고 작업이 단순하지만 문제 발생 시 원인 파악 및 문제 해결이 어렵다
        - 논리 백업
            - DB 내의 논리적 객체들을 백업하는 방법
            - 복원 시 데이터 손상을 막고 문제 발생 시 원인 파악 및 해결이 수월하지만 백업/복원 시 시간이 많이 소요
- 스토리지 B
    - 스토리지(Storage)
        - 스토리지는 단일 디스크로 처리할 수 없는 대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술
        - 스토리지 종류에는 DAS, NAS, SAN이 있음
    - DAS(Direct Attached Storage)
        - DAS는 서버와 저장장치를 전용 케이블로 직접 연결하는 방식
        - 일반 가정에서 컴퓨터에 외장하드를 연결하는 것이 여기에 해당
        - 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉽다
        - 초기 구축 비용 및 유지보수 비용이 저렴
        - 직접 연결 방식이므로 다른 서버에서 접근할 수 없고 파일을 공유할 수 없음
        - 확장성 및 유연성이 떨어짐
    - NAS(Network Attached Storage)
        - NAS는 서버와 저장장치를 네트워크를 통해 연결하는 방식
        - 별도의 파일 관리 기능이 있는 NAS Storage가 내장된 저장장치를 직접 관리
        - Ethernet 스위치를 통해 다른 서버에서도 스토리지에 접근할 수 있어 파일 공유 가능
        - 장소에 구애받지 않고 저장장치에 쉽게 접근 가능
        - DAS에 비해 확장성 및 유연성이 우수
    - SAN(Storage Area Network)
        - SAN은 DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식
        - 광 채널(FC) 스위치를 이용하여 네트워크 구성
        - 광 채널 스위치는 서버와 저장장치를 광케이블로 연결하므로 처리 속도가 빠름
        - 저장장치를 공유함으로써 여러 개의 저장장치나 백업 장비를 단일화시킬 수 있음
        - 확장성, 유연성, 가용성이 뛰어남
- 논리 데이터 모델의 변환 D
    - 엔티티(Entity)를 테이블로 변환
        - 논리 데이터 모델에서 정의된 엔티티를 물리 데이터 모델의 테이블로 변환하는 것
            
            
            | 논리적 설계(데이터 모델링) | 물리적 설계 |
            | --- | --- |
            | 엔티티(Entitiy) | 테이블(Table) |
            | 속성(Attribute) | 컬럼(Column) |
            | 주 식별자(Primary Identifier) | 기본키(Primary Key) |
            | 외부 식별자(Foreign Identifier) | 외래키(Foreign Key) |
            | 관계(relationship) | 관계(relationship) |
    - 슈퍼타입/서브타입을 테이블로 변환
        - 슈퍼타입/서브타입은 논리 데이터 모델에서 이용되는 형태이므로 물리 데이터 모델을 설계할 때는 슈퍼타입/서브타입을 테이블로 변환해야 함
        - 슈퍼타입/서브타입 모델을 테이블로 변환하는 방법에는 슈퍼타입 기준 테이블 변환, 서브타입 기준 테이블 변환, 개별타입 기준 테이블 변환이 있음
    - 슈퍼타입 기준 테이블 변환
        - 슈퍼타입 기준의 테이블 변환은 서브타입을 슈퍼타입에 통합하여 하나의 테이블로 만드는 것
        - 서브타입에 속성이나 관계가 적을 경우에 적용하는 방법
        - 하나로 통합된 테이블에는 서브타입의 모든 속성이 포함되어야 함
    - 서브타입 기준 테이블 변환
        - 서브타입 기준의 테이블 변환은 슈퍼타입 속성들을 각각의 서브타입에 추가하여 서브타입들을 개별적인 테이블로 만드는 것
        - 서브타입에 속성이나 관계가 많이 포함된 경우 적용
    - 개별타입 기준 테이블 변환
        - 개별타입 기준의 테이블 변환은 슈퍼타입과 서브타입들을 각각의 개별적인 테이블로 변환하는 것
        - 슈퍼타입과 서브타입 테이블들 사이에는 각각 1:1 관계가 형성
    - 속성을 컬럼으로 변환
        - 논리 데이터 모델에서 정의한 속성을 물리 데이터 모델의 컬럼으로 변환
        
        | 일반 속성 변환 | 속성과 컬럼은 명칭이 반드시 일치할 필요는 없으나, 개발자와 사용자 간 의사소통을 위해 가능한 한 표준화된 약어를 사용하여 일치시키는 것이 좋음 |
        | --- | --- |
        | Primary UID를 기본키로 변환 | 논리 데이터 모델에서의 Primary UID는 물리 데이터 모델의 기본키로 만듦 |
        | Primary UID(관계의 UID
        Bar)를 기본키로 변환 | 다른 엔티티와의 관계로 인해 생서오딘 Primary UID는 물리 데이터 모델의 기본키로 만듦 |
        | Secondary(Alternate)
        UID를 유니크키로 변환 | 논리 모델링에서 정의된 Secondary UID 및 Alternate Key는 물리 모델에서 유니크키로 만듦 |
    - 관계를 외래키로 변환
        - 논리 데이터 모델에서 정의된 관계는 기본키와 이를 참조하는 외래키로 변환
- 자료 구조 B
    - 자료 구조
        - 자료 구조는 자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 것
        - 저장 공간의 효율성과 실행시간의 단축을 위해 사용
    - 배열(Array)
        - 배열은 크기와 형(Type)이 동일한 자료들이 순서대로 나열된 자료의 집합
        - 반복적인 데이터 처리 작업에 적합한 구조
        - 정적인 자료 구조로, 기억장소의 추가가 어려움
        - 데이터 삭제 시 기억장소가 빈 공간으로 남아있어 메모리의 낭비 발생
    - 연속 리스트(Contiguous List)
        - 연속 리스트는 배열과 같이 연속되는 기억장소에 저장되는 자료 구조
        - 중간에 데이터를 삽입하기 위해서는 연속된 빈 공간이 있어야 한다
        - 삽입, 삭제 시 자료의 이동이 필요
    - 연결 리스트(Linked List)
        - 연결 리스트는 자료들을 임의의 기억공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조
        - 연결을 위한 링크(포인터) 부분이 필요하기에 기억 공간의 이용 효율이 좋지 않음
        - 접근 속도가 느리고, 연결이 끊어지면 다음 노드를 찾기 어려움
    - 스택(Stack)
        - 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조
        - 후입선출(LIFO; Last In First Out) 방식으로 자료 처리
        - 저장할 기억 공간이 없는 상태에서 데이터가 삽입되면 오버플로(Overflow) 발생
        - 삭제할 데이터가 없는 상태에서 데이터를 삭제하면 언더플로(Underflow)가 발생
    - 큐(Queue)
        - 큐는 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료 구조
        - 선입선출(FIFO; First In First Out) 방식으로 처리
        - 시작을 표시하는 프런트(Front) 포인터와 끝을 표시하는 리어(Rear) 포인터가 있다
    - 그래프(Graph)
        - 그래프는 정점(Vertex)과 간선(Edge)의 두 집합으로 이루어지는 자료 구조
        - 사이클이 없는 그래프를 트리라고 한다
        - 간선의 방향성 유무에 따라 방향 그래프와 무방향 그래프로 구분
    - 방향/무방향 그래프의 최대 간선 수
        - 방향 그래프의 최대 간선 수 : n(n-1)
        - 무방향 그래프에서 최대 간선 수(n(n-1)/2
- 트리(Tree) C
    - 트리
        - 트리는 정점(Node, 노드)과 선분(Branch, 가지)을 이용하여 사이클을 이루지 않도록 구성한 그래프(Graph)의 특수한 형태
        - 트리는 하나의 기억 공간을 노드(Node)라고 하며, 노드와 노드를 연결하는 선을 링크(Link)라고 한다
    - 트리 관련 용어
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%2025.png)
        
        - 노드(Node) : 트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지(Branch)를 합친 것
        - 근 노드(Root Node) : 트리의 맨 위에 있는 노드
        - 디그리(Degree, 차수) : 각 노드에서 뻗어 나온 가지의 수
        - 단말 노드(Terminal Node) = 잎 노드(Leaf Node) : 자식이 하나도 없는 노드, 즉 디그리가 0인 노드
        - 비단말 노드(Non-Terminal Node) : 자식이 하나라도 있는 노드, 즉 Degree가 0이 아닌 노드
        - 조상 노드(Ancestors Node) : 임의의 노드에서 근 노드에 이르는 경로상에 있는 노드들
        - 자식 노드(Son Node) : 어떤 노드에 연결된 다음 레벨의 노드들
        - 부모 노드(Parent Node) : 어떤 노드에 연결된 이전 레벨의 노드들
        - 형제 노드(Brother Node, Sibling) : 동일한 부모를 갖는 노드들
        - Level : 근 노드의 Level을 1로 가정한 후 어떤 Level이 L이면 자식 노드는 L + 1
        - 깊이(Depth, Height) : Tree에서 노드가 가질 수 있는 최대 레벨
        - 숲(Forest) : 여러 개의 트리가 모여 있는 것
        - 트리의 디그리 : 노드들의 디그리 중에서 가장 많은 수
- 이진 트리(Tree) A
    - 이진 트리
        - 이진 트리는 차수(Degree)가 2 이하인 노드들로 구성된 트리, 즉 자식이 둘 이하인 노드들로만 구성된 트리를 말한다
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%203.png)
            
    - 트리의 운행법
        - 트리를 구성하는 각 노드들을 찾아가는 방법을 운행법(Traversal)이라 한다
        - 이진 트리를 운행하는 방법은 산술식의 표기법과 연관성을 갖는다
        - 이진 트리의 운행법은 다음 세 가지가 있다
        - Preorder 운행 : Root → Left → Right
        - Inorder 운행 : Left → Root → Right
        - Postorder 운행 : Left → Right → Root
    - Proeorder 운행법
        - 이진 트리를 Root → Left → Right 순으로 운행하며 노드들을 찾아가는 방법
    - Inorder 운행법
        - 이진 트리를 Left → Root → Right 순으로 운행하며 노드들을 찾아가는 방법
    - Postorder 운행법
        - 이진 트리를 Left → Right → Root 순으로 운행하며 노드들을 찾아가는 방법
    - 수식의 표기법
        - 이진 트리로 만들어진 수식을 Inorder, Preorder, Postorder로 운행하면 각각 Infix, Prefix, Postfix 표기법이 된다.
        - 전위 표기법(PreFix) : 연산자 → Left → Right, +AB
        - 중위 표기법(InFix) : Left → 연산자 → Right, A + B
        - 후위 표기법(PostFix) : Left → Right → 연산자, AB+
- 정렬(Sort) A
    
    ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%204.png)
    
    - 삽입 정렬(Insertion Sort)
        - 삽입 정렬은 가장 간단한 정렬 방식으로, 이미 순서화딘 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식
    - 선택 정렬(Selection Sort)
        - 선택 정렬은 n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 (n-1)개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식을 반복하여 정렬하는 방식
    - 버블 정렬(Bubble Sort)
        - 버블 정렬은 주어진 파일에서 인접한 두 개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식
    - 쉘 정렬(Shell Sort)
        - 쉘 정렬은 입력 파일을 어떤 매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 Insertion 정렬 방식으로 순서 배열하는 과정을 반복하는 정렬 방식
        - 삽입 정렬을 확장한 개념
    - 퀵 정렬(Quick Sort)
        - 퀵 정렬은 키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식
        - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬
    - 힙 정렬(Heap Sort)
        - 힙 정렬은 전이진 트리를 이용한 정렬 방식
        - 구성된 전이진 트리(Complete Binary Tree)를 Heap Tree로 변환하여 정렬
    - 2-Way 합병 정렬(Merge Sort)
        - 2-Way 합병 정렬은 이미 정렬되어 있는 두 개의 파일을 한 개의 파일로 합병하는 정렬 방식
    - 기수 정렬(Radix Sort) = Bucket Sort
        - 기수 정렬은 Queue를 이용하여 자릿수(Digit)별로 정렬하는 방식
        - 레코드의 키 값을 분석하여 같은 수 또는 같은 문자끼리 그 순서에 맞는 버킷에 분배하였다가 버킷의 순서대로 레코드를 꺼내어 정렬

# 통합 구현

- 통합 구현 D
    - 통합 구현
        - 통합 구현은 사용자의 요구사항에 맞춰 송,수신 모듈과 중계 모듈 간의 연계를 구현하는 것을 의미한다
        - 통합 구현은 송,수신 방식이나 시스템 아키텍처 구성, 송,수신 모듈 구현 방법 등에 따라 다르므로 사용자의 요구사항과 구축 환경에 적합한 방식을 설계해야 한다
        - 일반적인 통합 구현은 송,수신 시스템과 모듈, 중계 시스템, 연계 데이터, 네트워크로 구성된다.
    - 통합 구현의 구성 요소
        
        
        | 송신 시스템과 모듈 | - 송신 시스템 : 데이터를 생성 및 변환하여 전송하는 시스템으로, 송신 모듈과 모니터링(Monitoring) 기능으로 구성
        
        - 송신 모듈 : 전송 데이터를 생성하고 필요에 따라 전송 데이터의 변환 등을 수행  |
        | --- | --- |
        | 수신 시스템과 모듈 | - 수신 시스템 : 수신 받은 데이터를 정제 및 변환하는 시스템으로, 수신 모듈과 모니터링(Monitoring) 기능으로 구성
        
        - 수신 모듈 : 수신 데이터를 정제하고 애플리케이션이나 데이터베이스 테이블에 적합한 데이터로 변환하는 작업 등을 수행 |
        | 중계 시스템 | - 내,외부 시스템 간 또는 내부 시스템 간의 연계 시 사용되는 아키텍처 |
        | 연계 데이터 | - 송, 수신 시스템 간 송, 수신되는 데이터 |
        | 네트워크 | - 송신 시스템, 수신 시스템, 중계 시스템을 연결해주는 통신망 |
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%205.png)
        
    - 연계 요구사항 분석
        - 연계 요구사항 분석은 통합 구현을 위해 사용자 요구사항을 분석하여 연계 데이터를 식별 및 표준화하여 연계 데이터를 정의하는 것
        - 연계 요구사항 분석 절차
            - 하드웨어 및 소프트웨어 구성, 네트워크 현황 확인
            - 테이블 정의서, 코드 정의서 등의 문서 확인
            - 체크리스트 작성
            - 관련 문서 공유 및 인터뷰, 설문 조사 실시
            - 요구사항 정의서 작성
    - 연계 데이터 식별 및 표준화의 절차
        - 연계 범위 및 항목 정의 : 시스템 간 연계할 정보를 상세화하여 정의
        - 연계 코드 변환 및 매핑 : 연계 정보 중 코드로 관리되어야 할 항목을 찾아 코드로 변환
        - 연계 데이터 식별자와 변경 구분 추가 : 연계 정보에 데이터 구분 식별자, 작업 구분 정보, 테이블/파일 관리 정보 등을 추가
        - 연계 데이터 표현 방법 정의 : 연계 대상 범위, 대상 항목, 코드 변환 방식, 매핑 방식을 정의한 후 연계 데이터 구성
        - 연계 정의서 및 연계서 작성 : 이전 과정에서 정의된 다양한 항목들과 파악된 현황들을 문서화
- 연계 메커니즘 C
    - 연계 메커니즘
        - 연계 메커니즘은 데이터의 생성 및 전송을 담당하는 송신 시스템과 데이터 수신 및 운영 DB 반영을 담당하는 수신 시스템으로 구성된다
        - 송, 수신 시스템 사이에는 데이터의 송, 수신과 송, 수신 시스템 현황을 모니터링하는 중계 시스템을 설치할 수 있다
        - 연계 메커니즘의 연계 방식
            
            
            | 직접 연계 방식 | - 중간 매개체 없이 송, 수신 시스템이 직접 연계하는 방식
            
            - 종류 : DB Link, API/Open API, DB Connection, JDBC 등 |
            | --- | --- |
            | 간접 연계 방식 | - 송, 수신 시스템 사이에 중간 매채체를 두어 연계하는 방식 
            
            - 종류 : 연계 솔루션, ESB, 소켓(Socket), 웹 서비스(Web Service) 등 |
    - 연계 메커니즘의 과정
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%206.png)
        
    - 연계 메커니즘의 구성
        
        
        | 연계 데이터 생성 및 추출 | - 연계 솔루션과 관계없이 응용 시스템에서 연계 데이터를 생성하고 추출하는 과정 |
        | --- | --- |
        | 코드 매핑 및 데이터 변환 | - 송신 시스템에서 사용하는 코드를 수신 시스템에서 사용하는 코드로 매핑 및 변환하는 과정 |
        | 인터페이스 테이블 또는 
        파일 생성 | - 연계 데이터를 인터페이스 테이블이나 파일 형식으로 생성하는 과정 |
        | 로그(Log) 기록 | - 송, 수신 시스템에서 수행되는 모든 과정에 관한 결과 및 오류에 대한 정보를 로그 테이블이나 파일에 기록하는 과정 |
        | 연계 서버 또는 
        송, 수신 어댑터 | - 연계 서버 : 데이터를 전송 형식에 맞게 변환하고 송, 수신을 수행하는 등 송, 수신과 관련된 모든 처리 수행
        
        - 송신 어댑터 : 인터페이스 테이블 또는 파일의 데이터를 전송 형식에 맞도록 변환 및 송신 수행
        
        - 수신 어댑터 : 수신 데이터를 인터페이스 테이블이나 파일로 생성 |
        | 전송 | - 송신 시스템에서 생성된 연계 데이터를 네트워크 환경에 맞는 데이터로 변환한 후 수신 시스템으로 보내는 것 |
        | 운영 DB에 연계 데이터
        반영 | - 수신된 인터페이스 테이블 또는 파일 구조의 데이터를 변환 프로그램을 이용하여 수신 시스템의 운영 ㅇB에 반영하는 과정  |
- 연계 장애 및 오류처리 구현 D
    - 연계 메커니즘 구간별 장애 및 오류 모니터링 현황
        - 연계 메커니즘에서 오류 발생 시점, 오류 로그 기록 장소, 오류 로그 기록 주체는 크게 송,수신 시스템, 연계 서버 구간으로 구분된다
        - 구간별 주요 오류 발생 시점
            
            
            | 구간 | 오류 발생 시점 |
            | --- | --- |
            | 송신 시스템 | - 데이터 생성 및 추출 시 
            
            - 코드 매핑 및 데이터 변환 시
            
            - 인터페이스 테이블 또는 파일 등록 시  |
            | 수신 시스템 | - 연계 데이터 로드(Load) 시 
            
            - 코드 매핑 및 데이터 변환 시 
            
            - 운영 DB에 반영 시  |
            | 연계 서버 | - 연계 데이터 로드(Load) 및 전송 형식으로 변환 시 
            
            - 연계 데이터 송, 수신 시 
            
            - 수신 시스템의 데이터 형식으로 변환 및 로드(Load) 시  |
    - 장애 및 오류 유형과 처리방안
        - 장애 및 오류 유형의 분류
            - 송, 수신 시스템의 연계 프로그램 오류
            - 연계 서버의 오류
            - 연계 데이터의 오류
        - 송, 수신 시스템의 연계 프로그램과 연계 서버에서 기록하는 로그를 통해 장애 및 오류 원인을 확인하고 분석하여 적절한 처리방안을 선택한다
    - 장애 및 오류의 확인과 처리 절차
        - 1차적으로 연계 서버에서 제공하는 장애 및 오류 현황 모니터링 화면을 통해 오류 원인 및 발생 현황을 확인
        - 1차에서 확인이 불가능한 경우 송, 수신 시스템의 연계 프로그램과 연계 서버에서 기록한 오류 로그 테이블 또는 파일을 확인하여 오류 원인을 분석
        - 발생한 오류에 대한 원인이 확인되면 원인에 따른 적절한 조치 수행
    - 장애 및 오류의 정의와 설계
        - 장애 및 오류 현황의 기록과 확인을 위해서는 다음 항목들을 정의하고 설계해야 한다.
            
            
            | 항목 | 내용 |
            | --- | --- |
            | 장애 및 오류 관리
            대상 | 송, 수신 시스템의 연계 프로그램에서 관리하는 장애 및 오류를 관리 대상으로 정의 |
            | 관리 대상의 장애 및
            오류 코드와 메시지 | 관리 대상에서 식별한 오류 내용을 주제별로 분류한 후 각 오류 내용에 오류 코드를 부여하고 오류 메시지를 정의 |
            | 장애 및 오류 코드와
            메시지 관리 방식 | 관리 대상 오류 코드와 오류 메시지가 많은 경우에는 테이블 관리 방식을, 적은 경우에는 파일 관리 방식 선택 |
            | 장애 및 오류 기록 방식 | 오류 로그 테이블이나 파일은 기록 단위에 따라 인터페이스 테이블이나 파일에 대한 록, 연계 데이터에 대한 로그로 설계 |
- 연계 데이터 보안 적용 D
    - 연계 데이터 보안
        - 송신 시스템에서 수신 시스템으로 전송되는 연계 데이터는 보안에 취약할 수 있으므로 데이터의 중요성을 고려하여 보안을 적용해야 한다
        - 일반적인 연계 데이터의 보안 방식
            - 전송 구간 보안
            - 데이터 보안
    - 전송 구간 보안
        - 전송 구간의 보안은 전송되는 데이터나 패킷(Packet)을 쉽게 가로챌 수 없도록 암호화 기능이 포함된 프로토콜을 사용한다
        - 데이터나 패킷을 가로채더라도 내용을 확인할 수 없게 데이터나 패킷을 암호화한다
    - 데이터 보안
        - 데이터 보안은 송신 시스템에서 연계 데이터를 추출할 때와 수신 시스템에서 데이터를 운영 DB에 반영할 때 데이터를 암,복호화 하는 것이다
        - 데이터의 암,복호화 처리 절차
            - 송신 시스템
                1. DB에서 연계 데이터 추출
                2. 보안 적용 대상 컬럼(Cloumn)을 암호화
                3. 연계 데이터를 인터페이스 테이블 또는 파일에 등록 및 송신
            - 수신 시스템
                1. 수신된 데이터 중 암호화한 컬럼을 복호화
                2. 운영 DB에 반영
    - 암,복호화 적용 절차
        - 암호화 적용 대상, 암호화 알고리즘, 암호화 키(Key) 선정
        - 암호화 적용 대상 컬럼(Column)의 데이터 길이 변경
        - 암호화 알고리즘 라이브러리 확보 및 설치
        - 연계 응용 프로그램에서 암,복호화 처리 수행
- XML(eXtrensible Markup Language) A
    - XML
        - XML은 특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어
        - 웹브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결하기 위해 개발
        - 사용자가 직접 문서의 태그(Tag)를 정의할 수 있으며, 다른 사용자가 정의한 태그를 사용할 수 있다
        - 트리 구조로 구성되어 있어 상위 태그는 여러 개의 하위 태그를 가질 수 있다
    - SOAP(Simple Object Access Protocol)
        - SOAP는 컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약
        - 웹 서비스에서 사용되는 메시지의 형식과 처리 방법을 지정
        - 기본적으로 HTTP 기반에서 동작하기 때문에 프록시와 방화벽의 영향 없이 통신 가능
        - 최근에는 무거운 구조의 SOAP 대신 RESTful Protocol을 이용하기도 함
    - WSDL(Web Service Description Language)
        - WSDL은 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어
        - XML로 작성되며, UDDI의 기초가 된다
        - SOAP, XML 스키마와 결합하여 인터넷에서 웹 서비스를 제공하기 위해 사용
        - 클라이언트는 WSDL 파일을 읽어 서버에서 어떠한 조작이 가능한지를 파악 할 수 있다
- 연계 테스트 D
    - 연계 테스트의 개요
        - 연계 테스트는 구축된 연계 시스템과 연계 시스템의 구성 요소가 정상적으로 동작하는지 확인하는 활동
        - 연계 테스트 진행 순서
            1. 연계 테스트 케이스 작성 : 연계 시스템 간의 데이터 및 프로세스의 흐름을 분석하여 필요한 테스트 항목 도출
            2. 연계 테스트 환경 구축 : 테스트의 일정, 방법, 절차, 소요 시간 등을 송, 수신 기관과의 협의를 통해 결정
            3. 연계 테스트 수행 : 연계 응용 프로그램을 실행하여 연계 테스트 케이스의 시험 항목 및 처리 절차 등을 실제로 진행
            4. 연계 테스트 수행 결과 검증 : 연계 테스트 케이스의 시험 항목 및 처리 절차를 수행한 결과가 예상 결과와 동일한지 확인 

# 서버 프로그램 구현

- 개발 환경 구축 D
    - 개발 환경 구축
        - 개발 환경 구축은 응용 소프트웨어 개발을 위해 개발 프로젝트를 이해하고 소프트웨어 및 하드웨어 장비를 구축하는 것
        - 개발 환경은 응용 소프트웨어가 운영될 환경과 유사한 구조로 구축
        - 분석 단계의 산출물을 바탕으로 개발에 필요한 하드웨어와 소프트웨어를 선정
        - 하드웨어와 소프트웨어의 성능, 편의성, 라이선스 등의 비즈니스 환경에 적합한 제품들을 최종적으로 결정하여 구축
    - 하드웨어 환경
        - 하드웨어 환경은 사용자와의 인터페이스 역할을 하는 클라이언트(Client), 그리고 클라이언트와 통신하여 서비스를 제공하는 서버(Server)로 구성
        - 클라이언트의 종류 : 개인용 컴퓨터(PC), 스마트폰 등
        - 서버의 종류
            
            
            | 종류 | 특징 |
            | --- | --- |
            | 웹 서버
            (Web Server) | - 클라이언트로부터 직접 요청을 받아 처리
            
            - 저용량의 정적 파일들 제공 |
            | 웹 애플리케이션
            서버(WAS; Web
            Application Server) | - 동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이서 역할을 수행 |
            | 데이터베이스 서버
            (DB Server) | - 데이터베이스와 이를 관리하는 DBMS를 운영 |
            | 파일 서버(File Server) | - 데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장 |
    - 소프트웨어 환경
        - 소프트웨어 환경은 클라이언트와 서버 운영을 위한 시스템 소프트웨어와 개발에 사용되는 개발 소프트웨어로 구성된다
        - 시스템 소프트웨어의 종류 : 운영체제(OS), 웹 서버 및 WAS 운용을 위한 서버 프로그램, DBMS 등
        - 개발 소프트웨어의 종류
            
            
            | 종류 | 특징 |
            | --- | --- |
            | 요구사항 관리 도구 | 요구사항의 수집과 분석, 추적 등을 편리하게 도와주는 소프트웨어 |
            | 설계/모델링 도구 | UML(통합 모델링 언어)을 지원하며, 개발의 전 과정에서 설계 및 모델링을 도와주는 소프트웨어 |
            | 구현 도구 | 개발 언어를 통해 애플리케이션의 실제 구현을 지원하는 소프트웨어  |
            | 빌드 도구 | 구현 도구를 통해 작성된 소스의 빌드 및 배포, 라이브러리 관리를 지원하는 소프트웨어  |
            | 테스트 도구 | 모듈들이 요구사항에 적합하게 구현되었는지 테스트하는 소프트웨어 |
            | 형상 관리 도구 | 산출물들을 버전별로 관리하여 품질 향상을 지원하는 소프트웨어  |
    - 웹 서버(Web Server)의 기능
        
        
        | 기능 | 내용 |
        | --- | --- |
        | HTTP/HTTPS 지원 | 브라우저로부터 요청을 받아 응답할 때 사용되는 프로토콜 |
        | 통신 기록
        (Communication Log) | 처리한 요청들을 로그 파일로 기록하는 기능 |
        | 정적 파일 관리
        (Managing Static Files) | HTML, CSS, 이미지 등의 정적 파일들을 저장하고 관리하는 기능 |
        | 대역폭 제한
        (Bandwidth Throtting) | 네트워크 트래픽의 포화를 방지하기 위해 응답 속도를 제한하는 기능 |
        | 가상 호스팅
        (Virtual Hosting) | 하나의 서버로 여러 개의 도메인 이름을 연결하는 기능 |
        | 인증(Authentication) | 사용자가 합법적인 사용자인지를 확인하는 기능 |
    - 개발 언어의 선정 기준
        
        
        | 기준 | 내용 |
        | --- | --- |
        | 적절성 | 개발하려는 소프트웨어의 목적에 적합해야 한다 |
        | 효율성 | 코드의 작성 및 구현이 효율적이어야 한다 |
        | 이식성 | 다양한 시스템 및 환경에 적용이 가능해야 한다 |
        | 친밀성 | 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 한다 |
        | 범용성 | 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 한다  |
- 소프트웨어 아키텍처 A
    - 소프트웨어 아키텍처
        - 소프트웨어 아키텍처는 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
        - 애플리케이션의 분할 방법과 분할된 모듈에 할당될 기능, 모듈 간의 인터페이스 등을 결정
        - 소프트웨어 아키텍처 설계의 기본 원리에는 모듈화, 추상화, 단게적 분해, 정보 은닉이 존재
    - 모듈화(Modularity)
        - 모듈화는 소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것을 의미
        - 모듈의 크기를 너무 작게 나누면 개수가 많아져 모듈 간의 통합 비용이 많이 든다
        - 모듈의 크기를 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다
    - 추상화(Abstraction)
        - 추상화는 문제의 전체적이고 포괄적인 개념을 설계한 후 차례로 세분화하여 구체화시켜 나가는 것
        - 완전한 시스템을 구축하기 전에 그 시스템과 유사한 모델을 만들어 여러 가지 요인들을 테스트할 수 있다
        - 추상화의 유형
            
            
            | 과정 추상화 | 자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계 |
            | --- | --- |
            | 데이터 추상화 | 데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체 |
            | 제어 추상화 | 이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체 |
    - 단계적 분해(Stepwisw Refinement)
        - 단계적 분해는 문제를 상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법
        - Niklaus Wirth에 의해 제안된 하향식 설계 전략
        - 소프트웨어의 포괄적인 기능에서부터 시작하여 점차적으로 구체화하고, 알고리즘, 자료 구조 등 상세한 내역은 가능한 한 뒤로 미루어 진행
    - 정보 은닉(Information Hiding)
        - 정보 은닉은 한 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
        - 정보 은닉을 통해 모듈을 독립적으로 수행 가능
        - 하나의 모듈이 변경되더라도 다른 모듈에 영향을 주지 않으므로 수정, 시험, 유지보수가 용이
    - 상위 설계와 하위 설계
        - 소프트웨어 개발의 설계 단계는 크게 상위 설계와 하위 설계로 구분할 수 있다.
            
            
            |  | 상위 설계 | 하위 설계 |
            | --- | --- | --- |
            | 별칭 | 아키텍처 설계, 예비 설계 | 모듈 설계, 상세 설계 |
            | 설계 대상 | 시스템의 전체적인 구조 | 시스템의 내부 구조 및 행위 |
            | 세부 목록 | 구조, DB, 인터페이스 | 컴포넌트, 자료 구조, 알고리즘 |
    - 소프트웨어 아키텍처의 품질 속성
        - 소프트웨어 아키텍처의 품질 속성은 소프트웨어 아키텍처가 이해 관계자들이 요구하는 수준의 품질을 유지 및 보장할 수 있게 설계되었는지 확인하기 위해 품질 평가 요소들을 구체화 시켜 놓은 것
        - 품질 평가 요소의 종류
            
            
            | 시스템 측면 | 성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성 등 |
            | --- | --- |
            | 비즈니스 측면 | 시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개 일정 등 |
            | 아키텍처 측면 | 개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성 등  |
    - 소프트웨어 아키텍처의 설계 과정
        - 설계 목표 설정 : 요구사항을 분석하여 전체 시스템의 설계 목표 설정
        - 시스템 타입 결정 : 시스템과 서브시스템의 타입을 결정하고, 아키텍처 패턴 선택
        - 아키텍처 패턴 적용 : 시스템의 표준 아키텍처 설계
        - 서브시스템 구체화 : 서브시스템의 기능 및 서브시스템 간의 상호작용을 위한 동작과 인터페이스 정의
        - 검토 : 설계 목표, 요구사항, 설계의 기본 원리 등을 만족하는지 아키텍처 검토
    - 협약(Contract)에 의한 설계
        - 협약에 의한 설계는 컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유할 수 있도록 명세한 것
        - 컴포넌트에 대한 정확한 인터페이스를 명세
        - 명세에 포함될 조건
            
            
            | 조건 | 내용 |
            | --- | --- |
            | 선행 조건(Precondition) | 오퍼레이션이 호출되기 전에 참이 되어야 할 조건 |
            | 결과 조건(Postcondition) | 오퍼레이션이 수행된 후 만족되어야 할 조건 |
            | 불변 조건(Invariant) | 오퍼레이션이 실행되는 동안 항상 만족되어야 할 조건 |
- 아키텍처 패턴 B
    - 아키텍처 패턴(Patterns)
        - 아키텍처 패턴은 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
        - 소프트웨어 시스템의 구조를 구성하기 위한 기본적인 윤곽을 제시
        - 아키텍처 패턴에는 서브시스템들과 그 역할이 정의
        - 서브시스템 사이의 관계와 여러 규칙, 지침 등이 포함되어 있음
        - 주요 아키텍처 패턴의 종류
            - 레이어 패턴
            - 클라이언트-서버 패턴
            - 파이프-필터 패턴
            - 모델-뷰-컨트롤러 패턴
    - 레이어 패턴(Layers Pattern)
        - 레이어 패턴은 시스템을 계층적으로 구분하여 구성하는 고전적인 방법의 패턴
        - 하위 계층은 상위 계층에 대한 서비스 제공자가, 상위 계층은 하위 계층의 클라이언트가 된다
        - 서로 마주보는 두 개의 계층 사이에서만 상호작용이 이루어진다
        - 대표적으로 OSI 참조 모델이 존재한다.
    - 클라이언-서버 패턴(Client-Server  Pattern)
        - 클라이언트-서버 패턴은 하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴
        - 사용자가 클라이언트를 통해 서버에 요청하면 클라이언트가 응답을 받아 사용자에게 제공하는 방식
    - 파이프-필터 패턴(Pipe-Filter  Pattern)
        - 파이프-필터 패턴은 데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴
        - 앞 시스템의 처리 결과물을 파이프를 통해 전달받아 처리한 후 그 결과물을 다시 파이프를 통해 다음 시스템으로 넘겨주는 패턴을 반복
        - 데이터 변환, 버퍼링, 동기화 등에 주로 사용
        - 대표적으로 UNIX의 쉘(Shell)이 존재
    - 모델-뷰-컨트롤러 패턴(Model-View-Controller  Pattern)
        - 모델-뷰-컨트롤러 패턴은 서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴
        - 컨트롤러가 사용자의 요청을 받으면 핵심 기능과 데이터를 보관하는 모델을 이용하여 뷰에 정보를 출력하는 구조
        - 여러 개의 뷰를 만들 수 있다
        - 한 개의 모델에 대해 여러 개의 뷰를 필요로 하는 대화형 애플리케이션에 적합
    - 기타 패턴
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 마스터-슬레이브 패턴
        (Master-Slave Pattern) | 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴  |
        | 브로커 패턴
        (Broker Pattern) | 사용자가 원하는 서비스와 특성을 브로커 컴포넌트에 요청하면 브로커 컴포넌트가 요청에 맞는 컴포넌트와 사용자를 연결해주는 패턴 |
        | 피어-투-피어 패턴
        (Peer-To-Peer Pattern) | 피어(Peer)라 불리는 하나의 컴포넌트가 클라이언트가 될 수도, 서버가 될 수도 있는 패턴 |
        | 이벤트-버스 패턴
        (Event-Bus Pattern) | 소스가 특정 채널에 이벤트 메시지를 발행(Publish) 하면 해당 채널을 구독(Subscribe)한 리스터(Listener)들이 메시지를 받아 이벤트를 처리하는 패턴 |
        | 블랙보드 패턴
        (Blackboard Pattern) | 모든 컴포넌트들이 공유 데이터 저장소와 블랙보드 컴포넌트에 접근이 가능한 패턴 |
        | 인터프리터 패턴
        (Interpreter Pattern) | 프로그램 코드의 각 라인을 수행하는 방법을 지정하고, 기호마다 클래스를 갖도록 구성한 패턴  |
- 객체지향(Object-Oriented) A
    - 객체지향
        - 객체지향은 소프트웨어의 각 요소들을 객체(Object)로 만든 후, 객체들을 조립해서 소프트웨어를 개발하는 기법
        - 구조적 기법의 문제점으로 인한 소프트웨어 위기의 해결책으로 채택되어 사용 중
        - 소프트웨어의 재사용 및 확장이 용이하여 고품질의 소프트웨어를 빠르게 개발할 수 있고 유지보수가 쉽다
        - 객체지향의 구성 요소
            - 객체(Object)
            - 클래스(Class)
            - 메시지(Message)
        - 객체지향의 특징
            - 캡슐화(Encapsulation)
            - 상속(Inheritance)
            - 다형성(Polymorphism)
            - 연관성(Relationship)
    - 객체(Object)
        - 객체는 데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈
            
            
            | 데이터 | - 객체가 가지고 있는 정보로, 속성이나 상태, 분류 등 |
            | --- | --- |
            | 함수 | - 객체가 수행하는 기능으로 객체가 갖는 데이터를 처리하는 알고리즘 
            
            - 객체의 상태를 참조하거나 변경하는 수단 |
    - 클래스(Class)
        - 클래스는 공통된 속성과 연산을 갖는 객체의 집합
        - 각각의 객체들이 갖는 속성과 연산을 정의하고 있는 틀
        - 클래스에 속한 각각의 객체를 인스턴스(Instance)라고 한다.
    - 메시지(Message)
        - 메시지는 객체들 간의 상호작용을 하는데 사용되는 수단으로, 객체에게 어떤 행위를 핟도록 지시하는 명령 또는 요구사항
        - 메시지를 받은 객체는 대응하는 연산을 수행하여 예상된 결과를 반환
    - 캡슐화(Encapsulation)
        - 캡슐화는 외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부 내용을 은닉하는 것
        - 캡슐화된 객체는 외부 모듈의 변경으로 인한 파급 효과가 적다
        - 객체들 간에 메시지를 주고받을 때 상대 객체의 세부 내용은 알 필요가 없으므로 인터페이스가 단순해지고, 객체 간의 결합도가 낮아진다.
    - 상속(Inheritance)
        - 상속은 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것
        - 하위 클래스는 물려받은 속성과 연산을 다시 정의하지 않아도 즉시 자신의 속성으로 사용 가능
        - 하위 클래스는 상속받은 속성과 연산 외에 새로운 속성과 연산을 첨가하여 사용 가능
    - 다형성(Polymorphism)
        - 다형성은 하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력
        - 객체들은 동일한 메소드명을 사용하며 같은 의미의 응답을 한다
    - 연관성(Relationship)
        - 연관성은 두 개 이상의 객체들이 상호 참조하는 관계를 의미
        - 연관성의 종류
            
            
            | 종류 | 의미 | 특징 |
            | --- | --- | --- |
            | is member of | 연관화(Association) | 2개 이상의 객체가 상호 관련되어 있음을 의미 |
            | is instance of | 분류화(Classfication) | 동일한 형의 특성을 갖는 객체들을 모아 구성하는 것  |
            | is part of | 집단화(Aggregation) | 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것 |
            | is a | 일반화(Generalization) | 공통적인 성질들로 추상화한 상위 객체를 구성하는 것 |
            | is a | 특수화/상세화
            (Specialization) | 상위 객체를 구체화하여 하위 객체를 구성하는 것  |
- 객체지향 분석 및 설계 A
    - 객체지향 분석(OOA; Object Oriented Analysis)
        - 객체지향 분석은 사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업
        - 개발을 위한 업무를 객체와 속성, 클래스와 멤버, 전체와 부분 등으로 나누어서 분석
        - 클래스를 식별하는 것이 객체지향 분석의 주요 목적
    - 객체지향 분석의 방법론
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 럼바우(Rumbaugh) 방법 | - 분석 활동을 객체 모델, 동적 모델, 기능 모델로 나누어 수행 |
        | Booch(부치) 방법 | - 미시적(Micro) 개발 프로세스와 거시적(Macro) 개발 프로세스를 모두 사용
        
        - 클래스와 객체들을 분석 및 식별하고 클래스의 속성과 연산을 정의  |
        | Jacobson 방법 | - 유스케이스(Use Case)를 강조하여 사용 |
        | Coad와 Yourdon 방법 | - E-R 다이어그램을 사용하여 객체의 행위를 모델링
        
        - 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성 |
        | Wirfs-Brock 방법 | - 분석과 설계 간의 구분이 없고, 고객 명세서를 평가해서 설계 작업까지 연속적으로 수행 |
    - 럼바우(Rumbaugh)의 분석 기법
        - 럼바우의 분석 기법은 모든 소프트웨어 구성 요소를 그래픽 표기법을 이용하여 모델링하는 기법
        - 객체 모델링 기법(OMT; Object-Modeling Technique)이라고도 한다
        - 분석 활동은 ‘객체 모델링 → 동적 모델링 → 기능 모델링’ 순으로 이루어진다.
            
            
            | 객체 모델링
            (Object Modeling) | 정보 모델링(Information Modeling)이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것  |
            | --- | --- |
            | 동적 모델링
            (Dynamic Modeling) | 상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링 |
            | 기능 모델링
            (Functional Modeling) | 자료 흐름도(DFD)를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링 |
    - 객체지향 설계 원칙
        - 객체지향 설계 원칙은 변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙
        - SRP, OCP, LSP, ISP, DIP의 다섯 가지 원칙 앞 글자로 SOLID 원칙이라고 부른다.
            
            
            | 종류 | 내용 |
            | --- | --- |
            | 단일 책임 원칙(SRP) | 객체는 단 하나의 책임만 가져야 한다는 원칙 |
            | 개방-폐쇄 원칙(OCP) | 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙 |
            | 리스코프 치환 원칙(LSP) | 자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙 |
            | 인터페이스 분리 원칙(ISP) | 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙 |
            | 의존 역전 원칙(DIP) | 의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙 |
- 모듈 A
    - 모듈(Module)
        - 모듈은 모듈화를 통해 분리된 시스템의 각 기능으로, 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등을 의미
        - 모듈의 기능적 독립성은 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립됨을 의미
        - 모듈의 독립성은 결합도(Coupling)와 응집도(Cohesion)에 의해 측정
    - 결합도(Coupling)
        - 결합도는 모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계
        - 결합도가 약할수록 품질이 높고, 강할수록 품질이 낮다
    - 결합도의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 내용 결합도
        (Content Coupling) | - 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도 |
        | 공통(공유) 결합도
        (Common Coupling) | - 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도 
        
        - 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 방식으로 상호작용하는 때의 결합도  |
        | 외부 결합도
        (External Coupling) | - 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도 |
        | 제어 결합도
        (Control Coupling) | - 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도 
        
        - 하위 모듈에서 상위 모듈로 제어 신호가 이동하여 하위 모듈이 상위 모듈에게 처리 명령을 내리는 권리 전도 현상이 발생  |
        | 스탬프(검인) 결합도
        (Stamp Coupling) | - 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도 |
        | 자료 결합도
        (Data Coupling) | - 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도  |
    - 응집도(Cohesion)
        - 응집도는 모듈의 내부 요소들이 서로 관련되어 있는 정도
        - 응집도가 강할수록 품질이 높고, 약할수록 품질이 낮다
    - 응집도의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 기능적 응집도
        (Functional Conhesion) | 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도 |
        | 순차적 응집도
        (Sequential Cohesion) | 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도 |
        | 교환(통신)적 응집도
        (Communication Cohesion) | 동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도  |
        | 절차적 응집도
        (Procedural Cohesion) |  다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도  |
        | 시간적 응집도
        (Temporal Cohesion) | 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도  |
        | 논리적 응집도
        (Logical Cohesion) | 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도  |
        | 우연적 응집도
        (Coincidental Cohesion) | 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도  |
    - 팬인(Fan-In)/팬아웃(Fan-Out)
        - 팬인은 어떤 모듈을 제어하는 모듈의 수
        - 팬아웃은 어떤 모듈에 의해 제어되는 모듈의 수
        - 팬인이 높다는 것은 재사용 측면에서 설계가 잘 되었다는 의미
        - 팬인이 높은 경우 단일 장애점이 발생할 수 있으므로 중점적인 관리 및 테스트가 필요
    - N-S 차트(Nassi-Schneideman Chart)
        - N-S 차트는 논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법
        - 박스 다이어그램, Chapin Chart라고도 한다
        - GOTO나 화살표를 사용하지 않는다
        - 연속, 선택 및 다중 선택, 반복의 3가지 제어 논리 구조로 표현
        - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는 데 적합
- 단위 모듈 A
    - 단위 모듈(Unit Module)
        - 단위 모듈은 소프트웨어 구현에 필요한 여러 동작 중 한 가지 동작을 수행하는 기능을 모듈로 구현한 것
        - 단위 모듈로 구현되는 하나의 기능을 단위 기능이라고 한다
        - 독립적인 컴파일이 가능하며, 다른 모듈에 호출되거나 삽입되기도 한다
        - 단위 모듈의 구현 과정
            1. 단위 기능 명세서 작성 : 기능 및 코드 명세서나 설계 지침과 같은 단위 기능을 명세화하는 단계
            2. 입, 출력 기능 구현 : 입, 출력 기능을 위한 알고리즘 및 데이터를 구현하는 단계
            3. 알고리즘 구현 : 단위 기능별로 모듈을 구현하는 단계 
    - IPC(Inter-Process Communication)
        - IPC는 모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합
        - 복수의 프로세스를 수행하며 이뤄지는 프로세스 간 통신까지 구현이 가능
        - IPC의 대표 메소드 5가지
            
            
            | 메소드 | 특징 |
            | --- | --- |
            | Shared Memory | - 공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식 |
            | Socket | - 네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스 간에 통신하는 방식 |
            | Semaphores | - 공유 자원에 대한 접근 제어를 통해 통신하는 방식 |
            | Pipes&named Pipes | - ‘Pipe’라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식
            
            - Pipe는 하나의 프로세스가 이용 중이라면 다른 프로세스는 접근할 수 없음 |
            | Message Queueing | - 메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식 |
    - 단위 모듈 테스트
        - 단위 모듈 테스트는 프로그램의 단위 기능으로 구현된 모듈이 정해진 기능을 정확히 수행하는지 검증하는 것
        - 단위 테스트(Unit Test)라고도 불림
        - 단위 모듈 테스트의 기준은 단위 모듈에 대한 코드이므로 시스템 수준의 오류는 잡아낼 수 없음
    - 테스트 케이스(Test Case)
        - 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서
        - 테스트 케이스를 이용하지 않은 테스트는 특정 요소에 대한 검증이 누락되거나 불필요한 검증의 반복으로 인해 인력과 시간을 낭비할 수 있다
        - SIO/IEC/IEEE 29119-3 표준에 따른 테스트 케이스의 구성 요소
            
            
            | 식별자(Identifier) | 항목 식별자, 일련번호 |
            | --- | --- |
            | 테스트 항목(Test Item) | 테스트 대상(모듈 또는 기능) |
            | 입력 명세(Input Specification) | 입력 데이터 또는 테스트 조건 |
            | 출력 명세(Output Specification) | 테스트 케이스 수행 시 예상되는 출력 결과 |
            | 환경 설정(Environmental Needs) | 필요한 하드웨어나 소프트웨어의 환경 |
            | 특수 절차 요구
            (Special Procedure Requirement) | 테스트 케이스 수행 시 특별히 요구되는 절차 |
            | 의존성 기술
            (Inter-case Dependencies) | 테스트 케이스 간의 의존성  |
- 공통 모듈 B
    - 공통 모듈
        - 공통 모듈은 여러 프로그램에서 공통으로 사용할 수 있는 모듈
        - 자주 사용되는 계산식이나 매번 필요한 사용자 인증과 같은 기능들이 공통 모듈로 구성될 수 있음
        - 공통 모듈을 구현할 때는 해당 기능을 명확히 이해할 수 있도록 명세 기법을 준수
    - 공통 모듈 명세 기법의 종류
        
        
        | 명세 기법 | 내용 |
        | --- | --- |
        | 정확성(Correctness) | 시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성 |
        | 명확성(Clarity) | 해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성 |
        | 완전성(Completeness) | 시스템 구현을 위해 필요한 모든 것을 기술 |
        | 일관성(Consistency) | 공통 기능들 간 상호 충돌이 발생하지 않도록 작성 |
        | 추적성(Traceability) | 기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성 |
    - 재사용(Reuse)
        - 재사용은 이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업
        - 새로 개발하는데 필요한 비용과 시간을 절약 가능
        - 누구나 이해할 수 있고 사용이 가능하도록 사용법을 공개
        - 재사용 규모에 따른 분류
            
            
            | 함수와 객체 | - 클래스나 메소드 단위의 소스 코드를 재사용 |
            | --- | --- |
            | 컴포넌트 | - 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈 
            
            - 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용 |
            | 애플리케이션 | - 공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용 |
    - 효과적인 모듈 설계 방안
        - 결합도(Coupling)는 줄이고 응집도(Cohesion)는 높여서 모듈의 독립성과 재사용성을 높인다
        - 복잡도와 중복성을 줄이고 일관성을 유지
        - 모듈의 기능은 예측이 가능해야 하며 지나치게 제한적이어서는 안 된다
        - 모듈 크기는 시스템의 전반적인 기능과 구조를 이해하기 쉬운 크기로 분해
        - 효과적인 제어를 위해 모듈 간의 계층적 관계를 정의하는 자료가 제시되어야 한다
- 코드 C
    - 코드(Code)
        - 코드는 자료의 분류, 조합, 집계, 추출을 용이하게 하기 위해 사용하는 기호
        - 정보를 신속, 정확, 명료하게 전달할 수 있게 한다
        - 일정한 규칙에 따라 작성
        - 정보 처리의 효율과 처리된 정보의 가치에 많은 영향을 미친다
    - 코드의 주요 기능
        
        
        | 기능 | 내용 |
        | --- | --- |
        | 식별 기능 | 데이터 간의 성격에 따라 구분 가능 |
        | 분류 기능 | 특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 가능 |
        | 배열 기능 | 의미를 부여하여 나열 가능 |
        | 표준화 기능 | 다양한 데이터를 기준에 맞추어 표현 가능 |
        | 간소화 기능 | 복잡한 데이터를 간소화 가능 |
    - 코드의 종류
        
        
        | 종류 | 내용 |
        | --- | --- |
        | 순차 코드
        (Sequence Code) | 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법. 순차 코드 또는 일련번호 코드라고도 한다  |
        | 블록 코드
        (Block Code) | 코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법. 구분 코드라고도 함 |
        | 10진 코드
        (Deimal Code) | 코드화 대상 항목을 0~9까지 10진 분할하고, 다시 그 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법. 도서 분류식 코드라고도 함 |
        | 그룹 분류 코드
        (Group Classification
        Code) | 코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고, 각 그룹 안에서 일련번호를 부여하는 방법 |
        | 연상 코드
        (Mnemonic Code) | 코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법 |
        | 표의 숫자 코드
        (Significant Digit Code) | 코드화 대상 항목의 성질. 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법. 유효 숫자 코드라고도 함  |
        | 합성 코드
        (Combined Code) | 필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법 |
- 디자인 패턴 A
    - 디자인 패턴(Design Pattern)
        - 디자인 패턴은 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다
        - 문제 및 배경, 실제 적용된 사례, 재사용이 가능한 샘플 코드 등으로 구성
        - 개발 과정 중에 문제가 발생하면 새로 해결책을 구성하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적
        - GOF의 디자인 패턴은 생성 패턴, 구조 패턴, 행위 패턴으로 구분됨
    - 생성 패턴(Creational Pattern)
        - 클래스나 객체의 생성과 참조 과정을 정의하는 패턴
        
        | 추상 팩토리
        (Abstract Factory) | - 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관, 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현한다.
        
        - 연관된 서브 클래스를 묶어 한 번에 교체하는 것이 가능하다. |
        | --- | --- |
        | 빌더(Builder) | - 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성한다.
        
         - 객체의 생성 과정과 표현 방법을 분리하고 있어, 동일한 객체 생성에서도 서로 다른 결과를 만들어 낼 수 있다.  |
        | 팩토리 메소드
        (Factory Method) | - 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴이다. 
        
        - 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
        
        - 가상 생성자(Virtual Constructor) 패턴이라고도 한다. |
        | 프로토타입
        (Prototype) | - 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
        
        - 일반적인 방법으로 객체를 생성하며, 비용이 큰 경우 주로 이용한다. |
        | 싱글톤(Singleton) | - 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.
        - 클래스 내에서 인스턴스가 하나뿐임을 보장하며, 불필요한 메모리 낭비를 최소화 할 수 있다. |
    - 구조 패턴(Structural Pattern)
        - 구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴
        
        | 어댑터(Adapter) | - 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환 해주는 패턴
        
        - 기존의 클래스를 이용하고 싶지만 인터페이스가 일치하지 않을 때 이용한다. |
        | --- | --- |
        | 브리지(Bridge) | - 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
        
        - 기능과 구현을 두 개의 별도 클래스로 구현한다. |
        | 컴포지트(Composite) | - 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
        
        - 객체들을 트리 구조로 구성하여 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현할 수 있다. |
        | 데코레이터(Decorator) | - 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴
        
        - 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현 |
        | 퍼싸드(Facade) | - 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
        
        - 서브 클래스들 사이의 통합 인터페이스를 제공하는 Wrapper 객체가 필요하다. |
        | 플라이웨이트
        (Flyweight) | - 인스턴스가 필요할 때마다 매번 생성하는 것이 아닌 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
        
        - 다수의 유사 객체를 생성하거나 조작할 때 유용하게 사용할 수 있다. |
        | 프록시(Proxy) | - 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴
        
        - 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용 |
    - 행위 패턴(Behavioral Pattern)
        - 클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴
        
        | 책임 연쇄
        (Chain of Responsibility) | - 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴
        
        - 요청을 처리할 수 있는 각 객체들이 고리(Chain)으로 묶여 있어 요청이 해결될 때까지 고리를 따라 책임이 넘어간다. |
        | --- | --- |
        | 커맨드(Command) | - 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴
        
        - 요청에 사용되는 각종 명령어들을 추상 클래스와 구체 클래스로 분리하여 단순화한다.  |
        | 인터프리터(Interpreter) | - 언어에 문법 표현을 정의하는 패턴
        
        - SQL이나 통신 프로토콜과 같은 것을 개발할 때 사용 |
        | 반복자(Iterator) | - 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴이다
        
        - 내부 표현 방법의 노출 없이 순차적인 접근이 가능하다. |
        | 중재자(Mediator) | - 수많은 객체들 간의 복잡한 상호작용(Interface)을 캡슐화하여 객체로 정의하는 패턴
        
        - 객체 사이의 의존성을 줄여 결합도를 감소시킬 수 있다.
        
        - 중재자는 객체 간의 통제와 지시의 역할을 수행 |
        | 메멘토(Memento) | - 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
        
        - Ctrl + Z와 같은 되돌리기 기능을 개발할 때 주로 이용 |
        | 옵서버(Observer) | - 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴
        
        - 주로 분산된 시스템 간에 이벤트를 생성, 발행(Publish)하고 이를 수신(Subscribe)해야 할 때 이용 |
        | 상태(State) | - 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴
        
        - 객체 상태를 캡슐화하고 이를 참조하는 방식으로 처리 |
        | 전략(Strategy) | - 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
        
        - 클라이언트는 독립적으로 원하는 알고리즘을 선택하여 사용할 수 있으며, 클라이언트에 영향 없이 알고리즘의 변경이 가능하다. |
        | 탬플릿 메소드
        (Template Method) | - 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴
        
        - 유사한 서브 클래스를 묶어 공통된 내용을 상위 클래스에서 정의함으로써 코드의 양을 줄이고 유지보수를 용이하게 해준다.  |
        | 방문자(Visitor) | - 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
        
        - 분리된 처리 기능은 각 클래스를 방문(Visit)하여 수행한다. |
- 개발 지원 도구 D
    - 통합 개발 환경(IDE; Integrated Development Environment)
        - 통합 개발 환경은 개발에 필요한 환경, 즉 편집기(Editor), 컴파일러(Compiler), 디버거(Debugger)등의 다양한 툴을 하나의 인터페이스로 통합하여 제공하는 환경
        - 통합 개발 환경 도구는 통합 개발 환경을 제공하는 소프트웨어를 의미
        - 통합 개발 환경 도구는 코드를 실행하거나 테스트할 때 오류가 발생한 부분을 시각화하므로 수정이 용이
    - 통합 개발 환경 도구의 종류
        
        
        | 프로그램 | 개발사 | 플랫폼 | 운영체제 | 지원 언어 |
        | --- | --- | --- | --- | --- |
        | 이클립스(Eclipse) | Eclipse Foundation, 
        IBM | 크로스 플랫폼 | Winodws,
        Linux,
        MacOS 등 | Java, C, C++
        PHP, JSP 등 |
        | 비주얼 스튜디오
        (Visual Studio) | Microsoft | Win32, Win64 | Windows | Basic, C, C++,
        C#, .NET 등 |
        | 엑스 코드(Xcode) | Applie | Mac, iPhone | MacOS,
        iOS | C, C++,
        C#, Java,
        AppleScript 등 |
        | 안드로이드 스튜디오
        (Android Studio) | Google | Android | Windows, 
        Linux,
        MacOS | Java, C, C++ |
        | IDEA | JetBrains
        이전 InteliJ) | 크로스 플랫폼 | Windows,
        Linux,
        MacOS | Java, JSP,
        XML, Go,, Kotlin,
        PHP 등  |
    - 빌드 도구
        - 빌드는 소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물
        - 빌드 도구는 전처리(Preprocessing), 컴파일(Compile)등의 작업을 수행
        - 대표적인 빌드 도구
            
            
            | 종류 | 특징 |
            | --- | --- |
            | Ant
            (Another 
            Neat Tool) | - 아파치 소프트웨어 재단에서 개발
            
            - 자바 프로젝트의 공식 빌드 도구 
            
            - 정해진 규칙이나 표준이 없음 |
            | Maven | - 아파치 소프트웨어 재단에서 Ant의 대안으로 개발
            
            - 의존성(Dependency)을 사용하여 라이브러리를 관리 
            
            - 규칙이나 표준이 존재하여 예외 사항만 기록 |
            | Gradle | - 한스 도커(Hans Dockter)가 Ant와 Maven을 보완하여 개발
            
            - 안드로이드 스튜디오의 공식 빌드 도구 
            
            - 그루비(Groovy) 기반의 빌드 스크립트를 사용  |
    - 기타 협업 도구
        - 협업 도구는 개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행할 수 있도록 도와주는 도구
        - 협업 소프트웨어, 그룹웨어(Groupware)등으로도 불림
        - 일정 관리, 업무흐름 관리, 정보 공유, 커뮤니케이션 등의 업무 보조 도구가 포함
- 서버 개발 D
    - 서버 개발
        - 서버 개발은 웹 애플리케이션의 로직을 구현할 서버 프로그램을 제작하여 웹 애플리케이션 서버(WAS)에 탑재하는 것을 의미
        - 서버 개발에 사용되는 프로그래밍 언어에는 Java, JavaScript, Python, PHP, Ruby 등이 있다
        - 각 프로그래밍 언어에는 해당 언어로 서버 프로그램을 개발할 수 있도록 지원하는 프레임워크 존재
    - 서버 개발 프레임워크
        - 서버 개발 프레임워크는 서버 프로그램 개발 시 다양한 네트워크 설정, 요청 및 응답 처리, 아키텍처 모델 구현 등을 손쉽게 처리할 수 있도록 클래스나 인터페이스를 제공하는 소프트웨어를 의미한다
        - 서버 개발 프레임워크의 대부분은 모델-뷰-컨트롤러(MVC) 패턴을 기반으로 개발되었다
        - 서버 개발 프레임워크의 종류
            
            
            | 프레임워크 | 특징 |
            | --- | --- |
            | Spring | JAVA를 기반으로 만들어진 프레임워크로, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다. |
            | Node.js | JavaScript를 기반으로 만들어진 프레임워크로, 비동기 입,출력 처리와 이벤트 위주의 높은 처리 성능을 갖고 있어 실시간으로 입,출력이 빈번한 애플리케이션에 적합하다. |
            | Django | Python을 기반으로 만들어진 프레임워크로, 컴포넌트의 재사용과 플러그인화를 강조하여 신속한 개발이 가능하도록 지원한다. |
            | Condeigniter | PHP를 기반으로 만들어진 프레임워크로, 인터페이스가 간편하여 서버 자원을 적게 사용한다. |
            | Ruby on Rails | Ruby를 기반으로 만들어진 프레임워크로, 테스트를 위한 웹 서버를 지원하며 데이터베이스 작업을 단순화, 자동화시켜 개발 코드의 길이가 짧아 신속한 개발이 가능하다. |
    - 서버 개발 과정
        - 서버 개발 과정은 DTO/VO, SQL, DAO, Service, Controller를 각각 구현하는 과정
        - 구현 순서는 개발자가 임의로 변경 가능
        - 개발하려는 서버 프로그램의 목적, 개발 언어, 규모 등의 이유로 통합하거나 세분화 가능
        - 구현 과정
            
            
            | 과정 | 내용 |
            | --- | --- |
            | DTO/VO 구현 | - 데이터 교환을 위해 사용할 객체를 만드는 과정 
            
            - 송, 수신할 데이터의 자료형(Data Type)에 맞는 변수 및 객체를 생성 |
            | SQL 구현 | - 데이터의 삽입, 변경, 삭제 등의 작업을 수행할 SQL문을 생성하는 과정 
            
            - SQL문은 소스 코드 내에 직접 입력, 또는 별도의 XML 파일로 관리 |
            | DAO 구현 | - 데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정 |
            | Service 구현 | - 사용자의 요청에 응답하기 위한 로직을 구현하는 과정  |
            | Controller 구현 | - 사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정  |
- 배치 프로그램 C
    - 배치 프로그램(Batch Parogram)
        - 배치 프로그램은 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램
        - 배치 프로그램의 필수 요소
            
            
            | 요소 | 내용 |
            | --- | --- |
            | 대용량 데이터 | - 대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함 |
            | 자동화 | - 심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 함  |
            | 견고성 | - 잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함 |
            | 안정성/신뢰성 | - 오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 함 |
            | 성능 | - 다른 응용 프로그램의 수행을 방해하지 않아야 함 
            
            - 지정된 시간 내에 처리가 완료되어야 함  |
    - 배치 스케줄러(Batch Scheduler)
        - 배치 스케줄러는 일괄 처리(Batch Processing) 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구
        - 특정 업무(Job)를 원하는 시간에 처리할 수 있도록 지원한다는 특성 때문에 잡 스케줄러(Job Scheduler)라고도 불린다
        - 배치 스케줄러의 종류
            
            
            | 배치 스케줄러 | 특징 |
            | --- | --- |
            | 스프링 배치
            (Spring Batch) | - Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크 
            
            - 로그 관리, 추적, 트랜잭션 관리, 작업 처리 통계, 작업 재시작 등의 다양한 기능 제공  |
            | Quatz | - 스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리 
            
            - 수행할 작업과 수행 시간을 관리하는 요소들을 분리하여 일괄 처리 작업에 유연성을 제공 |
            | Cron | - 리눅스의 기본 스케줄러 도구 
            
            - crontab 명령어를 통해 작업 예약 가능  |
    - crontab 명령어 작성 방법
        
        ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%207.png)
        

# 인터페이스 구현

- 시스템 인터페이스 요구사항 분석 D
    - 시스템 인터페이스 요구사항
        - 시스템 인터페이스 요구사항은 개발할 시스템과 외부 시스템을 연동하는데 필요한 시스템 인터페이스에 대한 요구사항을 기술한 것
        - 시스템 인터페이스 요구사항 명세서의 구성 요소
            - 인터페이스 이름
            - 연계 대상 시스템
            - 연계 범위 및 내용
            - 연계 방식
            - 송신 데이터
            - 인터페이스 주기
            - 기타 고려사항
    - 시스템 인터페이스 요구사항 분석
        - 시스템 인터페이스 요구사항 분석은 요구사항을 분류하고 구체적으로 명세한 후 이를 이해관계자에게 전달하는 일련의 과정
        - 소프트웨어 요구사항 분석 기법을 적절히 이용
        - 요구사항의 분해가 필요한 경우 적절한 수준으로 세분화
        - 요구사항 분석 시 누락된 요구사항이나 제한 조건 추가
        - 요구사항에 대한 상대적 중요도를 평가하여 우선순위 부여
    - 시스템 인터페이스 요구사항 분석 절차
        1. 시스템 인터페이스 관련 요구사항을 선별하여 별도로 요구사항 목록 작성
        2. 요구사항과 관련된 자료 준비
        3. 기능적인 요구사항과 비기능적인 요구사항을 분류 
        4. 요구사항을 분석하고 요구사항 명세서에 내용을 추가하거나 수정 
        5. 추가, 수정한 요구사항 명세서와 요구사항 목록을 관련 이해관계자에게 전달 
- 인터페이스 요구사항 검증 C
    - 인터페이스 요구사항 검증
        - 인터페이스 요구사항 검증은 사용자들의 요구사항이 요구사항 명세서에 정확하고 완전하게 기술되었는지 검토하고 개발 범위의 기준인 베이스라인을 설정하는 것
        - 인터페이스 요구사항 검증 수행 순서
            1. 요구사항 검토 계획 수립 : 검토 기준 및 방법, 참여자, 체크리스트, 관련 자료, 일정 등의 검토 계획 수립
            2. 검토 및 오류 수정 : 인터페이스 요구사항 명세서 검토 및 오류 목록과 시정 조치서 작성
            3. 베이스라인 설정 : 검증된 인터페이스 요구사항을 승인받은 후 요구사항 명세서의 베이스라인 설정 
    - 요구사항 검증 방법
        - 요구사항 검토(Requirements Review) : 요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법
            
            
            | 동료 검토
            (Peer Review) | 요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법  |
            | --- | --- |
            | 워크스루
            (Walk Through) | 검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법  |
            | 인스펙션
            (Inspection) | 요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법  |
        - 프로토타이핑(Prototyping) : 사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품(Prototype)을 만들어 최종 결과물을 예측
        - 테스트 설계 : 요구사항은 테스트할 수 있도록 작성되어야 하며, 이를 위해 테스트 케이스를 생성하여 요구사항이 현실적으로 테스트 가능한지를 검토
        - CASE 도구 활용 : 일관성 분석(Consistency Analysis)을 통해 요구사항 변경사항의 추적, 분석, 관리, 표준 준수 여부를 확인
    - 인터페이스 요구사항 검증의 주요 항목
        - 완전성(Completeness) : 사용자의 모든 요구사항이 누락되지 않고 완전하게 반영되어 있는가
        - 일관성(Consistency) : 요구사항이 모순되거나 충돌되는 점 없이 일관성을 유지하고 있는가
        - 명확성(Unambiguity) : 모든 참여자가 요구사항을 명확히 이해할 수 있는가
        - 기능성(Functionaility) : 요구사항이 어떻게(How to) 보다 무엇을(What)에 중점을 두고 있는가
        - 검증 가능성(Verifiability) : 요구사항이 사용자의 요구를 모두 만족하고, 개발된 소프트웨어가 사용자의 요구 내용과 일치하는지를 검증할 수 있는가
        - 추적 가능성(Traceability) : 요구사항 명세서와 설계서를 추적할 수 있는가
        - 변경 용이성(Easily Changeable) : 요구사항 명세서의 변경이 쉽도록 작성되었는가
- 송, 수신 데이터 식별 D
    - 식별 대상 데이터
        - 식별 대상 데이터는 송, 수신 시스템 사이에서 교환되는 데이터로, 규격화된 표준 형식에 따라 전송된다
        - 교환되는 데이터의 종류
            - 인터페이스 표준 항목
            - 송, 수신 데이터 항목
            - 공통 코드
    - 인터페이스 표준 항목
        - 인터페이스 표준 항목은 송,수신 시스템을 연계하는데 표준적으로 필요한 데이터
            
            
            | 시스템 공통부 | - 시스템 간 연동 시 필요한 공통 정보 
            
            - 구성 정보 : 인터페이스 ID, 전송 시스템 정보, 서비스 코드 정보, 응답 결과 정보, 장애 정보 등 |
            | --- | --- |
            | 거래 공통부 | - 시스템들이 연동된 후 송, 수신되는 데이터를 처리할 때 필요한 정보 
            
            - 구성 정보 : 직원 정보, 승인자 정보, 기기 정보, 매체 정보 등  |
    - 송, 수신 데이터 항목
        - 송, 수신 데이터 항목은 송, 수신 시스템이 업무를 수행하는 데 사용하는 데이터
        - 전송되는 데이터 항목과 순서는 인터페이스별로 다르다
    - 공통 코드
        - 공통 코드는 시스템들에서 공통으로 사용하는 코드
        - 연계 시스템이나 연계 소프트웨어에서 사용하는 상태 및 오류 코드 등의 항목에 대해 코드값과 코드명, 코드 설명 등을 공통 코드로 관리
    - 정보 흐름 식별
        - 정보 흐름은 개발할 시스템과 내, 외부 시스템 사이에서 전송되는 정보들의 방향성을 식별한다
        - 개발할 시스템과 내,외부 시스템에 대한 각각의 인터페이스 목록을 확인하여 정보 흐름을 식별한다
        - 식별한 정보 흐름을 기반으로 송,수신 시스템 사이에서 교환되는 주요 데이터 항목이나 정보 그룹을 도출한다.
    - 송, 수신 데이터 식별
        - 송,수신 데이터는 개발할 시스템과 연계할 내,외부 시스템 사이의 정보 흐름과 데이터베이스 산출물을 기반으로 식별한다
        - 송,수신 데이터의 종류에 따라 다음과 같이 식별한다
            - 인터페이스 표준 항목과 송,수신 데이터 항목 식별 : 송, 수신 시스템 사이의 교환 범위를 확인하고 인터페이스 표준 항목에 대해 송,수신 데이터 항목을 식별
            - 코드성 데이터 항목 식별 : 코드성 데이터 항목에 대해 코드, 코드명, 코드 설명 등의 코드 정보를 식별
- 인터페이스 방법 명세화 D
    - 인터페이스 방법 명세화
        - 인터페이스 방법 명세화는 내,외부 시스템이 연계하여 작동할 때 인터페이스별 송,수신 방법, 송,수신 데이터, 오류 식별 및 처리 방안에 대한 내용을 문서로 정리하는 것
            - 송,수신 방법 명세화 : 내, 외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 연계 방식, 통신 및 처리 유형, 발생 주기 등의 송, 수신 방법을 정의하고 명세를 작성하는 것
            - 송,수신 데이터 명세화 : 내, 외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 필요한 송, 수신 데이터에 대한 명세를 작성하는 것
            - 오류 식별 및 처리 방안 명세화 : 내, 외부 인터페이스 목록에 있는 각각의 인터페이스에 대해 인터페이스 시 발생할 수 있는 오류를 식별하고 오류 처리 방안에 대한 명세를 작성하는 것
        - 인터페이스별로 송,수신 방법을 명세화하기 위해 필요한 정보
            - 시스템 연계 기술
            - 인터페이스 통신 유형
            - 처리 유형
            - 발생 주기
    - 시스템 연계 기술
        
        
        | 기술 | 내용 |
        | --- | --- |
        | DB Link | DB에서 제공하는 DB Link 객체를 이용하는 방식 |
        | API/Open API | 송신 시스템의 데이터베이스(DB)에서 데이터를 읽어 와 제공하는 애플리케이션 프로그래밍 인터페이스 프로그램 |
        | 연계 솔루션 | EAI 서버와 송, 수신 시스템에 설치되는 클라이언트를 이용하는 방식 |
        | Socket | 서버가 통신을 위한 소켓(Socket)을 생성하여 포트를 할당하고 클라이언트의 통신 요청 시 클라이언트와 연결하여 통신하는 네트워크 기술 |
        | Web Service | 웹 서비스(Web Service)에서 WSDL, UDDI, SOAP 프로토콜을 이용하여 연계하는 서비스  |
    - 인터페이스 통신 유형
        
        
        | 유형 | 내용 |
        | --- | --- |
        | 단방향 | 시스템에서 거래를 요청만 하고 응답이 없는 방식 |
        | 동기 | 시스템에서 거래를 요청하고 응답이 올 때까지 대기(Request-Reply) 하는 방식 |
        | 비동기 | 시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리 하는 방식(Send-Receive, Send-Receive-Acknowledge, Publish-Subscribe) |
    - 인터페이스 처리 유형
        
        
        | 유형 | 내용 |
        | --- | --- |
        | 실시간 방식 | 사용자가 요청한 내용을 바로 처리해야 할 때 사용하는 방식 |
        | 지연 처리 방식 | 데이터를 매건 단위로 처리할 경우 비용이 많이 발생할 때 사용하는 방식 |
        | 배치 방식 | 대량의 데이터를 처리할 때 사용하는 방식  |
    - 인터페이스 발생 주기
        - 인터페이스 발생 주기는 개발할 시스템과 내,외부 시스템 간 송, 수신 데이터가 전송되어 인터페이스가 사용되는 주기를 의미한다
        - 업무의 성격과 송,수신 데이터 전송량을 고려하여 매일, 수시, 주 1회 등으로 구분한다
- 미들웨어 솔루션 B
    - 미들웨어(Middleware)
        - 미들웨어는 운영체제와 응용 프로그램, 또는 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어
        - 미들웨어는 표준화된 인터페이스를 제공함으로써 시스템 간의 데이터 교환에 일관성을 보장
        - 미들웨어의 종류
            - DB(DataBase)
            - RPC(Remote Procedure Call)
            - MOM(Message Oriented Middleware)
            - TP-Monitor(Transaction Processing Monitor)
            - ORB(Object Request Broker)
            - WAS(Web Application Server)
    - DB
        - 데이터베이스 벤더에서 제공하는 클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어
        - DB를 사용하여 시스템을 구축하는 경우 보통 2-Tier 아키텍처라고 한다
    - RPC(원격 프로시저 호출)
        - 응용 프로그램의 프로시저를 사용하여 원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어
    - MOM(메시지 지향 미들웨어)
        - 메시지 기반의 비동기형 메시지를 전달하는 미들웨어
        - 온라인 업무보다는 이기종 분산 데이터 시스템의 데이터 동기를 위해 많이 사용
    - TP-Monitor(트랜잭션 처리 모니터)
        - 온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어
        - 항공기나 철도 예약 업무 등 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 주로 사용
    - ORB(객체 요청 브로커)
        - 코바(CORBA) 표준 스펙을 구현한 객체 지향 미들웨어
        - 최근에는 TP-Monitor의 장점인 트랜잭션 처리와 모니터링 등을 추가로 구현한 제품도 있다
    - WAS(웹 애플리케이션 서버)
        - 사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어
        - 클라리언트/서버 환경보다는 웹 환경을 구현하기 위한 미들웨어
        - HTTP 세션 처리를 위한 웹 서버 기능뿐만 아니라 미션-크리티컬한 기업 업무까지 JAVA, EJB 컴포넌트 기반으로 구현 가능
- 모듈 연계를 위한 인터페이스 기능 식별 A
    - 모듈 연계
        - 모듈 연계는 내부 모듈과 외부 모듈 또는 내부 모듈 간 데이터의 교환을 위해 관계를 설정하는 것
        - 대표적인 모듈 연계 방법
            - EAI(Enterprise Application Integration)
            - ESB(Enterprise Service Bus)
            - 웹 서비스(Web Service)
    - EAI(Enterprise Application Integration)
        - 기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션
        - EAI 구축 유형
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%2042.png)
            
    - ESB(Enterprise Service Bus)
        - 애플리케이션 간 연계, 데이터 변환, 웹 서비스 지원 등 표준 기반의 인터페이스를 제공하는 솔루션
        - 애플리케이션 통합 측면에서 EAI와 유사하지만 애플리케이션 보다는 서비스 중심의 통합을 지향
        - 특정 서비스에 국한되지 않고 범용적으로 사용하기 위해 애플리케이션과의 결합도를 약하게 유지
        - 관리 및 보안 유지가 수월
        - 높은 수준의 품질 지원 가능
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%208e16a16d7d394d42a6f36fac62b565cc/Untitled%2043.png)
            
    - 웹 서비스(Web Service)
        - 네트워크의 정보를 표준화된 서비스 형태로 만들어 공유하는 기술
        - 웹 서비스는 서비스 지향 아키텍처(SOA) 개념을 실현하는 대표적인 방법
        - 웹 서비스의 구성
            
            
            | SOAP | - HTTP, HTTPS, SMTP 등을 활용하여 XML 기반의 메시지를 네트워크 상에서 교환하는 프로토콜 |
            | --- | --- |
            | UDDI | - WSDL을 등록하여 서비스와 서비스 제공자를 검색하고 접근하는데 사용 |
            | WSDL | - 웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어 
            
            - XML로 작성되며, UDDI의 기초가 됨 |
    - 모듈 간 연계 기능 식별
        - 모듈 간 연계 기능은 모듈과 연계된 기능을 시나리오 형태로 구체화하여 식별한다
        - 식별된 연계 기능은 인터페이스 기능을 식별하는데 사용
    - 모듈 간 인터페이스 기능 식별
        - 모듈 간 인터페이스 기능은 식별된 모듈 간 관련 기능을 검토하여 인터페이스 동작에 필요한 기능을 식별한다
        - 외부 및 인터페이스 모듈 간 동작하는 기능을 통해 인터페이스 기능을 식별
        - 해당 업무에 대한 시나리오를 통해 내부 모듈과 관련된 인터페이스 기능을 식별
        - 식별된 인터페이스 기능 중에서 실제적으로 필요한 인터페이스 기능을 최종적으로 선별
        - 식별된 인터페이스 기능은 인터페이스 기능 구현을 정의하는데 사용
- 모듈 간 인터페이스 데이터 표준 확인 D
    - 인터페이스 데이터 표준
        - 인터페이스 데이터 표준은 모듈 간 인터페이스에 사용되는 데이터의 형식을 표준화하는 것
        - 인터페이스 데이터 표준은 기존의 데이터 중에서 공통 영역을 추출하거나 어느 한쪽의 데이터를 변환하여 정의
        - 확인된 인터페이스 데이터 표준은 인터페이스 기능 구현을 정의하는데 사용
    - 인터페이스 데이터 표준 확인
        - 데이터 인터페이스 확인 : 데이터 표준을 위해 식별된 데이터 인터페이스에서 입,출력값의 의미와 데이터의 특성 등을 구체적으로 확인
        - 인터페이스 기능 확인 : 데이터 표준을 위해 식별된 인터페이스 기능을 기반으로 인터페이스 기능 구현을 위해 필요한 데이터 항목을 확인
        - 인터페이스 데이터 표준 확인 : 데이터 인터페이스에서 확인된 데이터 표준과 인터페이스 기능을 통해 확인된 데이터 항목들을 검토하여 최종적으로 데이터 표준을 확인
- 인터페이스 기능 구현 정의 D
    - 인터페이스 기능 구현의 정의
        - 인터페이스 기능 구현의 정의는 인터페이스를 실제로 구현하기 위해 인터페이스 기능에 대한 구현 방법을 기능별로 기술하는 것
        - 인터페이스 기능 구현 정의 절차
            - 컴포넌트 명세서 확인
                - 컴포넌트의 개요, 내부 클래스의 클래스명과 설명 등을 통해 컴포넌트가 가지고 있는 주요 기능을 확인함
                - 인터페이스 클래스를 통해 인터페이스에 필요한 주요 기능을 확인
            - 인터페이스 명세서 확인
                - 컴포넌트 명세서의 인터페이스 클래스에 명시된 인터페이스의 세부 조건 및 기능을 확인
            - 일관된 인터페이스 기능 구현 정의
                - 인터페이스의 기능, 인터페이스 데이터 표준, 모듈 세부 설게서를 통해 인터페이스의 기능 구현을 정의
                - 정의한 인터페이스 기능 구현에 대해 송, 수신 측에서 진행해야 할 절차까지 다시 세부적으로 정의
            - 정의된 인터페이스 기능 구현 정형화
                - 정의한 인터페이스 기능 구현을 특정 하드웨어나 소프트웨어에 의존적이지 않게 사람들이 보기 쉽고 표준화 되도록 정형화
    - 모듈 세부 설계서
        - 모듈 세부 설계서는 모듈의 구성 요소와 세부적인 동작 등을 정의한 설계서
        - 모듈 세부 설계서 종류
            
            
            | 컴포넌트 명세서 | 컴포넌트의 개요 및 내부 클래스의 동작, 인터페이스를 통해 외부와 통신하는 명세 등을 정의한 것  |
            | --- | --- |
            | 인터페이스 명세서 | 컴포넌트 명세서의 항목 중 인터페이스 클래스의 세부 조건 및 기능 등을 정의한 것  |
- 인터페이스 구현 A
    - 인터페이스 구현
        - 인터페이스 구현은 송, 수신 시스템 간의 데이터 교환 및 처리를 실현해 주는 작업
        - 대표적인 인터페이스 구현 방법
            - 데이터 통신을 이용한 인터페이스 구현
            - 인터페이스 엔티티를 이용한 인터페이스 구현
    - 데이터 통신을 이용한 인터페이스 구현
        - 데이터 통신을 이용한 인터페이스 구현은 애플리케이션 영역에서 데이터 포맷을 인터페이스 대상으로 전송하면 이를 수신 측에서 파싱하여 해석하는 방식
        - 주로 JSON이나 XML 형식의 데이터 포맷을 사용하여 인터페이스를 구현
    - 인터페이스 엔티티를 이용한 인터페이스 구현
        - 인터페이스 엔티티를 이용한 인터페이스 구현은 인터페이스가 필요한 시스템 사이에 별도의 인터페이스 엔티티를 두어 상호 연계하는 것
        - 일반적으로 인터페이스 테이블을 엔티티로 활용한다
    - JSON(JavaScript Object Notation)
        - 웹과 컴퓨터 프로그램에서 용량이 적은 데이터를 교환하기 위해 데이터 객체를 송성,값의 쌍(Attribute-Value Pairs) 형태로 표현하는 개방형 표준 포맷
        - 비동기 처리에 사용되는 AJAX에서 XML을 대체하여 사용
    - AJAX(Asynchronous JavaScript and XML)
        - AJAX는 자바 스크립트를 사용하여 클라이언트와 서버 간에 XML 데이터를 주고 받는 비동기 통신 기술
        - 전체 페이지를 새로 고치지 않고도 웹 페이지 일부 영역만을 업데이트할 수 있다
- 인터페이스 보안 B
    - 인터페이스 보안
        - 인터페이스 보안은 인터페이스의 보안성 향상을 위해 인터페이스의 보안 취약점을 분석한 후 적절한 보안 기능을 적용하는 것
    - 인터페이스 보안 기능 적용
        - 인터페이스 보안 기능은 일반적으로 네트워크, 애플리케이션, 데이터베이스 영역에 적용한다
            
            
            | 네트워크 영역 | - 인터페이스 송, 수신 간 스니핑(Sniffing) 등을 이용한 데이터 탈취 및 변조 위협을 방지하기 위해 네트워크 트래픽에 대한 암호화를 설정
            
            - 암호화는 인터페이스 아키텍처에 따라 IPSec, SSL, S-HTTP 등의 다양한 방식으로 적용함 |
            | --- | --- |
            | 애플리케이션 영역 | - 소프트웨어 개발 보안 가이드를 참조하여 애플리케이션 코드 상의 보안 취약점을 보완하는 방향으로 애플리케이션 보안 기능을 적용 |
            | 데이터베이스 영역 | - 데이터베이스, 스키마, 엔티티의 접근 권한과 프로시저, 트리거 등 데이터베이스 동작 객체의 보안 취약점에 보안 기능을 적용
            
            - 개인 정보나 업무상 민감한 데이터의 경우 암호화나 익명화 등 데이터 자체의 보안 방법도 고려함  |
    - 데이터 무결성 검사 도구
        - 데이터 무결성 검사 도구는 인터페이스 보안 취약점을 분석하는데 사용되는 도구
        - 데이터 무결성 검사 도구는 시스템 파일의 변경 유무를 확인하고, 파일이 변경되었을 경우 이를 관리자에게 알려준다
        - 종류 : Tripwire, AIDE, Samhain, Claymore, Slipwire, Fcheck등
- 인터페이스 구현 검증 B
    - 인터페이스 구현 검증
        - 인터페이스 구현 검증은 인터페이스가 정상적으로 문제없이 작동하는지 확인하는 것
        - 인터페이스 구현 검증 도구와 감시 도구를 이용하여 인터페이스의 동작 상태를 확인
    - 인터페이스 구현 검증 도구
        - 인터페이스 구현을 검증하기 위해서는 인터페이스 단위 기능과 시나리오 등을 기반으로 하는 통합 테스트가 필요
        - 통합 테스트를 수행하기 위해 사용되는 테스트 자동화 도구
            
            
            | 도구 | 기능 |
            | --- | --- |
            | xUnit | - 같은 테스트 코드를 여러 번 작성하지 않게 도와주고, 테스트마다 예상 결과를 기억할 필요가 없게 하는 자동화된 해법을 제공하는 단위 테스트 프레임워크
            
            - Smalltalk에 처음 적응되어 SUnit이라는 이름이었으나 Java용의 JUnit, C++용의 CppUnit, .Net용의 NUnit, Http용의 HttpUnit 등 다양한 언어에 적용되면서 xUnit으로 통칭되고 있다. |
            | STAF | - 서비스 호출 및 컴포넌트 재사용 등 다양한 환경을 지원하는 테스트 프레임워크
            
            - 크로스 플랫폼, 분산 소프트웨어 테스트 환경을 조성할 수 있도록 지원
            
            - 분산 소프트웨어의 경우 각 분산 환경에 설치된 데몬이 프로그램 테스트에 대한 응답을 대신하며, 테스트가 완료되면 이를 통합하고 자동화하여 프로그램을 완성한다. |
            | FitNesse | - 웹 기반 테스트케이스 설계, 실행, 결과 확인 등을 지원하는 테스트 프레임워크이다. |
            | NTAF | - FitNess의 장점인 협업 기능과 STAF의 장점인 재사용 및 확장성을 통합한 NHN(Naver)의 테스트 자동화 프레임워크이다. |
            | Selenium |  - 다양한 브라우저 및 개발 언어를 지원하는 웹 애플리케이션 테스트 프레임워크이다. |
            | watir | -Ruby를 사용하는 애플리케이션 테스트 프레임워크이다. |
    - 인터페이스 구현 감시 도구
        - 인터페이스 동작 상태는 APM(애플리케이션 성능 관리)을 사용하여 감시할 수 있다
        - APM을 통해 데이터베이스와 웹 애플리케이션의 트랜잭션, 변수값, 호출 함수, 로그 및 시스템 부하 등 종합적인 정보를 조회하고 분석할 수 있다
        - 대표적인 APM
            
            
            | 스카우터(Scouter) | 애플리케이션 및 OS 자원에 대한 모니터링 기능을 제공하는 오픈소스 APM 소프트웨어 |
            | --- | --- |
            | 제니퍼(Jennifer) | 애플리케이션의 개발부터 테스트, 오픈, 운영, 안정화까지 전 단계에 걸쳐 성능을 모니터링하고 분석해주는 소프트웨어  |
    - APM(Application Performance Management/Monitoring)
        - APM은 애플리케이션의 성능 관리를 위해 접속자, 자원 현황, 트랜잭션 수행 내역, 장애 진단 등 다양한 모니터링 기능을 제공하는 도구
        - APM은 리소스 방식과 엔드투엔드(End-to-End)의 두 가지 유형이 있다
            
            
            | 리소스 방식 | Nagios, Zabbix, Cacti 등 |
            | --- | --- |
            | 엔드투엔드 방식 | VisualVM, 제니퍼, 스카우터 등  |

# 화면 설계

- 사용자 인터페이스 A
    - 사용자 인터페이스(UI, User Interface)
        - 사용자 인터페이스는 사용자와 시스템 간의 상호작용이 원활하게 이뤄지도록 도와주는 장치나 소프트웨어를 의미
        - 사용자 인터페이스의 세 가지 분야
            - 정보 제공과 전달을 위한 물리적 제어에 관한 분야
            - 콘텐츠의 상세적인 표현과 전체적인 구성에 관한 분야
            - 모든 사용자가 편리하고 간편하게 사용하도록 하는 기능에 관한 분야
    - 사용자 인터페이스의 구분
        
        
        | 구분 | 내용 |
        | --- | --- |
        | CLI(Command Line
        Interface) | 명령과 출력이 텍스트 형태로 이뤄지는 인터페이스 |
        | GUI(Graphical User
        Interface) | 아이콘이나 메뉴를 마우스로 선택하여 작업을 수행하는 그래픽 환경의 인터페이스 |
        | NUI(Natural User
        Interface) | 사용자의 말이나 행동 등 자연스러운 움직임을 통해 기기를 조작하는 인터페이스 |
    - 사용자 인터페이스의 기본 원칙
        
        
        | 원칙 | 내용 |
        | --- | --- |
        | 직관성 | 누구나 쉽게 이해하고 사용할 수 있어야 한다 |
        | 유효성 | 사용자의 목적을 정확하고 완벽하게 달성해야 한다 |
        | 학습성 | 누구나 쉽게 배우고 익힐 수 있어야 한다 |
        | 유연성 | 사용자의 요구사항을 최대한 수용하고 실수를 최소화해야 한다 |
- UI 설계 도구 C
    - 와이어프레임(Wireframe)
        - 와이어프레임은 페이지에 대한 개략적인 레이아웃이나 UI 요소 등에 대한 뼈대를 설계하는 도구
        - 와이어프레임은 기획 단계의 초기에 제작
        - 개발자나 디자이너 등이 레이아웃을 협의하거나 현재 진행 상태 등을 공유하기 위해 사용
        - 페이지의 영역 구분, 콘텐츠, 텍스트 배치 등을 화면 단위로 설계
        - 와이어프레임 툴 : 손그림, 파워포인트, 키노트, 스케치, 일러스트, 포토샵 등
    - 목업(Mockup)
        - 목업은 와이어프레임보다 좀 더 실제 화면과 유사하게 만든 정적인 형태의 모형
        - 디자인, 사용 방법 설명, 평가 등을 위해 만든다
        - 시각적으로만 구성 요소를 배치하는 것으로 실제로 구현되지는 않는다
        - 목업 툴 : 파워 목업, 발사믹 목업 등
    - 스토리보드(Story Board)
        - 스토리 보드는 와이어프레임에 콘텐츠에 대한 설명, 페이지 간 이동 흐름 등을 추가한 문서
        - 디자이너와 개발자가 최종적으로 참고하는 작업 지침서
        - 서비스 구축을 위한 모든 정보가 들어 있다
        - 스토리보드 툴 : 파워포인트, 키노트, 스케치, Axure 등
    - 프로토타입(Prototype)
        - 프로토타입은 와이어프레임이나 스토리보드 등에 인터랙션을 적용함으로써 실제 구현된 것처럼 테스트가 가능한 동적인 형태의 모형
        - 사용자의 요구사항을 개발자가 맞게 해석했는지 검증하기 위한 것
        - 일부 핵심적인 기능만을 제공
        - 종류
            
            
            | 페이퍼 프로토타입 | - 스케치, 그림, 글 등을 이용하여 손으로 직접 작성하는 아날로그적인 방법 
            
            - 제작 기간이 짧은 경우, 제작 비용이 적을 경우, 업무 협의가 빠를 경우 사용 |
            | --- | --- |
            | 디지털 프로토타입 | - 파워포인트, 아크로뱃, 비지오, 옴니그래플 등과 같은 프로그램을 사용하여 작성하는 방법 
            
            - 재사용이 필요한 경우, 산출물과 비슷한 효과가 필요한 경우, 숙련된 전문가가 있을 경우 사용  |
    - 유스케이스(Use Case)
        - 유스케이스는 사용자의 요구사항을 기능 단위로 표현하는 것
        - 사용자가 원하는 목표를 달성하기 위해 수행할 내용을 기술
        - 사용자의 요구사항을 빠르게 파악함으로써 프로젝트의 초기에 시스템의 기능적인 요구를 결정하고 그 결과를 문서화할 수 있다
        - 일반적으로 다이어그램 형식으로 묘사
- 품질 요구사항 B
    - 품질 요구사항
        - 소프트웨어 품질은 소프트웨어에 대한 요구사항이 사용자의 입장에서 얼마나 충족하는가를 나타내는 소프트웨어 특성의 총체
        - 소프트웨어의 품질은 사용자의 요구사항을 충족시킴으로써 확립
        - 소프트웨어 품질 관련 표준
            
            
            | ISO/IEC 9126 | 소프트웨어의 품질 특성과 평가를 위한 국제 표준 |
            | --- | --- |
            | ISO/IEC 25010 | ISO/IEC 9126에 호환성과 보안성을 강화하여 개정한 소프트웨어 제품에 대한 국제 표준 |
            | ISO/IEC 12119 | 패키지 소프트웨어의 일반적인 제품 품질 요구사항 및 테스트를 위한 국제 표준 |
            | ISO/IEC 14598 | 소프트웨어 품질의 측정과 평가에 필요 절차를 규정한 표준 |
    - ISO/IEC 9126의 소프트웨어 품질 특성
        
        
        | 특성 | 내용 |
        | --- | --- |
        | 기능성
        (Functionality) | - 소프트웨어가 사용자의 요구사항을 정확하게 만족하는 기능을 제공하는지 여부를 나타냄
        
        - 하위 특성 : 적절성/적합성, 정밀성/정확성, 상호 운용성, 보안성, 준수성 |
        | 신뢰성
        (Reliability) | - 주어진 시간동안 주어진 기능을 오류 없이 수행할 수 있는 정도
        
        - 하위 특성 : 성숙성, 고장 허용성, 회복성 |
        | 사용성
        (Usability) | - 사용자와 컴퓨터 사이에 발생하는 어떠한 행위에 대하여 사용자가 정확하게 이해하고 사용하며, 향후 다시 사용하고 싶은 정도
        
        - 하위 특성 : 이해성, 학습성, 운용성, 친밀성 |
        | 효율성
        (Efficiency) | - 사용자가 요구하는 기능을 얼마나 빠르게 처리할 수 있는지 정도
        
        - 하위 특성 : 시간 효율성, 자원 효율성  |
        | 유지 보수성
        (Maintainability) | - 환경의 변화 또는 새로운 요구사항이 발생했을 때 소프트웨어를 개선하거나 확장할 수 있는 정도 
        
        - 하위 특성 : 분석성, 변경성, 안정성, 시험성 |
        | 이식성
        (Portability) | - 소프트웨어가 다른 환경에서도 얼마나 쉽게 적용할 수 있는지 정도 
        
        - 하위 특성 : 적용성, 설치성, 대체성, 공존성 |
- UI 설계 D
    - UI 설계서
        - UI 설계서는 사용자의 요구사항을 바탕으로 UI 설계를 구체화하여 작성하는 문서
        - UI 설계서는 기획자, 개발자, 디자이너 등과의 원활한 의사소통을 위해 작성
        - UI 설계서 작성 순서
            1. UI 설계서 표지 작성 : 다른 문서와 혼동되지 않도록 프로젝트명 또는 시스템명을 포함하여 작성
            2. UI 설계서 개정 이력 작성 : UI 설계서가 수정될 때마다 어떤 부분이 어떻게 수정되었는지를 정리
            3. UI 요구사항 정의서 작성 : 사용자의 요구사항을 확인하고 정리
            4. 시스템 구조 작성 : UI 요구사항과 UI 프로토타입에 기초하여 전체 시스템의 구조를 설계
            5. 사이트 맵 작성 : 사이트에 표시할 콘텐츠를 메뉴별로 구분하여 설계
            6. 프로세스 정의서 작성 : 사용자가 요구하는 프로세스들을 작업 진행 순서에 맞춰 정리
            7. 화면 설계 : 필요한 화면을 페이지별로 설계 
    - UI 흐름 설계
        - UI 흐름 설계는 업무의 진행 과정이나 수행 절차에 따른 흐름을 파악하여 화면과 폼을 설계하는 단계
        - UI 흐름 설계 순서
            1. 기능 작성 : 화면에 표현할 기능을 작성
            2. 입력 요소 확인 : 화면에 표현되어야 할 기능을 확인한 후 화면에 입력할 요소를 확인
            3. 유스케이스 설계 : UI 요구사항을 기반으로 UI 유스케이스를 설계
            4. 기능 및 양식 확인 : 텍스트 박스, 콤보 박스, 라디오 박스, 체크 박스 등을 확인하고 규칙을 정의
    - UI 상세 설계
        - UI 상세 설계는 UI 설계서를 바탕으로 실제 설계 및 구현을 위해 모든 화면에 대해 자세하게 설계를 진행하는 단계
        - UI 상세 설계를 할 때는 반드시 시나리오 작성 필요
        - UI 상세 설계 순서
            1. 요구사항 확인
                - UI 상세 설계를 위한 요구사항을 최종적으로 확인
            2. UI 설계서 표지 및 개정 이력 작성 
                - 표지 : 다른 문서와 혼동되지 않도록 프로젝트명이나 시스템명을 포함
                - 개정 이력 : UI 설계서의 수정사항 정리
            3. UI 구조 설계
                - UI 요구사항과 UI 프로토타입에 기초하여 UI 구조를 설계하는 단계
            4. 메뉴 구조 설계
                - 사이트 맵 구조를 설계한 후 이를 바탕으로 사용자 기반 메뉴 구조를 설계
            5. 화면 설계
                - UI 프로토타입과 UI 프로세스를 참고하여 필요한 화면을 페이지별로 설계
    - UI 시나리오 문서
        - UI 시나리오 문서는 사용자 인터페이스의 기능 구조, 대표 화면, 화면 간 인터랙션의 흐름, 다양한 상황에서의 예외 처리 등을 정리한 문서
        - 사용자가 최종 목표를 달성하기 위한 방법이 순차적으로 묘사되어 있음
        - UI 시나리오 문서의 요건
            
            
            | 완전성(Complete) | 누락되지 않도록 최대한 상세하게 기술 |
            | --- | --- |
            | 일관성(Consistent) | 서비스 목표, 시스템 및 사용자의 요구사항, UI 스타일 등이 모두 일관성을 유지해야 함 |
            | 이해성
            (Understandable) | 누구나 쉽게 이해할 수 있도록 설명 |
            | 가독성(Readable) | 표준화된 템플릿 등을 활용하여 문서를 쉽게 읽을 수 있도록 해야 함 |
            | 수정 용이성
            (Modifiable) | 시나리오의 수정이나 개선이 쉬워야 함 |
            | 추적 용이성(Traceable) | 변경 사항은 언제, 어떤 부분이, 왜 발생했는지 쉽게 추적할 수 있어야 함 ㅣㅣ |
- HCI / UX / 감성공학 B
    - HCI(Human Computer Interaction or Interface)
        - HCI는 사람이 시스템을 보다 편리하고 안전하게 사용할 수 있도록 연구하고 개발하는 학문
        - 최종 목표는 시스템을 사용하는데 있어 최적의 사용자 경험(UX)을 만드는 것
        - HCI는 어떤 제품이 좋은 제품인지, 어떻게 하면 좋은 제품을 만들 수 있는지 등을 연구
    - UX(User Experience, 사용자 경험)
        - UX는 사용자가 시스템이나 서비스를 이용하면서 느끼고 생각하게 되는 총체적인 경험
        - UI가 사용성, 접근성, 편의성을 중시한다면 UX는 이러한 UI를 통해 사용자가 느끼는 만족이나 감정을 중시
        - UX는 기술을 효용성 측면에서만 보는 것이 아니라 사용자의 삶의 질을 향상시키는 하나의 방향으로 보는 새로운 개념
        - UX의 특징
            
            
            | 주관성(Subjectivity) | 사람들의 개인적, 신체적, 인지적 특성에 따라 다르므로 주관적 |
            | --- | --- |
            | 정황성(Contextuality) | 경험이 일어나는 상황 또는 주변 환경에 영향을 받음 |
            | 총체성(Holistic) | 개인이 느끼는 총체적인 심리적, 감성적인 결과 |
    - 감성공학
        - 감성공학은 제품이나 작업환경을 사용자의 감성에 알맞도록 설계 및 제작하는 기술
        - 인문사회과학, 공학, 의학 등 여러 분야의 학문이 공존하는 종합과학
        - 감성공학의 목적은 인간의 삶을 편리하고 안전하며 쾌적하게 만드는 것
        - 감성공학은 인간의 감성을 구체적으로 제품 설계에 적용하기 위해 공학적인 접근 방법을 사용

# 애플리케이션 테스트 관리

- 애플리케이션 테스트 B
    - 애플리케이션 테스트
        - 애플리케이션 테스트는 애플리케이션에 잠재되어 있는 결함을 찾아내는 일련의 행위 또는 절차
        - 애플리케이션 테스트는 개발된 소프트웨어가 고객의 요구사항을 만족시키는지 확인(Validation)하고 소프트웨어가 기능을 정확히 수행하는지 검증(Verification) 한다.
    - 애플리케이션 테스트의 기본 원리
        
        
        | 기본 원리 | 설명 |
        | --- | --- |
        | 완벽한 테스트 불가능 | 소프트웨어의 잠재적인 결함을 줄일 수 있지만 소프트웨어에 결함이 없다고 증명할 수는 없음 |
        | 파레토 법칙
        (Pareto Principle) | 애플리케이션의 20%에 해당하는 코드에서 전체 결함의 80%가 발견된다는 법칙 |
        | 살충제 패러독스
        (Pesticide Paradox) | 동일한 테스트 케이스로 동일한 테스트를 반복하면 더 이상 결함이 발견되지 않는 현상 |
        | 테스팅은 정황(Context)
        의존 | 소프트웨어의 특징, 테스트 환경, 테스터의 역량 등 정황(Context)에 따라 테스트 결과가 달라질 수 있으므로, 정황에 따라 테스트를 다르게 수행해야 함 |
        | 오류-부재의 궤변
        (Absence of Errors
        Fallacy) | 소프트웨어의 결함을 모두 제거해도 사용자의 요구사항을 만족시키지 못하면 해당 소프트웨어는 품질이 높다고 말할 수 없음 |
        | 테스트와 위험은 반비례 | 테스트를 많이 하면 할수록 미래에 발생할 위험을 줄일 수 있음 |
        | 테스트의 점진적 확대 | 테스트는 작은 부분에서 시작하여 점점 확대하며 진행해야 함 |
        | 테스트의 별도 팀 수행 | 테스트는 개발자와 관계없는 별도의 팀에서 수행해야 함  |
- 애플리케이션 테스트의 분류 B
    - 프로그램 실행 여부에 따른 테스트
        
        
        | 정적 테스트 | - 프로그램을 실행하지 않고 명세서나 소스 코드를 대상으로 분석하는 테스트 
        
        - 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도, 남은 결함 등을 발견하기 위해 사용
        
        - 종류 : 워크스루, 인스펙션, 코드 검사 등 |
        | --- | --- |
        | 동적 테스트 | - 프로그램을 실행하여 오류를 찾는 테스트 
        
        - 소프트웨어 개발의 모든 단계에서 테스트를 수행 
        
        - 종류 : 블랙박스 테스트, 화이트박스 테스트 |
    - 테스트 기반(Test Bases)에 따른 테스트
        
        
        | 명세 기반 테스트 | - 사용자의 요구사항에 대한 명세를 빠짐없이 테스트 케이스로 만들어 구현하고 있는지 확인하는 테스트 
        
        - 종류 : 동등 분할, 경계 값 분석 등 |
        | --- | --- |
        | 구조 기반 테스트 | - 소프트웨어 내부의 논리 흐름에 따라 테스트 케이스를 작성하고 확인하는 테스트 
        
        - 종류 : 구문 기반, 결정 기반, 조건 기반 등 |
        | 경험 기반 테스트 | - 유사 소프트웨어나 기술 등에 대한 테스터의 경험을 기반으로 수행하는 테스트 
        
        - 사용자의 요구사항에 대한 명세가 불충분하거나 테스트 시간에 제약이 있는 경우 수행하면 효과적 
        
        - 종류 : 에러 추정, 체크 리스트, 탐색적 테스팅  |
    - 시각에 따른 테스트
        
        
        | 검증(Verification)
        테스트 | - 개발자의 시각에서 제품의 생산 과정을 테스트
        
        - 제품이 명세서대로 완성됐는지를 테스트  |
        | --- | --- |
        | 확인(Validation)
        테스트 | - 사용자의 시각에서 생산된 제품의 결과를 테스트
        
        - 사용자가 요구한대로 제품이 완성됐는지, 제품이 정상적으로 동작하는지를 테스트  |
    - 목적에 따른 테스트
        
        
        | 회복(Recovery)
        테스트 | 시스템에 여러 가지 결함을 주어 실패하도록 한 후 올바르게 복구되는지를 확인하는 테스트 |
        | --- | --- |
        | 안전(Security)
        테스트 | 시스템에 설치된 시스템 보호 도구가 불법적인 침입으로부터 시스템을 보호할 수 있는지를 확인하는 테스트 |
        | 강도(Stress)
        테스트 | 시스템에 과도한 정보량이나 빈도 등을 부과하여 과부하 시에도 소프트웨어가 정상적으로 실행되는지를 확인하는 테스트  |
        | 성능(Performance)
        테스트 | 소프트웨어의 실시간 성능이나 전체적인 효율성을 진단하는 테스트로, 소프트웨어의 응답 시간, 처리량 등을 테스트 |
        | 구조(Structure)
        테스트 | 소프트웨어 내부의 논리적인 경로, 소스 코드의 복잡도 등을 평가하는 테스트 |
        | 회귀(Regression)
        테스트 | 소프트웨어의 변경 또는 수정된 코드에 새로운 결함이 없음을 확인하는 테스트 |
        | 병행(Parallel)
        테스트 | 변경된 소프트웨어와 기존 소프트웨어에 동일한 데이터를 입력하여 결과를 비교하는 테스트  |
- 테스트 기법에 따른 애플리케이션 테스트 A
    - 화이트박스 테스트(White Box Test
        - 화이트박스 테스트는 모듈의 원시 코드를 오픈시킨 상태에서 원시 코드의 논리적인 모든 경로를 테스트하여 테스트 케이스를 설계하는 방법
        - 모듈 안의 작동을 직접 관찰
        - 원시 코드(모듈)의 모든 문장을 한 번 이상 실행함으로써 수행
    - 화이트박스 테스트의 종류
        
        
        | 기초 경로 검사
        (Base Path Testing) | - 테스트 케이스 설계자가 절차적 설계의 논리적 복잡성을 측정할 수 있게 해주는 테스트 기법 
        
        - 대표적인 화이트박스 테스트 기법  |
        | --- | --- |
        | 제어 구조 검사
        (Control Structure
        Testing) | - 조건 검사(Condition Testing) : 프로그램 모듈 내에 있는 논리적 조건을 테스트하는 테스트 케이스 설계 기법 
        
        - 루프 검사(Loop Testing) : 프로그램의 반복(Loop) 구조에 초점을 맞춰 실시하는 테스트 케이스 설계 기법 
        
        - 데이터 흐름 검사(Data Flow Testing) :프로그램에서 변수의 정의와 변수 사용의 위치에 초점을 맞춰 실시하는 테스트 케이스 설계 기법  |
    - 화이트박스 테스트의 검증 기준
        
        
        | 문장 검증 기준
        (Statement Coverage) | - 소스 코드의 모든 구문이 한 번 이상 수행되도록 테스트 케이스를 설계  |
        | --- | --- |
        | 분기 검증 기준
        (Branch Coverage) | - 소스 코드의 모든 조건문에 대해 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계 
        
        - 결정 검증 기준(Decision Coverage)이라고도 함 |
        | 조건 검증 기준
        (Condition Coverage) | - 소스 코드의 조건문에 포함된 개별 조건식의 결과가 True인 경우와 False인 경우가 한 번 이상 수행되도록 테스트 케이스를 설계  |
        | 분기/조건 기준
        (Branch/Condition
        Coverage) | - 분기 검증 기준과 조건 검증 기준을 모두 만족하는 설계로, 조건문이 True인 경우와 False인 경우에 따라 조건 검증 기준의 입력 데이터를 구분하는 테스트 케이스 설계  |
    - 블랙박스 테스트(Black Box Test)
        - 블랙박스 테스트는 소프트웨어가 수행할 특정 기능을 알기 위해서 각 기능이 오나전히 작동되는 것을 입증하는 테스트로, 기능 테스트라고도 함
        - 사용자의 요구사항 명세를 보면서 테스트
        - 주로 구현된 기능을 테스트
        - 소프트웨어 인터페이스를 통해 실시
    - 블랙박스 테스트의 종류
        
        
        | 동치 분할 검사
        (Equivalence
        Partitioning Testing,
        동치 클래스 분해) | - 프로그램의 입력 조건에 타당한 입력 자료와 타당하지 않은 입력 자료의 개수를 균등하게 하여 테스트 케이스를 정하고, 해당 입력 자료에 맞는 결과가 출력되는지 확인하는 기법 
        
        - 동등 분할 기법이라고도 함  |
        | --- | --- |
        | 경계값 분석(Boundary
        Value Analysis) | - 입력 조건의 중간값보다 경계값에서 오류가 발생될 확률이 높다는 점을 이용하여 입력 조건의 경계값을 테스트 케이스로 선정하여 검사하는 기법  |
        | 원인-효과 그래프 검사
        (Cause-Effect
        Graphing Testing) | - 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석한 다음 효용성이 높은 테스트 케이스를 선정하여 검사하는 기법 |
        | 오류 예측 검사
        (Error Guessing) | - 과거의 경험이나 확인자의 감각으로 테스트하는 기법 |
        | 비교 검사
        (Comparison Testing) | - 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력되는지 테스트하는 기법 |
- 개발 단계에 따른 애플리케이션 테스트 A
    - 개발 단계에 따른 애플리케이션 테스트
        - 소프트웨어의 개발 단계에 따라 단위 테스트, 통합 테스트, 시스템 테스트, 인수 테스트로 분류된다. 이렇게 분류된 것을 테스트 레벨이라 한다
        - 애플리케이션 테스트와 소프트웨어 개발 단계를 연결하여 표현한 것을 V-모델이라 한다
            
            ![Untitled](%E1%84%89%E1%85%B5%E1%84%82%E1%85%A1%E1%84%80%E1%85%A9%E1%86%BC%20%E1%84%89%E1%85%B5%E1%86%AF%E1%84%80%E1%85%B5%201%E1%84%80%E1%85%AF%E1%86%AB%20bff59c586dd04635983f375352064b37/Untitled%208.png)
            
    - 단위 테스트(Unit Test)
        - 단위 테스트는 코딩 직후 소프트웨어 설계의 최소 단위인 모듈이나 컴포넌트에 초점을 맞춰 테스트하는 것
        - 인터페이스, 외부적 I/O, 자료 구조, 독립적 기초 경로, 오류 처리 경로, 경계 조건 등을 검사
        - 사용자의 요구사항을 기반으로 한 기능성 테스트를 최우선으로 수행
        - 구조 기반 테스트와 명세 기반 테스트로 나뉘지만 주로 구조 기반 테스트를 시행
    - 통합 테스트(Integration Test)
        - 통합 테스트는 단위 테스트가 완료된 모듈들을 결합하여 하나의 시스템으로 완성시키는 과정에서의 테스트를 의미
        - 모듈 간 또는 통합된 컴포넌트 간의 상호 작용 오류를 검사
    - 시스템 테스트(System Test)
        - 시스템 테스트는 개발된 소프트웨어가 해당 컴퓨터 시스템에서 완벽하게 수행되는가를 점검하는 테스트
        - 기능적 요구사항과 비기능적 요구사항으로 구분하여 각각을 만족하는지 테스트
    - 인수 테스트(Acceptance Test)
        - 인수 테스트는 개발한 소프트웨어가 사용자의 요구사항을 충족하는지에 중점을 두고 테스트하는 방법
        - 인수 테스트는 개발한 소프트웨어를 사용자가 직접 테스트
            
            
            | 테스트 종류 | 설명 |
            | --- | --- |
            | 사용자 인수 테스트 | - 사용자가 시스템 사용의 적절성 여부를 확인 |
            | 운영상의 인수 테스트 | - 시스템 관리자가 시스템 인수 시 수행하는 테스트 기법
            
            - 백업/복원 시스템, 재난 복구, 사용자 관리, 정기 점검 등을 확인 |
            | 계약 인수 테스트 | - 계약상의 인수/검수 조건을 준수하는지 여부를 확인 |
            | 규정 인수 테스트 | - 소프트웨어가 정부 지침, 법규, 규정 등 규정에 맞게 개발되었는지 확인 |
            | 알파 테스트 | - 개발자의 장소에서 사용자가 개발자 앞에서 행하는 테스트 기법
            
            - 테스트는 통제된 환경에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함께 확인하면서 기록 |
            | 베타 테스트 | - 선정된 최종 사용자가 여러 명의 사용자 앞에서 행하는 테스트 기법
            
            - 실업무를 가지고 사용자가 직접 테스트 |
- 통합 테스트 A
    - 통합 테스트(Integration Test)
        - 통합 테스트는 단위 테스트가 끝난 모듈을 통합하는 과정에서 발생하는 오류 및 결함을 찾는 테스트 기법
        - 종류
            
            
            | 비점진적 통합 방식 | - 단계적으로 통합하는 절차 없이 모든 모듈이 미리 결합되어 있는 프로그램 전체를 테스트하는 방법 
            
            - 종류 : 빅뱅 통합 테스트 방식 |
            | --- | --- |
            | 점진적 통합 방식 | - 모듈 단위로 단계적으로 통합하면서 테스트하는 방법 
            
            - 종류 : 하향식 통합 테스트, 상향식 통합 테스트, 혼합식 통합 테스트  |
    - 하향식 통합 테스트(Top Down Integration Test)
        - 하향식 통합 테스트는 프로그램의 상위 모듈에서 하위 모듈 방향으로 통합하면서 테스트하는 기법
        - 깊이 우선 통합법이나 넓이 우선 통합법을 사용
        - 하향식 통합 테스트 절차
            1. 주요 제어 모듈은 작성된 프로그램을 사용하고, 주요 제어 모듈의 종속 모듈들은 스텁(Stub)으로 대체
            2. 깊이 우선 또는 넓이 우선 등의 통합 방식에 따라 하위 모듈인 스텁들이 한 번에 하나씩 실제 모듈로 교체
            3. 모듈이 통합될 때마다 테스트를 실시
            4. 새로운 오류가 발생하지 않음을 보증하기 위해 회귀 테스트를 실시 
    - 상향식 통합 테스트(Bottom Up Integration Test)
        - 상향식 통합 테스트는 프로그램의 하위 모듈에서 상위 모듈 방향으로 통합하면서 테스트하는 기법
        - 상향식 통합 테스트 절차
            1. 하위 모듈들을 클러스터(Cluster)로 결합
            2. 상위 모듈에서 데이터의 입,출력을 확인하기 위해 더미 모듈인 드라이버(Driver)를 작성
            3. 통합된 클러스터 단위로 테스트
            4. 테스트가 완료되면 클러스터는 프로그램 구조의 상위로 이동하여 결합하고 드라이버는 실제 모듈로 대체 
    - 혼합식 통합 테스트
        - 혼합식 통합 테스트는 하위 수준에서는 상향식 통합, 상위 수준에서는 하향식 통합을 사용하여 최적의 테스트를 지원하는 방식
        - 샌드위치(Sandwich)식 통합 테스트 방법이라고도 함
    - 회귀 테스팅(Regression Testing)
        - 회귀 테스트는 통합 테스트로 인해 변경된 모듈이나 컴포넌트에 새로운 오류가 있는지 확인하는 테스트
        - 이미 테스트된 프로그램의 테스팅을 반복하는 것
        - 회귀 테스트는 수정된 모듈이나 컴포넌트가 다른 부분에 영향을 미치는지, 오류가 생기지 않았는지 테스트하여 새로운 오류가 발생하지 않음을 보증하기 위해 반복 테스트
- 테스트 케이스 / 테스트 시나리오 / 테스트 오라클 B
    - 테스트 케이스(Test Case)
        - 테스트 케이스는 구현된 소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위해 설계된 입력 값, 실행 조건, 기대 결과 등으로 구성된 테스트 항목에 대한 명세서
        - 테스트 케이스를 미리 설계하면 테스트 오류 방지, 테스트 수행에 필요한 인력, 시간 등의 자원 낭비를 줄일 수 있다
    - 테스트 시나리오(Test Scenario)
        - 테스트 시나리오는 테스트 케이스를 적용하는 순서에 따라 여러 개의 테스트 케이스를 묶은 집합
        - 테스트 케이스를 적용하는 구체적인 절차를 명세
        - 테스트 순서에 대한 구체적인 절차, 사전 조건, 입력 데이터 등이 설정되어 있다
    - 테스트 오라클(Test Oracle)
        - 테스트 오라클은 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참값을 대입하여 비교하는 기법 및 호라동
        - 결과를 판단하기 위해 테스트 케이스에 대한 예상 결과를 계산하거나 확인
        - 테스트 오라클의 특징
            
            
            | 제한된 검증 | 테스트 오라클을 모든 테스트 케이스에 적용할 수 없음 |
            | --- | --- |
            | 수학적 기법 | 테스트 오라클의 값을 수학적 기법을 이용하여 구할 수 있음 |
            | 자동화 가능 | 테스트 대상 프로그램의 실행, 결과 비교, 커버리지 측정 등을 자동화 할 수 있음  |
    - 테스트 오라클의 종류
        
        
        | 참(True) 오라클 | - 모든 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하는 오라클 
        
        - 발생된 모든 오류를 검출할 수 있음 |
        | --- | --- |
        | 샘플링(Sampling)
        오라클 | - 특정한 몇몇 테스트 케이스의 입력 값들에 대해서만 기대하는 결과를 제공하는 오라클로 전수 테스트가 불가능한 경우 사용 |
        | 추정(Heuristic) 
        오라클 | - 특정 테스트 케이스의 입력 값에 대해 기대하는 결과를 제공하고, 나머지 입력 값들에 대해서는 추정으로 처리하는 오라클 |
        | 일관성 검사
        (Consistent) 오라클 | - 애플리케이션에 변경이 있을 때, 테스트 케이스의 수행 전과 후의 결과 값이 동일한지를 확인하는 오라클  |
- 테스트 자동화 도구 C
    - 테스트 자동화
        - 테스트 자동화는 사람이 반복적으로 수행하던 테스트 절차를 스크립트 형태로 구현하는 자동화 도구를 적용함으로써 쉽고 효율적으로 테스트를 수행할 수 있도록 한 것
        - 테스트 유형에 따른 테스트 자동화 도구의 종류
            - 정적 분석 도구
            - 테스트 실행 도구
            - 성능 테스트 도구
            - 테스트 통제 도구
    - 정적 분석 도구(Static Analysis Tools)
        - 정적 분석 도구는 프로그램을 실행하지 않고 분석하는 도구
        - 소스 코드에 대한 코딩 표준, 코딩 스타일, 코드 복잡도 및 남은 결함 등을 발견하기 위해 사용
    - 테스트 실행 도구(Test Execution Tools)
        - 테스트 실행 도구는 스크립트 언어를 사용하여 테스트를 실행하는 도구
        - 테스트 데이터와 테스트 수행 방법 등이 포함된 스크립트를 작성한 후 실행
        - 데이터 주도 접근 방식 : 스프레드시트에 테스트 데이터를 저장하고, 이를 읽어 실행하는 방식
        - 키워드 주도 접근 방식 : 스프레드시트에 테스트를 수행할 동작을 나타내는 키워드와 테스트 데이터를 저장하여 실행하는 방식
    - 성능 테스트 도구(Performance Test Tools)
        - 성능 테스트 도구는 애플리케이션의 처리량, 응답 시간, 결과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구
    - 테스트 통제 도구(Test Control Tools)
        - 성능 테스트 도구는 애플리케이션의 처리량, 응답 시간, 경과 시간, 자원 사용률 등을 인위적으로 적용한 가상의 사용자를 만들어 테스트를 수행함으로써 성능의 목표 달성 여부를 확인하는 도구
        - 종류 : 형상 관리 도구, 결함 추적/관리 도구 등
    - 테스트 하네스 도구(Test Harness Tools)
        - 테스트 하네스 도구는 테스트가 실행될 환경을 시뮬레이션 하여 컴포넌트 및 모듈이 정상적으로 테스트되도록 하는 도구
        - 테스트 하네스(Test Harness) : 애플리케이션의 컴포넌트 및 모듈을 테스트하는 환경의 일부분으로, 테스트를 지원하기 위해 생성된 코드와 데이터를 의미
    - 테스트 하네스의 구성 요소
        
        
        | 테스트 드라이버
        (Test Driver) | 테스트 대상의 하위 모듈을 호출하고, 파라미터를 전달하고, 모듈 테스트 수행 후의 결과를 도출하는 도구 |
        | --- | --- |
        | 테스트 스텁
        (Test Stub) | 제어 모듈이 호출하는 타 모듈의 기능을 단순히 수행하는 도구로, 일시적으로 필요한 조건만을 가지고 있는 테스트용 모듈  |
        | 테스트 슈트
        (Test Suites) | 테스트 대상 컴포넌트나 모듈, 시스템에 사용되는 테스트 케이스의 집합 |
        | 테스트 케이스
        (Test Case) | 사용자의 요구사항을 정확하게 준수했는지 확인하기 위한 입력값, 실행 조건, 기대 결과 등으로 만들어진 테스트 항목의 명세서 |
        | 테스트 스크립트
        (Test Script) | 자동화된 테스트 실행 절차에 대한 명세서 |
        | 목 오브젝트
        (Mock Object) | 사전에 사용자의 행위를 조건부로 입력해 두면, 그 상황에 맞는 예정된 행위를 수행하는 객체  |
    - 테스트 수행 단계별 자동화 도구
        
        
        | 테스트 단계 | 자동화 도구 | 설명 |
        | --- | --- | --- |
        | 테스트 계획 | 요구사항 관리 | 사용자의 요구사항 정의 및 변경 사항 등을 관리하는 도구 |
        | 테스트 분석/설계 | 테스트 케이스 생성 | 테스트 기법에 따른 테스트 데이터 및 테스트 케이스 작성을 지원하는 도구 |
        | 테스트 수행 | 테스트 자동화 | 테스트의 자동화를 도와주는 도구로 테스트의 효율성을 높임 |
        | 테스트 수행 | 정적 분석 | 코딩 표준, 런타임 오류 등을 검증하는 도구 |
        | 테스트 수행 | 동적 분석 | 대상 시스템의 시뮬레이션을 통해 오류를 검출하는 도구 |
        | 테스트 수행 | 성능 테스트 | 가상의 사용자를 생성하여 시스템의 처리 능력을 측정하는 도구 |
        | 테스트 수행 | 모니터링 | CPU, Memory 등과 같은 시스템 자원의 상태 확인 및 분석을 지원하는 도구 |
        | 테스트 관리 | 커버리지 분석 | 테스트 완료 후 테스트의 충분성 여부 검증을 지원하는 도구 |
        | 테스트 관리 | 형상 관리 | 테스트 수행에 필요한 다양한 도구 및 데이터를 관리하는 도구 |
        | 테스트 관리 | 결함 추적/관리 | 테스트 시 발생한 결함 추적 및 관리 활동을 지원하는 도구 |
- 결함 관리 C
    - 결함(Fault)
        - 결함은 오류 발생, 작동 실패 등과 같이 소프트웨어가 개발자가 설계한 것과 다르게 동작하거나 다른 결과가 발생하는 것을 의미
        - 사용자가 예상한 결과와 실행 결과 같의 차이나 업무 내용과의 불일치 등으로 인해 변경이 필요한 부분도 모두 결함에 해당
    - 결함 관리 프로세스
        1. 결함 관리 계획 : 전체 프로세스에 대한 결함 관리 일정, 인력, 업무 프로세스 등을 확보하여 계획을 수립
        2. 결함 기록 : 테스터는 발견된 결함을 결함 관리 DB에 등록
        3. 결함 검토 : 테스터, 프로그램 리더, 품질 관리(QA) 담당자 등은 등록된 결함을 검토하고 결함을 수정할 개발자에게 전달
        4. 결함 수정 : 개발자는 전달받은 결함을 수정
        5. 결함 재확인 : 테스터는 개발자가 수정한 내용을 확인하고 다시 테스트를 수행
        6. 결함 상태 추적 및 모니터링 활동 : 결함 관리 DB를 이용하여 프로젝트별 결함 유형, 발생률 등을 한눈에 볼 수 있는 대시보드 또는 게시판 형태의 서비스를 제공
        7. 최종 결함 분석 및 보고서 작성 : 발견된 결함에 대한 정보와 이해관계자들의 의견이 반영된 보고서를 작성하고 결함 관리 종료 
    - 결함 상태 추적
        - 테스트에서 발견된 결함은 지속적으로 상태 변화를 추적하고 관리해야 한다
        - 발견된 결함에 대해 결함 관리 측정 지표의 속성 값들을 분석하여 향후 결함이 발견될 모듈 또는 컴포넌트를 추정할 수 있다
        - 결함 관리 측정 지표
            
            
            | 결함 분포 | 모듈 또는 컴포넌트의 특정 속성에 해당하는 결함 수 측정 |
            | --- | --- |
            | 결함 추세 | 테스트 진행 시간에 따른 결함 수의 추이 분석 |
            | 결함 에이징 | 특정 결함 상태로 지속되는 시간 측정 |
    - 결함 추적 순서
        1. 결함 등록(Open) : 테스터와 품질 관리(QA) 담당자에 의해 발견된 결함이 등록된 상태
        2. 결함 검토(Reviewed) : 등록된 결함을 테스터, 품질 관리(QA) 담당자, 프로그램 리더, 담당 모듈 개발자에 의해 검토된 상태
        3. 결함 할당(Assigned) : 결함을 수정하기 위해 개발자와 문제 해결 담당자에게 결함이 할당된 상태
        4. 결함 수정(Resolved) : 개발자가 결함 수정을 완료한 상태
        5. 결함 조치 보류(Deferred) : 결함의 수정이 불가능해 연기된 상태로, 우선순위, 일정 등에 따라 재오픈을 준비중인 상태
        6. 결함 종료(Closed) : 결함이 해결되어 테스터와 품질 관리(QA) 담당자가 종료를 승인한 상태
        7. 결함 해제(Clarified) : 테스터, 프로그램 리더, 품질 관리(QA) 담당자가 종료 승인한 결함을 검토하여 결함이 아니라고 판명한 상태
    - 결함 분류
        
        
        | 시스템 결함 | 애플리케이션 환경이나 데이터베이스 처리에서 발생된 결함 |
        | --- | --- |
        | 기능 결함 | 애플리케이션의 기획, 설계, 업무 시나리오 등의 단계에서 유입된 결함 |
        | GUI 결함 | 사용자 화면 설계에서 발생된 결함 |
        | 문서 결함 | 기획자, 사용자, 개발자 간의 의사소통 및 기록이 원활하지 않아 발생된 결함 |
    - 결함 심각도
        - 결함 심각도는 애플리케이션에 발생한 결함이 전체 시스템에 미치는 치명도를 나타내는 척도
        - High, Medium, Low 또는 치명적(Critical), 주요(Major), 보통(Normal), 경미(Minor), 단순(Simple)등으로 분류
    - 결함 우선순위
        - 결함 우선순위는 발견된 결함 처리에 신속성을 나타내는 척도
        - 결함의 중요도와 심각도에 따라 설정되고 수정 여부가 결정
        - 결정적(Critical), 높음(High), 보통(Medium), 낮음(Low) 또는 즉시 해결, 주의 요망, 대기, 개선 권고 등으로 분류
    - 결함 관리 도구
        
        
        | Mantis | - 결함 및 이슈 관리 도구로, 소프트웨어 설계 시 단위별 작업 내용을 기록할 수 있어 결함 추적도 가능한 도구 |
        | --- | --- |
        | Trac | - 결함 추적은 물론 결함을 통합하여 관리할 수 있는 도구 |
        | Redmine | - 프로젝트 관리 및 결함 추적이 가능한 도구 |
        | Bugzilla | - 결함 신고, 확인, 처리 등 결함을 지속적으로 관리할 수 있는 도구
        
        - 결함의 심각도와 우선 순위를 지정할 수도 있다. |
- 애플리케이션 성능 분석 B
    - 애플리케이션 성능
        - 애플리케이션 성능이란 최소한의 자원을 사용하여 최대한 많은 기능을 신속하게 처리하는 정도
        - 애플리케이션 성능 측정 지표
            
            
            | 처리량(Throughput) | 일정 시간 내에 애플리케이션이 처리하는 일의 양 |
            | --- | --- |
            | 응답 시간(Response Time) | 애플리케이션에 요청을 전달한 시간부터 응답이 도착할 때까지 걸린 시간 |
            | 경과 시간(Turn Around Time) | 애플리케이션에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 |
            | 자원 사용률(Resource Usage) | 애플리케이션이 의뢰한 작업을 처리하는 동안의 CPU 사용량, 메모리 사용량, 네트워크 사용량 등 자원 사용률 |
    - 성능 테스트 도구
        - 성능 테스트 도구는 애플리케이션의 성능을 테스트하기 위해 애플리케이션에 부하나 스트레스를 가하면서 애플리케이션의 성능 측정 지표를 점검하는 도구
        - 종류
            
            
            | 도구명 | 도구 설명 | 지원 환경 |
            | --- | --- | --- |
            | JMeter | - HTTP, FTP 등 다양한 프로토콜을 지원하는 부하 테스트 도구 | Cross-Platform |
            | LoadUI | - 서버 모니터링, Drag&Drop 등 사용자의 편리성이 강화된 부하 테스트 도구
            
            - HTTP, JDBC 등 다양한 프로토콜 지원 | Cross-Platform |
            | OpenSTA | - HTTP, HTTPS 프로토콜에 대한 부하 테스트 및 생산품 모니터링 도구 | Windows |
    - 시스템 모니터링(Monitoring) 도구
        - 시스템 모니터링 도구는 애플리케이션이 실행되었을 때 시스템 자원의 사용량을 확인하고 분석하는 도구
        - 종류
            
            
            | 도구명 | 도구 설명 | 지원 환경 |
            | --- | --- | --- |
            | Scouter | - 단일 뷰 통합/실시간 모니터링, 튜닝에 최적화된 인프라 통합 모니터링 도구
            
            - 애플리케이션의 성능을 모니터링/통제하는 도구 | Cross-Platform |
            | Zabbix | - 웹기반 서버, 서비스, 애플리케이션 등의 모니터링 도구 | Cross-Platform |
- 복잡도 C
    - 복잡도(Complexity)
        - 복잡도는 시스템이나 시스템 구성 요소 또는 소프트웨어의 복잡한 정도를 나타내는 말
        - 시스템 또는 소프트웨어를 어느 정도의 수준까지 테스트해야 하는지 또는 개발하는 데 어느 정도의 자원이 소요되는지 예측하는 데 사용
    - 시간 복잡도
        - 시간 복잡도는 알고리즘을 수행하기 위해 프로세스가 수행하는 연산 횟수를 수치화한 것
        - 시간 복잡도가 낮을수록 알고리즘의 실행시간이 짧고, 높을수록 실행시간이 길어짐
        - 점근 표기법의 종류
            
            
            | 빅오 표기법
            (Big-O Natation) | - 알고리즘의 실행시간이 최악일 때를 표기하는 방법이다.
            
            - 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 많을 수 없다. |
            | --- | --- |
            | 세타 표기법
            (Big-θ Notation) | - 알고리즘의 실행시간이 평균일 때를 표기하는 방법이다.
            
            - 입력값에 대해 알고리즘을 수행했을 때 명령어 실행 횟수의 평균적인 수치를 표기한다. |
            | 오메가 표기법
            (Big-Ω Notation) | - 알고리즘의 실행시간이 최상일 때를 표기하는 방법이다.
            
            - 입력값에 대해 알고리즘을 수행했을 때 명령어의 실행 횟수는 어떠한 경우에도 표기 수치보다 적을 수 없다. |
    - 빅오 표기법으로 표현한 최악의 알고리즘 시간 복잡도
        
        
        | O(1) | - 입력값(n)에 관계 없이 일정하게 문제 해결에 하나의 단계만을 거친다.
        
        - 스택의 Push, Pop |
        | --- | --- |
        | O(log₂n) | - 문제 해결에 필요한 단계가 입력값(n) 또는 조건에 의해 감소한다.
        
        - Binary Tree, Binary Search |
        | O(n) | - 문제 해결에 필요한 단계가 입력값(n)과 1:1의 관계를 가진다.
        
        - for문 |
        | O(nlog₂n) | -문제 해결에 필요한 단계가 n(log₂n)번만큼 수행된다.
        
        - Heap Sort, 2-Way Merge Sort |
        | O(n²) | - 문제 해결에 필요한 단계가 입력값(n)의 제곱만큼 수행된다.
        
        - Insertion Sort, Shell Sort, Selection Sort, Bubble Sort, Quick Sort |
        | O(2²) | - 문제 해결에 필요한 단계가 2의 입력값(n) 제곱만큼 수행된다.
        
        - Fibonacci Sequence |
    - 순환 복잡도(Cyclomatic Complexity)
        - 순환 복잡도는 한 프로그램의 논리적인 복잡도를 측정하기 위한 소프트웨어의 척도
        - 맥케이브 순환도(McCabe’s Cyclomatic) 또는 맥케이브 복잡도 매트릭스(McCabe’s Complexity Matrics)라고도 한다
        - 제어 흐름도 이론에 기초를 둔다
        - 제어 흐름도 G에서 순환 복잡도 V(G)는 아래와 같은 방법으로 계산한다
            1. 순환 복잡도는 제어 흐름도의 영역 수와 일치하므로 영역 수를 계산
            2. V(G) = E - N + 2 
                - E는 화살표 수, N은 노드의 수
- 애플리케이션 성능 개선 B
    - 소스 코드 최적화
        - 소스 코드 최적화는 나쁜 코드(Bad Coed)를 배제하고, 클린 코드(Clean Code)로 작성하는 것
        - 클린 코드 : 누구나 쉽게 이해하고 수정 및 추가할 수 있는 단순, 명료한 코드. 즉, 잘 작성된 코드
        - 나쁜 코드
            - 프로그램의 로직이 복잡하고 이해하기 어려운 코드
                - 스파게티 코드 : 코드의 로직이 서로 복잡하게 얽혀 있는 코드
                - 외계인 코드 : 아주 오래되거나 참고문서 또는 개발자가 없어 유지보수 작업이 어려운 코드
    - 클린 코드 작성 원칙
        
        
        | 가독성 | - 누구든지 코드를 쉽게 읽을 수 있도록 작성한다.
        
        - 코드 작성 시 이해하기 쉬운 용어를 사용하거나 들여쓰기 기능 등을 사용한다. |
        | --- | --- |
        | 단순성 | - 코드를 간단하게 작성한다.
        
        - 한 번에 한 가지를 처리하도록 코드를 작성하고 클래스/메소드/함수 등을 최소 단위로 분리한다. |
        | 의존성 배제 | - 코드가 다른 모듈에 미치는 영향을 최소화한다.
        
        - 코드 변경 시 다른 부분에 영향이 없도록 작성한다. |
        | 중복성 최소화 | - 코드의 중복을 최소화한다.
        
        - 중복된 코드는 삭제하고 공통된 코드를 사용한다. |
        | 추상화 | - 상위 클래스/메소드/함수에서는 간략하게 애플리케이션의 특성을 나타내고, 상세 내용은 하위 클래스/메소드/함수에서 구현한다. |
    - 소스 코드 최적화 유형
        - 클래스 분할 배치 : 하나의 클래스는 하나의 역할만 수행하도록 응집도를 높이고, 크기를 작게 작성
        - 느슨한 결합(Loosely Coupled) : 인터페이스 클래스를 이용하여 추상화된 자료 구조와 메소드를 구현함으로써 클래스 간의 의존성을 최소화
    - 소스 코드 품질 분석 도구
        - 소스 코드 품질 분석 도구는 소스 코드의 코딩 스타일, 코드에 설정된 코딩 표준, 코드의 복잡도, 코드에 존재하는 메모리 누수 현상, 스레드 결함 등을 발견하기 위해 사용하는 분석 도구
        - 정적 분석 도구와 동적 분석 도구로 나뉨
            
            
            | 정적 분석 도구
            (Static Analysis) | - 작성한 소스 코드를 실행하지 않고 코딩 표준이나 코딩 스타일, 결함 등을 확인하는 코드 분석 도구 
            
             - 종류 : pmd, cppcheck, SonarQube, checkstyle, ccm, cobertura 등 |
            | --- | --- |
            | 동적 분석 도구
            (Dynamic Analysis) | - 작성한 소스 코드를 실행하여 코드에 존재하는 메모리 누수, 스레드 결함 등을 분석하는 도구 
            
            - 종류 : Avalanche, Valgrind 등 |
    - 소스 코드 품질 분석 도구의 종류
        
        
        | 도구 | 설명 | 지원 환경 |
        | --- | --- | --- |
        | pmd | - 소스 코드에 대한 미사용 변수, 최적화되지 않은 코드 등 결함을 유발할 수 있는 코드를 검사한다. | Linux, Windows |
        | cppcheck | - C/C++ 코드에 대한 메모리 누수, 오버플로우 등 분석 | Windows |
        | SonarQube | - 중복 코드, 복잡도, 코딩 설계 등을 분석하는 소스 분석 통합 플랫폼 | Cross-Platform |
        | checkstyle | - 자바 코드에 대해 소스 코드 표준을 따르고 있는지 검사한다.
        
        - 다양한 개발 도구에 통합하여 사용 가능 | Cross-Platform |
        | ccm | - 다양한 언어의 코드 복잡도를 분석한다. | Cross-Platform |
        | cobertura | - 자바 언어의 소스 코드 복잡도 분석 및 테스트 커버리지를 측정한다. | Cross-Platform |
        | Avalanche | - Valgrind 프레임워크 및 STP 기반으로 구현된다.
        
        - 프로그램에 대한 결함 및 취약점 등을 분석한다. | Linux, Windows |
        | Valgrind | - 프로그램 내에 존재하는 메모리 및 쓰레드 결함 등을 분석한다. | Cross-Platform |