# 시나공 실기 2권

# SQL 응용

- SQL - DDL A
    - DDL(Data Define Language, 데이터 정의어)
        - DDL은 DB 구조, 데이터 형식, 접근 방식 등 DB를 구축하거나 수정할 목적으로 수용하는 언어
        - 번역한 결과가 데이터 사전(Data Dictionary)라는 특별한 파일에 여러 개의 테이블로 저장된다.
        - DDL의 3가지 유형
            
            
            | 명령어 | 기능 |
            | --- | --- |
            | CREATE | SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 정의 |
            | ALTER | TABLE에 대한 정의를 변경 |
            | DROP | SCHEMA, DOMAIN, TABLE, VIEW, INDEX를 삭제 |
    - CREATE SCHEMA
        - 스키마를 정의하는 명령문
    - CREATE DOMAIN
        - 도메인을 정의하는 명령문
    - CREATE TABLE
        - 테이블을 정의하는 명령문
    - CREATE VIEW
        - 뷰를 정의하는 명령문
    - CREATE INDEX
        - 인덱스를 정의하는 명령문
    - ALTER TABLE
        - 테이블에 대한 정의를 변경하는 명령문
    - DROP
        - 스키마, 도메인, 기본 테이블, 뷰 테이블, 인덱스, 제약 조건 등을 제거하는 명령문
- SQL - DCL A
    - DCL(Data Control Language, 데이터 제어어)
        - DCL은 데이터의 보안, 무결성, 회복, 병행 제어 등을 정의하는 데 사용하는 언어
        - DCL은 DBA가 데이터 관리를 목적으로 사용
        - DCL의 종류
            
            
            | 명령어 | 기능 |
            | --- | --- |
            | COMMIT | 명령에 의해 수행된 결과를 실제 물리적 디스크로 저장하고, 데이터베이스 조작 작업이 정상적으로 완료되었음을 관리자에게 알려준다  |
            | ROLLBACK | 데이터베이스 조작 작업이 비정상적으로 종료되었을 때 원래의 상태로 복구 |
            | GRANT | 데이터베이스 사용자에게 사용 권한 부여 |
            | REVOKE | 데이터베이스 사용자의 사용 권한 취소 |
    - GRANT / REVOKE
        - 데이터베이스 관리자가 데이터베이스 사용자에게 권한을 부여하거나 취소하기 위한 명령어
            - GRANT : 권한 부여
            - REVOKE : 권한 취소
    - COMMIT
        - COMMIT은 Transction 처리가 정상적으로 완료된 후 Transcation이 수행한 내용을 데이터베이스에 반영하는 명령
        - COMMIT 명령을 실행하지 않아도 DML 문이 성공적으로 완료되면 자동으로 COMMIT 되고, DML이 실패하면 자동으로 ROLLBACK이 되도록 Auto Commit 기능 설정 가능
    - ROLLBACK
        - ROLLBACK은 변경되었으나 아직 COMMIT 되지 않은 모든 내용들을 취소하고 데이터베이스를 이전 상태로 되돌리는 명령어
        - Transcation 전체가 성공적으로 끝나지 못하면 일부 변경된 내용만 데이터베이스에 반영하는 비일관성(Inconsistency) 상태가 될 수 있기에 일부분만 완료된 Transcation은 ROLLBACK 되어야 함
    - SAVEPOINT
        - SAVEPOINT는 Transcation 내에 ROLLBACK할 위치인 저장점을 지정하는 명령어
        - 저장점을 지정할 때는 이름을 부여
        - ROLLBACK 할 때 지정된 저장점까지의 Transcation 처리 내용이 모두 취소
- SQL - DML A
    - DML(Data Manipulation Language, 데이터 조작어)
        - DML은 데이터베이스 사용자가 저장된 데이터를 실질적으로 관리하는데 사용되는 언어
        - DML은 데이터베이스 사용자와 데이터베이스 관리 시스템 간의 인터페이스를 제공
        - DML의 유형
            
            
            | 명령문 | 기능 |
            | --- | --- |
            | SELECT | 테이블에서 튜플 검색 |
            | INSERT | 테이블에 새로운 튜플 삽입 |
            | DELETE | 테이블에서 튜플 삭제 |
            | UPDATE | 테이블에서 튜플 내용 갱신 |
    - 삽입문(INSERT INTO ~ )
        - 삽입문은 기본 테이블에 새로운 튜플을 삽입할 때 사용
            - 대응하는 속성과 데이터는 개수와 데이터 유형이 일치해야 함
            - 기본 테이블의 모든 속성을 사용할 때는 속성명 생략 가능
            - SELECT문을 사용하여 다른 테이블의 검색 결과를 삽입 가능
    - 삭제문(DELETE FROM ~ )
        - 삭제문은 기본 테이블에 있는 튜플들 중에서 특정 튜플(행)을 삭제할 때 사용
        - 모든 레코드를 삭제할 때는 WHERE 절 생략
        - 모든 레코드를 삭제하더라도 테이블 구조는 남아 있기에 디스크에서 테이블을 완전히 제거하는 DROP과는 다름
    - 갱신문(UPDATE ~ SET ~)
        - 갱신문은 기본 테이블에 있는 튜플들 중에서 특정 튜플의 내용을 변경할 때 사용
- DML - SELECT - 1 A
    - 일반 형식
        
        ```sql
        SELECT [PREDICATE] [테이블명.]속성명[AS 별칭][, [테이블명.]속성명, ---]
        [, 그룹함수(속성명) [AS 별칭]]
        [, Window함수 OVER (PARTITION BY 속성명1, 속성명2 ---
                            ORDER BY 속성명3, 속성명4, ---)]
        FROM 테이블명[, 테이블명, ---]
        [WHERE 조건]
        [GROUP BY 속성명, 속성명, ---]
        [HAVING 조건]
        [ORDER BY 속성명 [ASC | DESC]];
        ```
        
        - SELECT절
            - PREDICATE : 불러올 튜플 수를 제한할 명령어를 기술한다.
                - ALL : 모든 튜플을 검색할 때 지정하는 것으로, 주로 생략한다.
                - DISTINCT : 중복된 튜플이 있으면 그 중 첫 번째 한 개만 검색한다.
                - DISTINCTROW : 중복된 튜플을 제거하고 한 개만 검색하지만 선택된 속성의 값이 아닌, 튜플 전체를 대상으로 한다.
            - 속성명 : 검색하여 불러올 속성(열) 또는 속성을 이용한 수식을 지정한다.
                - 기본 테이블을 구성하는 모든 속성을 지정할 때는 ‘*’를 기술한다.
                - 두 개 이상의 테이블을 대상으로 검색할 때는 ‘테이블명.속성명’으로 표현 한다.
            - AS : 속성 및 연산의 이름을 다른 제목으로 표시하기 위해 사용된다.
        - FROM 절 : 질의에 의해 검색될 데이터들을 포함하는 테이블명을 기술한다.
        - WHERE절 : 검색할 조건을 기술한다.
        - ORDER BY절 : 특정 속성을 기준으로 정렬하여 검색할 때 사용한다.
            - 속성명 : 정렬의 기준이 되는 속성명을 기술한다.
            - [ASC | DESC] : 정렬 방식으로서 ‘ASC’는 오름차순, ‘DESC’는 내림차순이다. 생략시 ASC로 지정된다.
    - 조건 연산자
        - 비교 연산자
            
            
            | 연산자 | = | <> | > | < | > = | < = |
            | --- | --- | --- | --- | --- | --- | --- |
            | 의미 | 같다 | 같지 않다 | 크다 | 작다 | 크거나 같다 | 작거나 같다 |
        - 논리 연산자 : NOT, AND, OR
        - LIKE 연산자 : 대표 문자를 이용해 지정된 속성의 값이 문자 패턴과 일치하는 튜플을 검색하기 위해 사용
            
            
            | 대표 문자 | % | - | # |
            | --- | --- | --- | --- |
            | 의미 | 모든 문자를 대표함 | 문자 하나를 대표함 | 숫자 하나를 대표함 |
    - 기본 검색
        - SELECT 절에 원하는 속성을 지정하여 검색
            
            ```sql
            SELECT * FROM 사원;
            SELECT 사원.* FROM 사원;
            SELECT 이름, 부서, 생일, 주소, 기본급 FROM 사원;
            SELECT 사원.이름, 사원.부서, 사원.생일, 사원.주소, 사원.기본급 FROM 시원;
            
            SELECT DISTINCT 주소 FROM 사원;
            SELECT 부서 + '부서의' AS 부서2, 이름 + '의 월금' AS 이름2, 기본급 + 10 AS 기본급2 FROM 사원; 
            ```
            
    - 조건 지정 검색
        - WHERE절에 조건을 지정하여 조건에 만족하는 튜플만 검색
            
            ```sql
            SELECT * 
              FROM 사원
             WHERE 부서 = '기획';
            
            SELECT * 
              FROM 사원
             WHERE 부서 = '기획' AND 주소 = '대흥동';
            
            SELECT *
              FROM 사원
             WHERE 부서 = '기획' OR 부서 = '인터넷';
            
            SELECT * 
              FROM 사원
             WHERE 이름 LIKE "김%";
            
            SELECT *
              FROM 사원
             WHERE 생일 BETWEEN #01/01/69# AND #12/31/73$;
            
            SELECT *
              FROM 사원
             WHERE 주소 IS NULL;
            
            ```
            
    - 정렬 검색
        - ORDER BY 절에 특정 속성을 지정하여 지정된 속성으로 자료를 정렬하여 검색
            
            ```sql
            SELECT TOP 2 *
              FROM 사원
             ORDER BY 주소 DESC;
            
            SELECT *
              FROM 사원
             ORDER BY 부서 ASC, 이름 DESC;
            ```
            
    - 하위 질의
        - 하위 질의는 조건절에 주어진 질의를 먼저 수행하여 그 검색 결과를 조건절의 피연산자로 사용
            
            ```sql
            SELECT 이름, 주소
              FROM 사원
             WHERE 이름 = (SELECT 이름 FROM 여가활동 WHERE 취미 = '나이트댄스');
            
            SELECT *
              FROM 사원
             WHERE 이름 NOT IN (SELECT 이름 FROM 여가활동);
            
            SELECT 부서
              FROM 사원
             WHERE EXISTS (SELECT 이름 FROM 여가활동 WHERE 여가활동.이름 = 사원.이름);
            ```
            
    - 복수 테이블 검색
        - 여러 테이블을 대상으로 검색을 수행
        
        ```sql
        SELECT 사원.이름, 사원.부서, 여가활동.취미, 여가활동.경력
          FROM 사원, 여가활동
         WHERE 여가활동.경력 >= 10 AND 사원.이름 = 여가활동.이름;
        ```
        
- DML - SELECT - 2 A
    - 일반 형식
        
        ```sql
        SELECT [PREDICATE] [테이블명.]속성명 [AS 별칭][, [테이블명.]속성명, ---]
        [, 그룹함수(속성명) [AS 별칭]]
        [, WINDOW함수 OVER (PARTITION BY 속성명1, 속성명2, ---
                      ORDER BY 속성명3, 속성명4, ---)[AS 별칭]]
          FROM 테이블명[, 테이블명, ---]
         [WHERE 조건]
         [GROUP BY 속성명, 속성명, ---]
         [HAVING 조건]
         [ORDER BY 속성명 [ASC | DESC]];
        ```
        
        - 그룹함수 : GROUP BY절에 지정된 그룹별로 속성의 값을 집계할 함수를 기술한다.
        - WINDOW 함수 : GROUP BY 절을 이용하지 않고 속성의 값을 집계할 함수를 기술한다.
            - PARTITION BY : WINDOW 함수가 적용될 범위로 사용할 속성을 지정한다.
            - ORDER BY : PARTITION 안에서 정렬 기준으로 사용할 속성을 지정한다.
        - GROUP BY절 : 특정 속성을 기준으로 그룹화하여 검색할 때 사용한다. 일반적으로 GROUP BY절은 그룹 함수와 함께 사용된다.
        - HAVING절 : GROUP BY와 함께 사용되며, 그룹에 대한 조건을 지정한다.
    - 그룹 함수
        - 그룹 함수는 GROUP BY 절에 지정된 그룹별로 속성의 값을 집계할 때 사용
            
            
            | 함수 | 기능 |
            | --- | --- |
            | COUNT(속성명) | - 그룹별 튜플 수를 구하는 함수 |
            | SUM(속성명) | - 그룹별 합계를 구하는 함수 |
            | AVG(속성명) | - 그룹별 평균을 구하는 함수  |
            | MAX(속성명) | - 그룹별 최댓값을 구하는 함수 |
            | MIN(속성명) | - 그룹별 최솟값을 구하는 함수 |
            | STDDEV(속성명) | - 그룹별 표준편차를 구하는 함수 |
            | VARIANCE(속성명) | - 그룹별 분산을 구하는 함수 |
            | ROLLUP(속성명, 속성명,
            —-) | - 인수로 주어진 속성을 대상으로 그룹별 소계를 구하는 함수 
            
            - 속성의 개수가 n개이면 n+1 레벨까지, 하위 레벨에서 상위 레벨 순으로 데이터가 집계 |
            | CUBE(속성명, 속성명,
            —-) | - ROLLUP과 유사한 형태지만 CUBE는 인수로 주어진 속성을 대상으로 모든 조합의 그룹별 소계를 구함 
            
            - 속성의 개수가 n개이면 2ⁿ레벨까지, 상위 레벨에서 하위 레벨 순으로 데이터가 집계 |
    - WINDOW 함수
        - WINDOW 함수는 GROUP BY 절을 이용하지 않고 함수의 인수로 지정한 속성의 값을 집계
        - 함수의 인수로 지정한 속성이 집계할 범위가 되는데, 이를 윈도우(WINDOW)라고 한다.
            - ROW_NUMBER() : 윈도우별로 각 레코드에 대한 일련번호를 반환한다
            - RANK() : 윈도우별로 순위를 반환하며, 공동 순위를 반영한다
            - DENSE_RANK() : 윈도우별로 순위를 반환하며, 공동 순위를 무시하고 순위를 부여한다
    - WINDOW 함수 이용 검색
        - GROUP BY 절을 이용하지 않고 함수의 인수로 지정한 속성을 범위로 하여 속성의 값을 집계한다
            
            ```sql
            SELECT 상여내역, 상여금, 
                   ROW_NUMBER() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS NO
              FROM 상여금;
            
            SELECT 상여내역, 상여금, 
                   RANK() OVER (PARTITION BY 상여내역 ORDER BY 상여금 DESC) AS 상여금순위
              FROM 상여금;
            ```
            
    - 그룹 지정 검색
        - GROUP BY 절에 지정한 속성을 기준으로 자료를 그룹화하여 검색한다
            
            ```sql
            SELECT 부서, AVG(상여금) AS 평균
              FROM 상여금
             GROUP BY 부서;
            
            SELECT 부서, COUNT(*) AS 사원수
              FROM 상여금
             GROUP BY 부서;
            
            SELECT 부서, COUNT(*) AS 사원수
              FROM 상여금
             WHERE 상여금 >= 100
             GROUP BY 부서
             HAVING COUNT(*) >= 2;
            
            SELECT 부서, 상여내역, SUM(상여금) AS 상여금합계
              FROM 상여금
             GROUP BY ROLLUP(부서, 상여내역); 
            
            SELECT 부서, 상여내역, SUM(상여금) AS 상여금합계
              FROM 상여금
             GROUP BY CUBE(부서, 상여내역);  
            ```
            
    - 집합 연산자를 이용한 통합 질의
        - 집합 연산자를 사용하여 2개 이상의 테이블의 데이터를 하나로 통합한다
            
            ```sql
            SELECT 속성명1, 속성명2, ---
              FROM 테이블명
             UNION | UNION ALL | INTERSECT | EXCEPT
              FROM 테이블명
            [ORDER BY 속성명 [ASC | DESC]];  
            ```
            
            - 두 개의 SELECT 문에 기술한 속성들은 개수와 데이터 유형이 서로 동일해야 한다.
            - 집합 연산자의 종류(통합 질의의 종류)
                
                
                | 집합 연산자 | 설명 | 집합 종류 |
                | --- | --- | --- |
                | UNION  | - 두 SELECT 문의 조회 결과를 통합하여 모두 출력
                
                - 중복된 행은 한 번만 출력 | 합집합 |
                | UNION ALL  | - 두 SELECT 문의 조회 결과를 통합하여 모두 출력
                
                - 중복된 행도 그대로 출력 | 합집합 |
                | INTERSECT  | - 두 SELECT문의 조회 결과 중 공통된 행만 출력한다. | 교집합 |
                | EXCEPT  | - 첫 번째 SELECT문의 조회 결과에서 두 번째 SELECT문의 조회 결과를 제외한 행을 출력한다.  | 차집합 |
- DML - JOIN B
    - JOIN
        - JOIN은 2개의 릴레이션에서 연관된 튜플들을 결합하여, 하나의 새로운 릴레이션을 반환
        - JOIN은 일반적으로 FROM절에 기술하지만, 릴레이션이 사용되는 곳 어디에나 사용 가능
        - JOIN은 크게 INNER JOIN과 OUTER JOIN으로 구분
    - INNER JOIN
        - INNER JOIN은 일반적으로 EQUI JOIN과 NON-EQUI JOIN으로 구분
            - 조건이 없는 INNER JOIN 수행 시 CROSS JOIN과 동일한 결과를 얻을 수 있다
            - EQUI JOIN
                - EQUI JOIN은 JOIN 대상 테이블에서 공통 속성을 기준으로 ‘=’(EQUAL) 비교에 의해 같은 값을 가지는 행을 연결하여 결과를 생성하는 JOIN 방법
                - EQUI JOIN에서 JOIN의 조건이 ‘=’일 때 동일한 속성이 두 번 나타나게 되는데, 이 중 중복된 속성을 제거하고 같은 속성을 한 번만 표기하는 방법을 NATURAL JOIN이라고 함
                - WHERE절을 이용한 EQUI JOIN의 표기 형식
                    
                    ```sql
                    SELECT [테이블명1.]속성명, [테이블명2.]속성명, ---
                      FROM 테이블명1, 테이블명2, ---
                     WHERE 테이블명1.속성명 = 테이블명2.속성명;
                    ```
                    
                - NATURAL JOIN절을 이용한 EQUI JOIN의 표기 형식
                    
                    ```sql
                    SELECT [테이블명1.]속성명, [테이블명2.]속성명, ---
                      FROM 테이블명1 NATURAL JOIN 테이블명2;
                    ```
                    
                - JOIN ~ USING 절을 이용한 EQUI JOIN의 표기 형식
                    
                    ```sql
                    SELECT [테이블명1.]속성명, [테이블명2.]속성명, ---
                      FROM 테이블명1 JOIN 테이블명2 USING(속성명);
                    ```
                    
                - NON-EQUI JOIN
                    - NON-EQUI JOIN은 JOIN 조건에 ‘=’ 조건이 아닌 나머지 비교 연산자, 즉 >, <, <>, ≥, ≤ 연산자를 사용하는 JOIN 방법
                        
                        ```sql
                        SELECT [테이블명1.]속성명, [테이블명2.]속성명, ---
                          FROM 테이블명1, 테이블명2, ---
                         WHERE (NON-EQUI JOIN 조건);
                        
                        SELECT 학번, 이름, 성적, 등급
                          FROM 학생, 성적등급
                         WHERE 학생.성적 BETWEEN 성적등급.최조 AND 성적등급.최고
                        ```
                        
    - OUTER JOIN
        - OUTER JOIN은 릴레이션에서 JOIN 조건에 만족하지 않는 튜플도 결과로 출력하기 위한 JOIN 방법으로, LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN이 있다
            - LEFT OUTER JOIN : INNER JOIN의 결과를 구한 후, 우측 항 릴레이션의 어떤 튜플과도 맞지 않는 좌측 항의 릴레이션에 있는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가
                
                ```sql
                SELECT [테이블명1.]속성명, [테이블명2].속성명, ---
                  FROM 테이블명1 LEFT OUTER JOIN 테이블명2
                    ON 테이블명1.속성명 = 테이블명2.속성명;
                
                SELECT [테이블명1.]속성명, [테이블명2].속성명, ---
                  FROM 테이블명1, 테이블명2
                 WHERE 테이블명1.속성명 = 테이블명2.속성명(+);
                ```
                
            - RIGHT OUTER JOIN : INNER JOIN의 결과를 구한 후, 좌측 항 릴레이션의 어떤 튜플과도 맞지 않는 우측 항의 릴레이션에 있는 튜플들에 NULL값을 붙여서 INNER JOIN의 결과에 추가
                
                ```sql
                SELECT [테이블명1.]속성명, [테이블명2].속성명, ---
                  FROM 테이블명1 RIGHT OUTER JOIN 테이블명2
                    ON 테이블명1.속성명 = 테이블명2.속성명;
                
                SELECT [테이블명1.]속성명, [테이블명2].속성명, ---
                  FROM 테이블명1, 테이블명2
                 WHERE 테이블명1.속성명(+) = 테이블명2.속성명;
                ```
                
            - FULL OUTER JOIN
                - LEFT OUTER JOIN과 RIGHT OUTER JOIN을 합쳐 놓은 것
                - INNER JOIN의 결과를 구한 후, 좌측 항의 릴레이션의 튜플들에 대해 우측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN 결과에 추가한다. 그리고 유사하게 우측 항의 릴레이션의 튜플들에 대해 좌측 항의 릴레이션의 어떤 튜플과도 맞지 않는 튜플들에 NULL 값을 붙여서 INNER JOIN의 결과에 추가
                    
                    ```sql
                    SELECT [테이블명1.]속성명, [테이블명2].속성명, ---
                      FROM 테이블명1 FULL OUTER JOIN 테이블명2
                        ON 테이블명1.속성명 = 테이블명2.속성명;
                    ```
                    
- Trigger C
    - 트리거(Trigger)
        - 트리거는 데이터베이스 시스템에서 데이터의 삽입(Insert), 갱신(Update), 삭제(Delete) 등의 이벤트(Event)가 발생할 때마다 관련 작업이 자동으로 수행되는 절차형 SQL
        - 트리거는 데이터베이스에 저장되며, 데이터 변경 및 무결성 유지, 로그 메시지 출력 등의 목적으로 사용
        - 트리거의 구문에는 DCL(데이터 제어어)을 사용할 수 없으며, DCL이 포함된 프로시저나 함수를 호출하는 경우에도 오류가 발생
    - 트리거의 구성도
        
        ![Untitled](시나공_필기_1권/Untitled%2055.png)
        
        - 트리거는 선언, 이벤트, 시작, 종료로 구성되며, 시작과 종료 구문 사이에는 제어(CONTROL), SQL, 예외(EXCEPTION)가 포함된다.
        - DECLARE : 트리거의 명칭, 변수 및 상수, 데이터 타입을 정의하는 선언부
        - EVENT : 트리거가 실행되는 조건 명시
        - BEGIN / END : 트리거의 시작과 종료
        - CONTROL : 조건문 또는 반복문이 삽입되어 순차적으로 처리
        - SQL : DML문이 삽입되어 데이터 관리를 위한 조회, 추가, 수정, 삭제 작업을 수행
        - EXCEPTION : BEGIN ~ END 안의 구문 실행 시 예외가 발생하면 이를 처리하는 방법 정의
    - 트리거의 생성
        - 트리거를 생성하기 위해서는 CREATE TRIGGER 명령어를 사용한다.
        - 표기 형식
            
            ```sql
            CREATE [OR REPLACE] TRIGGER 트리거명 동작시기 동작 ON 테이블명
            [REFERENCING NEW | OLD AS 테이블명]
            [FOR EACH ROW [WHEN 조건식]]
            BEGIN
              트리거 BODY;
            END; 
            ```
            
            - OR REPLACE : 선택적인(Optional) 예약어. 예약어 사용 시 동일한 트리거 이름이 이미 존재하는 경우 기존의 트리거 대체 가능
            - 동작시기 : 트리거가 실행될 때를 지정한다. 종류에는 AFTER와 BEFORE가 있다.
                - AFTER : 테이블이 변경된 후 트리거 실행
                - BEFORE : 테이블이 변경되기 전에 트리거 실행
            - 동작 : 트리거가 실행되게 할 작업의 종류 지정.
                - INSERT : 테이블에 새로운 튜플 삽입할 때 트리거 실행
                - DELETE : 테이블의 튜플 삭제할 때 트리거 실행
                - UPDATE : 테이블의 튜플을 수정할 때 트리거 실행
            - NEW | OLD : 트리거가 적용될 테이블의 별칭 지정
                - NEW : 추가되거나 수정에 참여할 튜플들의 집합(테이블)을 의미
                - OLD : 수정되거나 삭제 전 대상이 되는 튜플들의 집합(테이블)을 의미
            - FOR EACH ROW : 각 튜플마다 트리거를 적용
            - WHEN 조건식 : Optional 예약어. 트리거를 적용할 튜플의 조건 지정
            - 트리거 BODY
                - 트리거의 본문 코드를 입력하는 부분
                - BEGIN으로 시작해서 END로 끝나는데, 적어도 하나 이상의 SQL문이 없으면 에러 발생
    - 트리거의 제거
        - 트리거를 제거하기 위해서는 DROP TRIGGER 명령어를 사용
            
            ```sql
            DROP TRIGGER 트리거명;
            ```
            

# 소프트웨어 개발 보안 구축

- Secure SDLC B
    - Secure SDLC
        - Secure SDLC는 보안상 안전한 소프트웨어를 개발하기 위해 SDLC에 보안 강화를 위한 프로세스를 포함한 것을 의미
        - Secure SDLC는 요구사항 분석, 설계, 구현, 테스트, 유지보수 등 SDLC 전체 단계에 걸쳐 수행되어야 할 보안 활동을 제시한다
        - Secure SDLC의 대표적인 방법론
            
            
            | 방법론 | 내용 |
            | --- | --- |
            | CLASP | SDLC의 초기 단계에서 보안을 강화하기 위해 개발된 방법론 |
            | SDL | 마이크로소프트 사에서 안전한 소프트웨어 개발을 위해 기존의 SDLC를 개선한 방법론 |
            | Seven
            Tocuhpoints | 소프트웨어 보안의 모범사례를 SDLC에 통합한 방법론 |
    - SDLC 단계별 보안 활동
        1. 요구사항 분석 단계 
            - 보안 항목에 해당하는 요구사항을 식별하는 작업을 수행
        2. 설계 단계
            - 식별된 보안 요구사항들을 소프트웨어 설계서에 반영하고, 보안 설계서를 작성
        3. 구현 단계
            - 표준 코딩 정의서 및 소프트웨어 개발 보안 가이드를 준수하며, 설계서에 따라 보안 요구사항들을 구현
        4. 테스트 단계
            - 설계 단계에서 작성한 보안 설계서를 바탕으로 보안 사항들이 정확히 반영되고 동작되는지 점검
        5. 유지보수 단계
            - 이전 과정을 모두 수행하였음에도 발생할 수 있는 보안사고들을 식별
            - 사고 발생 시 이를 해결하고 보안 패치를 실시
    - 소프트웨어 개발 보안 요소
        
        
        | 보안 요소 | 설명 |
        | --- | --- |
        | 기밀성
        (Confidentiality) | - 시스템 내의 정보와 자원은 인가된 사용자에게만 접근이 허용
        
        - 정보가 전송 중에 노출되더라도 데이터를 읽을 수 없음 |
        | 무결성
        (Integrity) | - 시스템 내의 정보는 오직 인가된 사용자만 수정 가능 |
        | 가용성
        (Availability) | - 인가 받은 사용자는 시스템 내의 정보와 자원을 언제라도 사용 가능 |
        | 인증
        (Authentication) | - 시스템 내의 정보와 자원을 사용하려는 사용자가 합법적인 사용자인지를 확인하는 모든 행위 
        
        - 대표적 방법 : 패스워드, 인증용 카드, 지문 검사 등 |
        | 부인 방지
        (NonRequdiation) | - 데이터를 송, 수신한 자가 송, 수신 사실을 부인할 수 없도록 송, 수신 증거를 제공 |
    - 시큐어 코딩(Secure Coding)
        - 시큐어 코딩은 구현 단계에서 발생할 수 있는 보안 취약점들을 최소화하기 위해 보안 요소들을 고려하며 코딩하는 것
        - 보안 취약점을 사전 대응하여 안전성과 신뢰성 확보
        - 보안 정책을 바탕으로 시큐어 코딩 가이드를 작성하고, 개발 참여자에게는 시큐어 코딩 교육 실시
- 입력 데이터 검증 및 표현 B
    - 입력 데이터 검증 및 표현
        - 입력 데이터 검증 및 표현은 입력 데이터로 인해 발생하는 문제들을 예방하기 위해 구현 단계에서 검증해야 하는 보안 점검 항목들
        - 입력 데이터 검증 및 표현의 보안 약점
            
            
            | SQL 삽입
            (SQL Injection) | - 웹 응용 프로그램에 SQL을 삽입하여 내부 데이터베이스(DB) 서버의 데이터를 유출 및 변조하고, 관리자 인증을 우회하는 보안 약점
            
            - 동적 쿼리에 사용되는 입력 데이터에 예약어 및 특수문자가 입력되지 않게 필터링 되도록 설정하여 방지 |
            | --- | --- |
            | 경로 조작 및
            자원 삽입 | - 데이터 입출력 경로를 조작하여 서버 자원을 수정, 삭제할 수 있는 보안 약점
            
            - 사용자 입력값을 식별자로 사용하는 경우, 경로 순회 공격을 막는 필터를 삽입하여 방지 |
            | 크로스사이트
            스크립팅(XSS;
            Cross Site
            Scripting) | - 웹페이지에 악의적인 스크립트를 삽입하여 방문자들의 정보를 탈취하거나, 비정상적인 기능 수행을 유발하는 보안 약점
            
            - HTML 태그의 사용을 제한하거나 스크립트에 삽입되지 않도록 ‘<’, ‘>’, ‘&’ 등의 문자를 다른 문자로 치환함으로써 방지 |
            | 운영체제
            명령어 삽입 | - 외부 입력값을 통해 시스템 명령어의 실행을 유도함으로써 권한을 탈취하거나 시스템 장애를 유발하는 보안 약점
            
            - 웹 인터페이스를 통해 시스템 명령어가 전달되지 않도록 하고, 외부 입력값을 검증 없이 내부 명령어로 사용하지 않음으로써 방지 |
            | 위험한 형식 
            파일 업로드 | - 악의적인 명령어가 포함된 스크립트 파일을 업로드함으로써 시스템에 손상을 주거나, 시스템을 제어할 수 있는 보안 약점
            
            - 업로드 되는 파일의 확장자 제한, 파일명의 암호화, 웹사이트와 파일 서버의 경로 분리, 실행 속성을 제거하는 등의 방법으로 방지 |
            | 신뢰되지 않는
            URL 주소로
            자동접속 연결 | - 입력 값으로 사이트 주소를 받는 경우 이를 조작하여 방문자를 피싱 사이트로 유도하는 보안 약점
            
            - 연결되는 외부 사이트의 주소를 화이트 리스트로 관리함으로써 방지 |
            | 메모리 버퍼
            오버플로 | - 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에서 자료를 읽거나 쓰려고 할 때 발생하는 보안 약점
            
            - 메모리 버퍼를 사용할 경우 적절한 버퍼의 크기를 설정하고, 설정된 범위의 메모리 내에서 올바르게 읽거나 쓸 수 있도록 함으로써 방지 |
- 보안 기능 C
    - 보안 기능
        - 보안 기능은 소프트웨어 개발의 구현 단계에서 코딩하는 기능인 인증, 접근 제어, 기밀성, 암호화 등을 올바르게 구현하기 위한 보안 점검 항목들
        - 보안 기능의 보안 약점
            
            
            | 적절한 인증 없이
            중요기능 허용 | - 보안검사를 우회하여 인증과정 없이 중요한 정보 또는 기능에 접근 및 변경이 가능
            
            - 중요정보나 기능을 수행하는 페이지에서는 재인증 기능을 수행하도록 하여 방지 |
            | --- | --- |
            | 부적절한 인가 | - 접근제어 기능이 없는 실행경로를 통해 정보 또는 권한을 탈취할 수 있다. 
            
            - 모든 실행경로에 대해 접근제어 검사를 수행하고, 사용자에게는 반드시 필요한 접근 권한만을 부여하여 방지 |
            | 중요한 자원에 
            대한 잘못된 권한
            설정 | - 권한 설정이 잘못된 자원에 접근하여 해당 자원을 임의로 사용할 수 있다. 
            
            - 소프트웨어 관리자만 자원들을 읽고 쓸 수 있도록 설정하고, 인가되지 않은 사용자의 중요 자원에 대한 접근 여부를 검사함으로써 방지 |
            | 취약한 암호화
            알고리즘 사용 | - 암호화된 환경설정 파일을 해독하여 비밀번호 등의 중요정보를 탈취할 수 있다. 
            
            - 안전한 암호화 알고리즘을 이용하고, 업무관련 내용이나 개인정보 등에 대해서는 IT 보안인증사무국이 안정성을 확인한 암호모듈을 이용함으로써 방지 |
            | 중요정보 평문
            저장 및 전송 | - 암호화되지 않은 평문 데이터를 탈취하여 중요한 정보를 획득할 수 있다. 
            
            - 중요한 정보를 저장하거나 전송할 때는 반드시 암호화 과정을 거치도록 하고, HTTPS 또는 SSL 과 같은 보안 채널을 이용함으로써 방지 |
            | 하드코드 된
            비밀번호 | - 소스코드 유출 시 내부에 하드코드된 패스워드를 이용하여 관리자 권한을 탈취할 수 있다. 
            
            - 상수 형태의 암호키를 사용하지 않고, 암호화 키 생성 모듈 또는 보안이 보장된 외부 공간을 이용함으로써 방지  |
- 코드 오류 C
    - 코드 오류
        - 코드 오류는 소프트웨어 구현 단계에서 개발자들이 코딩 중 실수하기 쉬운 형(Type) 변환, 자원 반환 등의 오류를 예방하기 위한 보안 점검 항목들
        - 코드 오류의 보안 약점
            
            
            | 보안 약점 | 설명 |
            | --- | --- |
            | 널 포인터
            (Null Pointer)
            역참조 | - 널 포인터가 가리키는 메모리의 위치에 값을 저장할 때 발생하는 보안 약점
            
            - 포인터를 이용하기 전에 널 값을 갖고 있는지 검사함으로써 방지 |
            | 부적절한
            자원 해제 | - 자원을 반환하는 코드를 누락하거나 프로그램 오류로 할당된 자원을 반환하지 못했을 때 발생하는 보안 약점 
            
            - 프로그램 내에 자원 반환 코드가 누락되었는지 확인하고, 오류로 인해 함수가 중간에 종료되었을 때 예외처리에 관계없이 자원이 반환되도록 코딩함으로써 방지 |
            | 해제된 자원
            사용 | - 이미 사용이 종료되어 반환된 메모리를 참조하는 경우 발생하는 보안 약점 
            
            - 반환된 메모리에 접근할 수 없도록 주소를 저장하고 있는 포인터를 초기화함으로써 방지 |
            | 초기화되지
            않은 변수 사용 | - 변수 선언 후 값이 부여되지 않은 변수를 사용할 때 발생하는 보안 약점
            
            - 변수 선언 시 할당된 메모리를 초기화함으로써 방지  |
    - 스택 가드(Stack Guard)
        - 널 포인터 역참조와 같이 주소가 저장되는 스택에서 발생하는 보안 약점을 막는 기술 중 하나
        - 메모리상에서 프로그램의 복귀 주소와 변수 사이에 특정 값을 저장한 후 그 값이 변경되었을 경우 오버플로우 상태로 판단하여 프로그램 실행을 중단함으로써 잘못된 복귀 주소의 호출을 막는다
- 캡슐화 C
    - 캡슐화
        - 캡슐화는 정보 은닉이 필요한 중요한 데이터와 기능을 불완전하게 캡슐화하거나 잘못 사용함으로써 발생할 수 있는 문제를 예방하기 위한 보안 점검 항목들
        - 캡슐화의 보안 약점
            
            
            | 보안 약점 | 설명 |
            | --- | --- |
            | 잘못된 세션에
            의한 정보 노출 | - 다중 스레드(Multi-Thread) 환경에서 멤버 변수에 정보를 저장할 때 발생하는 보안 약점
            
            - 멤버 변수보다 지역 변수를 활용하여 변수의 범위를 제한함으로써 방지 |
            | 제거되지 않고 
            남은 디버그 코드 | - 개발 중에 버그 수정이나 결과값 확인을 위해 남겨둔 코드들로 인해 발생하는 보안 약점 
            
            - 소프트웨어 배포 전에 코드 검사를 수행하여 남아있는 디버그 코드를 삭제함으로써 방지 |
            | 시스템 데이터 
            정보 노출 | - 시스템의 내부 정보를 시스템 메시지 등을 통해 외부로 출력하도록 코딩했을 때 발생하는 보안 약점
            
            - 노출되는 메시지에는 최소한의 정보만을 제공함으로써 방지 |
            | Public 메소드
            로부터 반환된
            Private 배열 | - 선언된 클래스 내에서만 접근이 가능한 Private 배열을 모든 클래스에서 접근이 가능한 Public 메소드에서 반환할 때 발생하는 보안 약점 
            
            - Private 배열을 별도의 메소드를 통해 조작하거나, 동일한 형태의 복제본으로 반환받은 후 값을 전달하는 방식으로 방지 |
            | Private 배열에 
            Public 데이터 
            할당 | - Pirvate 배열에 Public으로 선언된 데이터 또는 메소드의 파라미터를 저장할 때 발생하는 보안 약점
            
            - Public으로 선언된 데이터를 Private 배열에 저장할 때, 레퍼런스가 아닌 값을 직접 지정함으로써 방지  |
    - 접근 제어자
        - 접근 제어자는 프로그래밍 언어에서 특정 개체를 선언할 때 외부로부터의 접근을 제한하기 위해 사용되는 예약어
            
            
            | 접근 제어자 | 클래스 내부 | 패키지 내부 | 하위 클래스 | 패키지 외부 |
            | --- | --- | --- | --- | --- |
            | Public | O | O | O | O |
            | Protected | O | O | O | X |
            | Default | O | O | X | X |
            | Private | O | X | X | X |
- 암호 알고리즘 A
    - 암호 알고리즘
        - 암호 알고리즘은 패스워드, 주민번호, 은행계좌와 같은 중요 정보를 보호하기 위해 평문을 암호화된 문장으로 만드는 절차 또는 방법을 으미ㅣ
        - 암호 방식 분류
            
            ![Untitled](시나공_필기_2권/Untitled%2017.png)
            
    - 개인키 암호화(Private Key Encryption) 기법
        - 개인키 암호화 기법은 동일한 키로 데이터를 암호화하고 복호화하는 암호화 기법
        - 대칭 암호 기법 또는 단일키 암호화 기법이라고도 한다
        - 암호화/복호화 속도가 빠르지만, 관리해야 할 키의 수가 많다
        - 개인키 암호화 기법의 종류
            
            
            | 스트림 암호화 방식 | - 평문과 동일한 길이의 스트림을 생성하여 비트 단위로 암호화하는 방식
            
            - 종류 : LFSR, RC4, TKIP |
            | --- | --- |
            | 블록 암호화 방식 | - 한 번에 하나의 데이터 블록을 암호화 하는 방식
            
            - 종류 : DES, SEED, AES, ARIA, IDEA, Skipjack |
    - 공개키 암호화(Public Key Encryption) 기법
        - 공개키 암호화 기법은 데이터를 암호화할 때 사용하는 공개키(Public Key)는 사용자에게 공개하고, 복호화할 때의 비밀키(Secret Key)는 관리자가 비밀리에 관리하는 암호화 기법
        - 비대칭 암호 기법이라고도 함
        - 관리해야 할 키의 수가 적지만, 암호화/복호화 속도가 느림
        - 대표적으로는 RSA(Rivest Shamir Adleman) 기법이 있다
    - 양방향 알고리즘의 종류
        
        
        | 알고리즘 | 특징 |
        | --- | --- |
        | SEED | - 1999년 한국인터넷진흥원(KISA)에서 개발한 블록 암호화 알고리즘
        
        - 블록 크기는 128Bit, 키 길이에 따라 128, 256으로 분류 |
        | ARIA(Academy, 
        Research Institute,
        Agency) | - 2004년 국가정보원과 산학연협회가 개발한 블록 암호화 알고리즘 |
        | DES(Data
        Encryption
        Standard) | - 1975년 미국 NBS에서 발표한 개인키 암호화 알고리즘
        
        - 블록 크기는 64비트, 키 길이는 56비트이며 16회의 라운드를 수행
        
        - DES를 3번 적용하여 보안을 더욱 강화한 3DES(Triple DES)도 있음 |
        | AES(Advanced
        Encryption
        Standard) | - 2001년 미국 표준 기술 연구소(NIST)에서 발표한 개인키 암호화 알고리즘
        
        - DES의 한계를 느낀 NIST에서 공모한 후 발표
        
        - 블록 크기는 128비트이며, 키 길이에 따라 AES-128, AES-192, AES-256으로 분류 |
        | RSA(Rivest Shamir
        Adleman) | - 1978년 MIT의 라이베스트(Rivest), 샤미르(Sharmir), 애들먼(Adelman)에 듸해 제안된 공개키 암호화 알고리즘
        
        - 큰 숫자를 소인수분해 하기 어렵다는 것에 기반하여 만들어짐 |
        | IDEA(Intenational
        Data Encryption
        Algorithm) | - 스위스의 라이(Lai)와 메시(Messey)가 1990년에 개발한 PES를 개선한 알고리즘
        
        - 블록 크기는 64비트, 키 길이는 128비트 |
        | Skipjack | - 국가 안전 보장국(NSA)에서 개발한 암호화 알고리즘 
        
        - 클리퍼 칩(Clipper Chip)이라는 IC 칩에 내장되어 있음 
        
        - 블록 크기는 64비트이고, 키 길이는 80비트
        
        - 주로 음성 통신 장비에 삽입되어 음성 데이터를 암호화  |
        | TKIP(Temporal
        Key Integrity
        Protocol) | - 무선랜 보안에 사용된 WEP를 보완한 데이터 보안 프로토콜로, 임시 키 무결성 프로토콜이라고도 함
        
        - WEP의 취약성을 보완하기 위해 암호 알고리즘의 입력 키 길이를 128비트로 늘리고 패킷당 키 할당, 키값 재설정 등 관리 방식을 개선 |
    - 해시(Hash)
        - 해시는 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것
        - 해시 알고리즘을 해시 함수라고 부르며, 해시 함수로 변환된 값이나 키를 해시값 또는 해시키라고 부른다
        - 데이터의 암호화, 무결성 검증을 위해 사용될 뿐만 아니라 정보보호의 다양한 분야에서 활용
        - 해시 함수의 종류
            
            
            | 해시 함수 | 특징 |
            | --- | --- |
            | SHA 시리즈 | - 1993년 미국 국가안보국(NSA)이 설계, 미국 국립표준기술연구소(NIST)에 의해 발표
            
            - 초기 개발된 SHA-0 이후 SHA-1 이 발표되었고, 다시 SHA-2라고 부르는 SHA-224, SHA-256, SHA-384, SHA-512가 발표 |
            | MD5
            (Message Digest
            algorithm 5) | - 1992년 R.Rivest가 MD4를 대체하기 위해 고안한 암호화 해시 함수
            
            - 블록 크기는 512비트, 키 길이는 128비트 |
            | N-NASH | - 1989년 일본의 전신전화주식회사(NTT)에서 발표한 암호화 해시 함수
            
            - 블록 크기와 키 길이 모두 128비트 |
            | SNEFRU | - 1990년 R.C.Merkle가 발표한 해시 함수
            
            - 32비트 프로세서에서 구현을 용이하게 할 목적으로 개발  |
- 서비스 공격 유형 A
    - 서비스 거부(DoS; Denial of Service) 공격
        - 서비스 거부 공격이란 표적이 되는 서버의 자원을 고갈시킬 목적으로 다수의 공격자 또는 시스템에서 대량의 데이터를 한 곳의 서버에 집중적으로 전송함으로써, 표적이 되는 서버의 정상적인 기능을 방해하는 것
        - 주요 서비스 거부 공격의 유형
            - Ping of Death
            - SMURFING
            - SYN Flooding
            - TearDrop
            - LAND Attack
            - DDoS 공격
    - Ping of Death(죽음의 핑)
        - Ping of Death는 Ping 명령을 전송할 때 패킷의 크기를 인터넷 프로토콜 허용 범위 이상으로 전송하여 공격 대상의 네트워크를 마비시키는 서비스 거부 공격 방법
        - 공격에 사용되는 큰 패킷은 수백 개의 패킷으로 분할되어 전송되는데, 공격 대상은 분할된 대량의 패킷을 수신함으로써 분할되어 전송된 패킷을 재조립 해야 하는 부담과 분할되어 전송된 각각의 패킷들의 ICMP Ping 메시지에 대한 응답을 처리하느라 시스템이 다운됨
    - SMURFING(스머핑)
        - SMURFING은 IP나 ICMP의 특성을 악용하여 엄청난 양의 데이터를 한 사이트에 집중적으로 보냄으로써 네트워크를 불능 상태로 만드는 공격 방법
        - 공격자는 송신 주소를 공격 대상지의 IP 주소로 위장하고 해당 네트워크 라우터의 브로드캐스트 주소를 수신지로 하여 패킷을 전송하면, 라우터의 브로드캐스트 주소로 수신된 패킷은 해당 네트워크 내의 모든 컴퓨터로 전송됨
        - 해당 네트워크 내의 모든 컴퓨터는 수신된 패킷에 대한 응답 메시지를 송신 주소인 공격 대상지로 집중적으로 전송하게 되는데, 이로 인해 공격 대상지는 네트워크 과부하로 인해 정상적인 서비스를 수행할 수 없게 됨
        - SMURFING 공격을 무력화하는 방법 중 하나는 각 네트워크 라우터에서 브로드캐스트 주소를 사용할 수 없게 미리 설정해 놓는 것
    - SYN Flooding
        - TCP(Transmission Control Protocol)는 신뢰성 있는 전송을 위해 3-way handshake를 거친 후 데이터를 전송하는데, SYN Flooding은 공격자가 가상의 클라이언트로 위장하여 3-way-handshake 과정을 의도적으로 중단시킴으로써 공격 대상지인 서버가 대기 상태에 놓여 정상적인 서비스를 수행하지 못하게 하는 공격 방법
        - SYN Flooding에 대비하기 위해 수신지의 ‘SYN’ 수신 대기 시간을 줄이거나 침입 차단 시스템을 활용한다
    - TearDrop
        - 데이터의 송,수신 과정에서 패킷의 크기가 커 여러 개로 분할되어 전송될 때 분할 순서를 알 수 있도록 Fragment Offset 값을 함께 전송하는데, TearDrop은 이 Offset 값을 변경시켜 수신 측에서 패킷을 재조립할 때 오류로 인한 과부하를 발생시킴으로써 시스템이 다운되도록 하는 공격 방법
        - TearDrop에 대비하기 위해 Fragment Offset이 잘못된 경우 해당 패킷을 폐기하도록 설정
    - LAND Attack(Local Area Network Denial Attack)
        - LAND Attack은 패킷을 전송할 때 송신 IP 주소와 수신 IP 주소를 모두 공격 대상의 IP 주소로 하여 공격 대상에게 전송하는 것으로, 이 패킷을 받은 공격 대상은 송신 IP 주소가 자신이므로 자신에게 응답을 수행하게 된다. 이처럼 패킷이 계속해서 전송될 경우 자신에 대해 무한히 응답하게 하는 공격
        - LAND Attack에 대비하기 위해 송신 IP 주소와 수신 IP 주소의 적절성을 검사한다
    - DDoS(Distributed Denial of Service, 분산 서비스 거부) 공격
        - DDoS 공격은 여러 곳에 분산된 공격 지점에서 한 곳의 서버에 대해 서비스 거부 공격을 수행하는 것
        - 네트워크에서 취약점이 있는 호스트들을 탐색한 후 이들 호스트들에 분산 서비스 공격용 툴을 설치하여 에이전트(Agent)로 만든 후 DDoS 공격에 이용
        - 분산 서비스 공격용 툴 : 에이전트(Agent)의 역할을 수행하도록 설계된 프로그램으로 데몬(Daemon)이라고 부르며, 다음과 같은 종류가 있다.
            
            
            | 종류 | 내용 |
            | --- | --- |
            | Trin00 | - 가장 초기 형태의 데몬으로, 주로 UDP Flooding 공격을 수행 |
            | TFN(Tribe Flood
            Network) | - UDP Flooding 뿐만 아니라 TCP SYN Flood 공격, ICMP 응답 요청, 스머핑 공격 등을 수행 |
            | TFN2K | - TFN의 확장판 |
            | Stacheldraht | - 이전 툴들의 기능을 유지하면서, 공격자, 마스터, 에이전트가 쉽게 노출되지 않도록 암호화된 통신을 수행 
            
            - 툴이 자동으로 업데이트됨 |
    - 네트워크 침해 공격 관련 용어
        
        
        | 용어 | 의미 |
        | --- | --- |
        | 세션 하이재킹
        (Session Hijacking) | - 상호 인증 과정을 거친 후 접속해 있는 서버와 서로 접속되어 클라이언트 사이의 세션 정보를 가로채는 공격 기법. 접속을 위한 인증 정보 없이도 가로챈 세션을 이용해 공격자가 원래의 클라이언트인 것처럼 위장하여 서버의 자원이나 데이터를 무단으로 사용
        
        - TCP 3-Way-Handshake 과정에 끼어듦으로써 클라이언트와 서버 간의 동기화된 시퀀스 번호를 가로채 서버에 무단으로 접근하는 TCP 세션 하이재킹이 대표적 |
        | ARP 스푸핑
        (ARP Sppofing) | - ARP의 취약점을 이용한 공격 기법으로, 자신의 물리적 주소(MAC)를 공격대상의 것으로 변조하여 공격 대상에게 도달해야 하는 데이터 패킷을 가로채거나 방해 |
        | 스미싱(Smishing) | - 문자 메시지(SMS)를 이용해 사용자의 개인 신용 정보를 빼내는 수법
        
        - 초기에는 문자 메시지를 이용해 개인 비밀정보나 소액 결제를 유도하는 형태로 시작 
        
        - 현재는 각종 행사 안내, 경품 안내 등의 문자 메시지에 링크를 걸어 안드로이드 앱 설치 파일인 apk 파일을 설치하도록 유도하여 사용자 정보를 빼가는 수법으로 발전 |
        | 사회 공학(Social
        Engineering) | - 컴퓨터 보안에 있어서, 인간 상호 작용의 깊은 신뢰를 바탕으로 사람들을 속여 정상 보안 절차를 깨트리기 위한 비기술적 시스템 침입 수단 |
        | 다크 데이터
        (Dark Data) | - 특정 목적을 가지고 데이터를 수집하였으나, 이후 활용되지 않고 저장만 되어있는 대량의 데이터 |
        | 타이포스쿼팅
        (Typosquatting) | - 네티즌들이 사이트에 접속할 때 주소를 잘못 입력하거나 철자를 빠뜨리는 실수를 이용하기 위해 이와 유사한 유명 도메인을 미리 등록하는 일로, URL 하이재킹이라고도 함 |
        | 스피어 피싱
        (Spear Phisging) | - 사회 공학의 한 기법으로, 특정 대상을 선정한 후 그 대상에게 일반적인 이메일로 위장한 메일을 지속적으로 발송하여, 발송 메일의 본문 링크나 첨부된 파일을 클릭하도록 유도해 사용자의 개인 정보를 탈취 |
        | APT(Advanced
        Persistent Threats,
        지능형 지속 위협) | - 다양한 IT 기술과 방식들을 이용해 조직적으로 특정 기업이나 조직 네트워크에 침투해 활동 거점을 마련한 뒤 때를 기다리면서 보안을 무력화시키고 정보를 수집한 다음 외부로 빼돌리는 형태의 공격 
        
        - 공격 방법 
          - 내부자에게 악성코드가 포함된 이메일을 오랜 기간 동안 꾸준히 발송해 한 번이라도 클릭되길 기다리는 형태
          - 스턱스넷(Stuxnet)과 같이 악송코드가 담긴 이동식 디스크 등으로 전파하는 형태
          - 악성코드에 감염된 P2P 사이트에 접속하면 악성코드에 감염되는 형태 등 |
        | 무작위 대입 공격
        (Brute Force
        Attack) | - 암호화된 문서의 암호키를 찾아내기 위해 적용 가능한 모든 값을 대입하여 공격하는 방식 |
        | 큐싱(Qsging) | - QR코드(Quick Response Code)를 통해 악성 앱의 다운로드를 유도하거나, 악성 프로그램을 설치하도록 하는 금융사기 기법의 하나로, QR 코드와 개인정보 및 금융정보를 낚는다(Pishing)는 의미의 합성 신조어 |
        | SQL 삽입(Injection)
        공격 | - 전문 스캐너 프로그램 혹은 봇넷 등을 이용해 웹사이트를 무차별적으로 공격하는 과정에서 취약한 사이트가 발견되면 데이터베이스 등의 데이터를 조작하는 일련의 공격 방식 |
        | 크로스 사이트 
        스크립팅
        (XSS; Cross Site
        Scrpting) | - 네트워크를 통한 컴퓨터 보안 공격의 하나로, 웹 페이지의 내용을 사용자 브라우저에 표현하기 위해 사용되는 스크립트의 취약점을 악용한 해킹 기법 
        
        - 사용자가 특정 게시물이나 이메일의 링크를 클릭하면 악성 스크립트가 실행되어 페이지가 깨지거나, 사용자의 컴퓨터에 있는 로그인 정보나 개인 정보, 내부 자료 등이 해커에게 전달 |
        | 스니핑
        (Sniffing) | - 네트워크의 중간에서 남의 패킷 정보를 도청하는 해킹 유형의 하나로 수동적 공격에 해당 |
    - 정보 보안 침해 공격 관련 용어
        
        
        | 용어 | 의미 |
        | --- | --- |
        | 워터링홀
        (Watering Hole) | - 목표 조직이 자주 방문하는 웹 사이트를 사전에 감염시켜 목표 조직의 일원이 웹 사이트에 방문했을 때 악성 코드에 감염되게 하는 웹 기반 공격 |
        | 좀비(Zombie) PC | - 악성코드에 감염되어 다른 프로그램이나 컴퓨터를 조종하도록 만들어진 컴퓨터로, C&C(Command & Control) 서버의 제어를 받아 주로 DDoS 공격 등에 이용 |
        | C&C 서버 | - 해커가 원격지에서 감염된 좀비 PC에 명령을 내리고 악성코드를 제어하기 위한 용도로 사용하는 서버 |
        | 봇넷(Botnet) | - 악성 프로그램에 감염되어 악의적인 의도로 사용될 수 있는 다수의 컴퓨터들이 네트워크로 연결된 형태  |
        | 웜(Worm) | - 네트워크를 통해 연속적으로 자신을 복제하여 시스템의 부하를 높임으로써 결국 시스템을 다운시키는 바이러스의 일종으로, 분산 서비스 거부 공격, 버퍼 오버플로 공격, 슬래머 등이 웜 공격의 한 형태 |
        | 제로 데이 공격
        (Zero Day Attack) | - 보안 취약점이 발견되었을 때 발견된 취약점의 존재 자체가 널리 공표되기도 전에 해당 취약점을 통하여 이루어지는 보안 공격으로, 공격의 신속성을 의미  |
        | 키로거 공격
        (Key Logger Attack) | - 컴퓨터 사용자의 키보드 움직임을 감지해 ID, 패스워드, 계좌 번호, 카드 번호등과 같은 개인의 중요한 정보를 몰래 빼가는 해킹 공격 |
        | 랜섬웨어
        (Ransomware) | - 인터넷 사용자의 컴퓨터에 잠입해 내부 문서나 파일 등을 암호화해 사용자가 열지 못하게 하는 프로그램으로, 암호 해독용 프로그램의 전달을 조건으로 사용자에게 돈을 요구하기도 함 |
        | 백도어
        (Back Door, Trap
        Door) | - 시스템 설계자가 서비스 기술자나 유지 보수 프로그램 작성자(Programmer)의 액세스 편의를 위해 시스템 보안을 제거하여 만들어놓은 비밀 통로로, 컴퓨터 범죄에 악용되기도 함 
        
        - 백도어 탐지 방법 : 무결성 검사, 열린 포트 확인, 로그 분석, SetUID 파일 검사 등  |
        | 트로이 목마
        (Trojan Horse) | - 정상적인 기능을 하는 프로그램으로 위장하여 프로그램 내에 숨어 있다가 해당 프로그램이 동작할 때 활성화되어 부작용을 일으키는 것으로, 자기 복제 능력은 없다  |
- 서버 인증 C
    - 보안 서버
        - 보안 서버란 인터넷을 통해 개인정보를 암호화하여 송,수신할 수 있는 기능을 갖춘 서버
        - 보안 서버의 기능
            - 서버에 SSL(Secure Socket Layer) 인증서를 설치하여 전송 정보를 암호화하여 송,수신하는 기능
            - 서버에 암호화 응용 프로그램을 설치하고 전송 정보를 암호화하여 송,수신하는 기능
    - 인증(認證, Authentication)
        - 인증은 다중 사용자 컴퓨터 시스템이나 네트워크 시스템에서 로그인을 요청한 사용자의 정보를 확인하고 접근 권한을 검증하는 보안 절차이다.
            - 인증에는 네트워크를 통해 컴퓨터에 접속하는 사용자의 등록 여부를 확인하는 것과 전송된 메시지의 위,변조 여부를 확인하는 것이 있다.
            - 인증의 주요 유형
                - 지식 기반 인증(Something You Know)
                - 소유 기반 인증(Something You Have)
                - 생체 기반 인증(Something You Are)
                - 위치 기반 인증(Somewhere You Are)
    - 지식 기반 인증(Something You Know)
        - 지식 기반 인증(Something You Know)은 사용자가 기억하고 있는 정보를 기반으로 인증을 수행하는 것이다.
            - 지식 기반 인증은 사용자의 기억을 기반으로 하므로 관리 비용이 저렴하다.
            - 사용자가 인증 정보를 기억하지 못하면 본인이라도 인증 받지 못한다.
            - 지식 기반 인증 유형
                
                
                | 고정된 패스워드
                (Password) | - 사용자가 알고 있는 비밀번호를 접속할 때 마다 반복해서 입력 |
                | --- | --- |
                | 패스 프레이즈
                (Passphrase)  | - ‘iloveyoy’와 같이 일반 패스워드보다 길이가 길고 기억하기 쉬운 문장을 활용하여 비밀번호를 구성하는 방법 |
                | 아이핀(i-PIN) | - 인터넷에서 주민등록번호 대신 쓸 수 있도록 만든 사이버 주민등록번호
                
                - 사용자에 대한 신원확인을 완료한 후에 본인확인기관에서 온라인으로 발행한다. |
    - 소유 기반 인증(Something You Have)
        - 소유 기반 인증은 사용자가 소유하고 있는 것을 기반으로 인증을 수행하는 것
        - 소유 기반 인증은 소유물이 쉽게 도용될 수 있으므로 지식 기반 인증 방식이나 생체 기반 인증 방식과 함께 사용
        - 소유 기반 인증 유형
            
            
            | 유형 | 내용 |
            | --- | --- |
            | 신분증 | - 사용자의 사진이 포함된 주민등록증, 운전면허증, 여권 등을 사용하여 사용자의 신분을 확인 |
            | 메모리 카드(토큰) | - 마그네틱 선에 보안 코드를 저장해서 사용하는 것으로, 카드 리더기를 통해서만 읽을 수 있다.  |
            | 스마트 카드 | - 마이크로프로세서, 카드 운영체제, 메모리 등으로 구성되어 사용자의 정보뿐만 아니라 특정 업무를 처리할 수 있는 기능이 내장 |
            | OTP
            (One Time 
            Password) | - 용자가 패스워드를 요청할 때마다 암호 알고리즘을 통해 새롭게 생성된 패스워드
            
            - 한 번 사용된 패스워드는 폐기 |
    - 생체 기반 인증(Something You Are)
        - 생체 기반 인증은 사용자의 고유한 생체 정보를 기반으로 인증을 수행하는 것
        - 사용이 쉽고 도난의 위험도 적으며 위조가 어렵다
        - 생체 인증 대상 : 지문, 홍채/망막, 얼굴, 음성, 정맥 등
    - 기타 인증 방법
        
        
        | 인증 기법 | 내용 |
        | --- | --- |
        | 행위 기반 인증
        (Something You Do) | - 사용자의 행동 정보를 이용해 인증 수행 |
        | 위치 기반 인증
        (Somewhere You Are) | - 인증을 시도하는 위치의 적절성 확인 |
- 보안 솔루션 A
    - 보안 솔루션
        - 보안 솔루션이란 접근 통제, 침입 차단 및 탐지 등을 수행하여 외부로부터의 불법적인 침입을 막는 기술 및 시스템
        - 주요 보안 솔루션
            - 방화벽
            - 침입 탐지 시스템(IDS)
            - 침입 방지 시스템(IPS)
            - 데이터 유출 방지(DLP)
            - 웹 방화벽
            - VPN
            - NAC
            - ESM
    - 방화벽(Firewall)
        - 방화벽은 기업이나 조직 내부의 네트워크와 인터넷 간에 전송되는 정보를 선별하여 수용, 거부, 수정하는 기능을 가진 침입 차단 시스템
        - 내부 네트워크에서 외부로 나가는 패킷은 그대로 통과시키고, 외부에서 내부 네트워크로 들어오는 패킷은 내용을 엄밀히 체크하여 인증된 패킷만 통과시키는 구조
    - 침입 탐지 시스템(IDS; Intrusion Detection System)
        - 침입 탐지 시스템은 컴퓨터 시스템의 비정상적인 사용, 오용, 남용 등을 실시간으로 탐지하는 시스템
        - 오용 탐지(Misuse Detection) : 미리 입력해 둔 공격 패턴이 감지되면 이를 알려준다
        - 이상 탐지(Anomaly Detection) : 평균적인 시스템의 상태를 기준으로 비정상적인 행위나 자원의 사용이 감지되면 이를 알려줌
    - 침입 방지 시스템(IPS; Intrusion Prevention System)
        - 침입 방지 시스템은 비정상적인 트래픽을 능동적으로 차단하고 격리하는 등의 방어 조치를 취하는 보안 솔루션
        - 침입 방지 시스템은 방화벽과 침입 탐지 시스템을 결합한 것
        - 침입 탐지 기능으로 패킷을 하나씩 검사한 후 비정상적인 패킷이 탐지되면 방화벽 기능으로 해당 패킷을 차단
    - 데이터 유출 방지(DLP; Data Leakage/Loss Prevention)
        - 데이터 유출 방지는 내부 정보의 외부 유출을 방지하는 보안 솔루션
        - 사내 직원이 사용하는 PC와 네트워크상의 모든 정보를 검색하고 메일, 메신저, 웹하드, 네트워크 프린터 등의 사용자 행위를 탐지, 통제해 외부로의 유출을 사전에 막는다
    - 웹 방화벽(Web Firewall)
        - 웹 방화벽은 일반 방화벽이 탐지하지 못하는 SQL 삽입 공격, Cross-Site Scripting(XSS) 등의 웹 기반 공격을 방어할 목적으로 만들어진 웹 서버에 특화된 방화벽
        - 웹 관련 공격을 감시하고 공격이 웹 서버에 도달하기 전에 이를 차단
    - VPN(Virtual Private Network, 가상 사설 통신망)
        - VPN은 인터넷 등 통신 사업자의 공중 네트워크와 암호화 기술을 이용하여 사용자가 마치 자신의 전용  회선을 사용하는 것처럼 해주는 보안 솔루션
        - SSL VPN : PC에 VPN Client 프로그램을 설치하여 VPN 서버에 접속하는 방식. 암호화에는 SSL 프로토콜 사용
        - IPSec VPN : VPN 서버가 설치된 각각의 네트워크를 서로 연결하는 방식으로, 암호화를 위해 IPSec 프로토콜을 사용
    - NAC(Network Access Control)
        - NAC은 네트워크에 접속하는 내부 PC의 MAC 주소를 IP 관리 시스템에 등록한 후 일관된 보안 관리 기능을 제공하는 보안 솔루션
        - 내부 PC의 소프트웨어 사용 현황을 관리하여 불법적인 소프트웨어 설치를 방지
    - SIEM(Security Information and Event Management)
        - SIEM은 다양한 장비에서 발생하는 로그 및 보안 이벤트를 통합하여 관리하는 빅 데이터 기반의 보안 솔루션
        - 방화벽, IDS, IPS, 웹 방화벽, VPN 등에서 발생한 로그 및 보안 이벤트를 통합하여 관리함으로써 비용 및 자원을 절약
        - 장기간의 로그 및 보안 이벤트를 수집 및 검색할 수 있는 빅데이터 기반의 통합 로그 수집 시스템

# 프로그래밍 언어 활용

- 데이터 입,출력 A
    - 데이터 입, 출력의 개요
        - 데이터 입, 출력은 키보드로부터 데이터를 입력받아 화면이나 파일로 출력하는 것을 의미
        - C언어의 입,출력 함수 : scanf, printf
        - Java의 입,출력 함수 : Scanner, nextInt, print, printf, println
    - C 문제
        - 6, 4 입력
            
            ```c
            #include <stdio.h>
            main() 
            {
            	int i, j, k;
            	scanf("%d %d, &i, &j);
            	k = i + j;
            	printf("%d\n", k);
            }
            ```
            
            - ⇒ 10
    - Java 문제
        - 4 입력
            
            ```java
            import java.util.Scanner
            public class Test
            {
            	public static void main(String[] args) 
            	{
            		Scanner scan = new Scanner(System.int);
            		int a = scan.nextInt();
            		System.out.printf("a * 3 = %d\n", a * 3);
            		System.out.println("a / 2 = " + (a / 2));
            		System.out.print("a - 1 = " + (a - 1));
            		scan.close();
            	}
            }
            ```
            
            - a * 3 = 12
            a / 2 = 2
            a - 1 = 3
- 제어문 A
    - 제어문의 개요
        - 제어문은 서술된 순서에 따라 무조건 위에서 아래로 실행되는 프로그램의 순서를 변경할 때 사용하는 명령문
    - C 문제
        
        ```c
        #include <stdio.h>
        main() {
        	int score[] = { 86, 53, 95, 76, 61 };
        	char grage;
        	char str[] = "Rank";
        	for(int i = 0; i < 5; i++) {
        		switch (score[i] / 10) {
        		case 10:
        		case 9:
        			grade = 'A';
        			break;
        		case 8:
        			grade = 'B';
        			break;
        		case 7:
        			grade = 'C';
        			break;
        		default: grade = 'F';
        		}
        		if (grade != 'F') 
        		printf("d is %c %s\n", i + 1, 
        					grade, str);
        	}
        }
        ```
        
        - 1 is B Rank
        3 is A Rank
        4 is C Rank
    - Java 문제
        
        ```java
        public class Test {
        	public static void main(String[] args) {
        		String str = "agile";
        		int x[] = { 1, 2, 3, 4, 5 };
        		char y[] = new char[5];
        		int i = 0;
        		while (i < str.length()) {
        			y[i] = str.charAt(i);
        			i++;
        		}
        		for (int p : x) {
        			i--;
        			System.out.print(y[i]);
        			System.out.print(p + " ");
        		}
        	}
        }
        ```
        
        - e1 l2 i3
- 포인터 A
    - 포인터의 개요
        - C언어에서는 변수의 주소를 포인터라고 하고, 포인터를 저장할 수 있는 변수를 포인터 변수라고 한다. 변수의 주소인 포인터는 출력할 수도 있고 포인터가 가리키는 곳에 값을 저장하거나 읽어 오는 등 다양한 조작이 가능하다.
    - C 문제
        
        ```c
        #include <stdio.h>
        main() {
        	int a = 50;
        	int *b = &a;
        	*b = *b + 20;
        	printf("%d, %d\n", a, *b);
        	char *s;
        	s = "gilbut";
        	for(int i = 0; i < 6; i += 2) {
        		printf("%c, ", s[i]);
        		printf("%c, ", *(s + i));
        		printf("s\n", s + i);
        	}
        }
        ```
        
        - 70, 70
        - g, g, gilbut
        l, l, lbut
        u, u, ut
- 구조체 A
    - 구조체의 개요
        - 배열이 자료의 형과 크기가 동일한 변수의 모임이라면 구조체는 자료의 종류가 다른 변수의 모임이라고 할 수 있다.
        - 구조체를 정의한다는 것은 int나 char 같은 자료형을 하나 만드는 것을 의미한다.
        - 구초제 변수를 사용하려면 먼저 정의한 구조체에 대한 변수를 선언해야 한다.
        - 구조체의 멤버는 모든 요소들이 개별적인 이름을 가지고 있으므로 구조체 멤버를 지정할 때는 구조체 변수와 함께 멤버 이름을 지정해야 한다.
    - C 문제
        
        ```c
        #include <stdio.h>
        	struct jsu {
        		char nae[12];
        		int os, db, hab, hhab;
        	};
        
        int main() {
        	struct jsu st[3] = { {"데이터1", 95, 88}, 
        											 {"데이터2", 84, 91},
        											 {"데이터3", 86, 75 } };
        	struct jsu* p;
        	p = &st[0];
        	(p + 1) -> hab = (p + 1) -> os + (p + 2) -> db;
        	(p + 1) -> hhab = (p + 1) -> hab + p -> os + p -> db;
        	printf("%d", (p + 1) -> hab + (p + 1) -> hhab);
        }
        ```
        
        - 501
- 사용자 정의 함수 A
    - 사용자 정의 함수의 개요
        - 사용자 정의 함수는 말 그대로 사용자가 직접 만들어 사용하는 함수다.
    - C 문제
        
        ```c
        #include <stdio.h>
        int factorial(int n);
        
        main() {
        	int (*pf)(int);
        	pf = factorial;
        	printf("%d", pf(3));
        }
        
        int factorial(int n) {
        	if (n <= 1)
        		return 1;
        	else 
        		return n * factorial(n - 1);
        }
        ```
        
        - 6
- Java의 클래스 A
    - Java 클래스의 개요
        - 클래스는 객체 생성을 위한 필드(속성)와 메소드(함수)를 정의하는 설계도로, Java는 아무리 작은 프로그램이라도 클래스를 만들어 사용해야 한다
        - 클래스를 만들어 사용하는 순서는 다음과 같다.
            1. 클래스 이름을 정하고 객체 생성을 위한 필드와 메소드를 정의한다. 이 때 사용하는 명령이 class
            2. 객체를 생성한다. 이 때 사용하는 명령이 new
            3. 생성된 객체들을 이용하여 프로그램을 코딩
    - Java 문제 1
        
        ```java
        class ClassA {
        	int a = 10;
        	int funcAdd(int x, int y) {
        		return x + y + a;
        	}
        
        public class Test {
        	public static void main(String[] args) {
        		int x = 3, y = 6, r;
        		ClassA cal = new ClassA();
        		r = cal.funcAdd(x, y);
        		System.out.print(r);
        	}
        }
        ```
        
        - 19
    - Java 문제 2
        
        ```java
        class ClassA {
        	ClassA() {
        		System.out.print('A');
        		this.prn();
        	}
        	void prn() {
        		System.out.print('B');
        	}
        }
        class ClassB extends ClassA {
        	ClassB() {
        		super();
        		System.out.print('D');
        	}
        	void prn() {
        		System.out.print('E');
        	}
        	void prn(int x) {
        		System.out.print(x);
        	}
        }
        public class Test {
        	public static void main(String[] args) {
        		int x = 7;
        		ClassB cal = new ClassB();
        		cal.prn(x);
        	}
        }
        ```
        
        - AED7
- Java의 활용 A
    - 추상 클래스와 형 변환의 개요
        - 추상 메소드는 자식 클래스에서 재정의해야만 사용할 수 있는 메소드를 의미하며, 이런 메소드를 하나 이상 포함하는 클래스를 추상 클래스라고 한다. 그리고 이렇게 재정의한 메소드를 부모 클래스의 객체 변수를 통해 사용하려면 부모 클래스의 객체 변수를 선언할 때 자식 클래스의 생성자를 이용해야 하는데, 이것을 클래스의 형 변환이라고 한다.
    - Java 문제
        
        ```java
        abstract class Animal {
        	String a = " is animal";
        	abstract void look();
        	void show() {
        		System.out.println("Zoo");
        	}
        }
        class Chicken extends Animal {
        	Chicken() {
        		look();
        	}
        	void look() {
        		System.out.println("Chicken" + a);
        	}
        	void display() {
        		System.out.println("two wings");
        	}
        }
        public class Test {
        	public static void main(String[] args) {
        		Animal a = new Chicken();
        		a.show();
        	}
        }
        ```
        
        - Chicken is animal
        Zoo
- Python의 활용 1 A
    - Python의 개요
        - Python은 객체지향 기능을 지원하는 스크립트 언어로, 다른 언어에 비해 문법이 간단하다는 장점이 있다.
            - 자료형 : 리스트(List), 세트(Set)
            - 입, 출력 함수 : input, print
            - 슬라이스(Slice)
            - Range
    - Python 문제 1
        - xyz321 입력
        
        ```python
        x = input('입력 : ')
        a = [ 'abc123', 'def456', 'ghi789' ]
        a.append(x)
        a.remove('def456')
        print(a[1][-3:], a[2][:-3], sep =',')
        for i in range(3, 6):
        	print(i, end = ' ')
        ```
        
        - 789, xyz
        3 4 5
    - Python 문제 2
        
        ```python
        a = {'apple', 'lemon', 'banana' }
        a.update( {'kiwi', 'banana' } )
        a.remove('lemon')
        a.add('apple')
        for i in a:
        	print("과일명 : %s" %i)
        ```
        
        - 과일명 : apple
        과일명 : banana
        과일명 : kiwi
- Python의 활용 2 A
    - Python 문제 1
        
        ```python
        a = [1, 2, 3, 4, 5]
        x = 100
        if x == 10;
        	a = list(map(lambda num : num + 10, a))
        elif x == 50;
        	a = list(map(lambda num : num + 50, a))
        else:
        	a = list(map(lambda num : num + 100, a))
        print(a)
        ```
        
        - [101, 102, 103, 104, 105]
    - Python 문제 2
        
        ```python
        	class Cls:
        		x, y = 10, 20
        		def chg(self):
        			temp = self.x
        			self.x = self.y
        			self.y = temp
        a = Cls( )
        print(a.x, a.y)
        a.chg()
        print(a.x, a.y)
        ```
        
        - 10 20
        20 10
- 절차적 프로그래밍 언어 D
    - 절차적 프로그래밍 언어
        - 절차적 프로그래밍 언어는 일련의 처리 절차를 정해진 문법에 따라 순서대로 기술하는 언어
        - 프로그램이 실행되는 순서를 중요시
        - 데이터를 중심으로 프로시저를 구현, 프로그램 전체가 유기적으로 연결
        - 자연어에 가까운 단어와 문장으로 구성
        - 과학 계산이나 하드웨어 제어에 주로 사용
    - 절차적 프로그래밍 언어의 종류
        
        
        | 언어 | 특징 |
        | --- | --- |
        | C | - 1972년 미국 벨 연구소의 데니스 리치에 의해 개발
        
        - 시스템 프로그래밍 언어로 널리 사용
        
        - 고급 프로그래밍 언어이면서 저급 프로그램 언어의 특징을 모두 갖춤 
        
        - 이식성이 좋아 컴퓨터 기종에 관계없이 프로그램 작성 가능 |
        | ALGOL | - 수치 계산이나 논리 연산을 위한 과학 기술 계산용 언어
        
        - PASCAL과 C 언어의 모체 |
        | COBOL | - 사무 처리용 언어이다. 
        
        - 영어 문장 형식으로 구성되어 있어 이해와 사용이 쉽다. 
        
        - 4개의 DIVISION으로 구성되어 있다. |
        | FORTRAN | - 과학 기술 계산용 언어이다. 
        
        - 수학과 공학 분야의 공식이나 수식과 같은 형태로 프로그래밍 할 수 있다. |
- 객체지향 프로그래밍 언어 D
    - 객체지향 프로그래밍 언어
        - 객체지향 프로그래밍 언어는 현실 세계의 개체를 기계의 부품처럼 하나의 객체로 만들어, 기계의 부품들을 조립하여 제품을 만들 듯이 소프트웨어를 개발할 때도 객체들을 조립해서 프로그램을 작성하는 기법
        - 프로시저보다는 명령과 데이터로 구성된 객체를 중심으로 하는 프로그래밍 기법
        - 한 프로그램을 다른 프로그램에서 이용할 수 있도록 함
    - 객체지향 프로그래밍 언어의 종류
        
        
        | 언어 | 특징 |
        | --- | --- |
        | JAVA | - 분산 네트워크 환경에 적용 가능
        
        - 멀티스레드 기능을 제공하므로 여러 작업을 동시에 처리 가능
        
        - 운영체제 및 하드웨어에 독립적이며, 이식성이 강함 |
        | C++ | - C 언어에 객체지향 개념을 적용한 언어
        
        - 모든 문제를 객체로 모델링하여 표현 |
        | Smalltalk | - 1세대 객체지향 프로그래밍 언어 중 하나로 순수한 객체지향 프로그래밍 언어
        
        - 최초로 GUI를 제공한 언어 |
- 스크립트 언어 C
    - 스크립트 언어(Script Language)
        - 스크립트 언어는 HTML 문서 안에 직접 프로그래밍 언어를 삽입하여 사용하는 언어
        - 기계로 컴파일되지 않고 별도의 번역기가 소스를 분석하여 동작
        - 게시판 입력, 상품 검색, 회원 가입 등과 같은 데이터베이스 처리 작업을 수행하기 위해 주로 사용
        - 스크립트 언어의 분류
            
            
            | 분류 | 내용 |
            | --- | --- |
            | 서버용 스크립트
            언어 | - 서버에서 해석되어 실행된 후 결과만 클라이언트로 보냄
            
            - 종류 : ASP, JSP, PHP, 파이썬 |
            | 클라이언트용 
            스크립트 언어 | - 클라이언트의 웹 브라우저에서 해석되어 실행 
            
            - 종류 : 자바 스크립트(JAVA Script), VB 스크립트(Visual Basic Script) |
    - 스크립트 언어의 종류
        
        
        | 자바 스크립트
        (JAVA Script) | - 웹 페이지의 동작을 제어하는 데 사용되는 클라이언트용 스크립트 언어
        
        - 클래스 기반의 객체 상속을 지원하여 객체지향 프로그래밍 언어의 성격도 가지고 있다. 
        
        - Prototype Link와 Prototype Object를 통해 프로토타입 개념을 활용할 수 있다.  |
        | --- | --- |
        | VB 스크립트
        (Visual Basic Script) | - 마이크로소프트 사에서 자바 스크립트에 대응하기 위해 제작한 언어
        
        - Active X를 사용하여 마이크로소프트 사의 애플리케이션들을 컨트롤할 수 있다. |
        | ASP
        (Active Server Page) | - 서버 측에서 동적으로 수행되는 페이지를 만들기 위한 언어
        
        - 마이크로소프트 사에서 제작
        
        - Windows 계열에서만 수행 가능한 프로그래밍 언어 |
        | JSP
        (Java Server Page) | - JAVA로 만들어진 서버용 스크립트로
        
        - 다양한 운영체제에서 사용 가능 |
        | PHP
        (Professinoal
        Hypertext
        Preprocessor) | - 서버용 스크립트 언어로, Linux, Unix, Windows 운영체제에서 사용 가능한 서버용 스크립트 언어
        
        - C, Java 등과 문법이 유사하므로 배우기 쉬워 웹 페이지 제작에 많이 사용된다.  |
        | 파이썬
        (Python) | - 귀도 반 로섬(Guido van Rossum)이 발표한 대화형 인터프리터 언어
        
        - 객체지향 기능을 지원하고 플랫폼에 독립적이며 문법이 간단하여 배우기 쉽다.  |
        | 쉘 스크립트 | - Unix/Linux 계열의 Shell에서 사용되는 명령어들의 조합으로 구성된 스크립트 언어
        
        - 쉘 스크립트에서 사용되는 제어문 
          - 선택형 : if, case
          - 반복형 : for, while, until |
        | Basic | - 절차지향 기능을 지원하는 대화형 인터프리터 언어
        
        - 초보자도 쉽게 사용할 수 있는 문법 구조를 가지고 있다. |
- 라이브러리 C
    - 라이브러리
        - 라이브러리는 프로그램을 효율적으로 개발할 수 있도록 자주 사용하는 함수나 데이터들을 미리 만들어 모아 놓은 집합체
        - 자주 사용하는 함수들의 반복적인 코드 작성을 피하기 위해 미리 만들어 놓은 것이며, 필요할 때는 언제든지 호출하여 사용 가능
        - 라이브러리의 분류
            
            
            | 분류 | 내용 |
            | --- | --- |
            | 표준 라이브러리 | - 프로그래밍 언어에 기본적으로 포함되어 있는 라이브러리 
            
            - 여러 종류의 모듈이나 패키지 형태 |
            | 외부 라이브러리 | - 개발자들이 필요한 기능들을 만들어 인터넷 등에 공유해 놓은 라이브러리 
            
            - 외부 라이브러리를 다운받아 설치한 후 사용 |
    - C언어의 대표적인 표준 라이브러리
        - C언어는 라이브러리를 헤더 파일로 제공한다. 각 헤더 파일에는 응용 프로그램 개발에 필요한 함수들이 정리되어 있다.
        - C언어에서 헤더 파일을 사용하려면 ‘#include <stdio.h>’와 같이 iunclude 문을 이용해 선언한 후 사용해야 한다.
            
            
            | 헤더 파일 | 기능 |
            | --- | --- |
            | stdio.h | - 데이터의 입, 출력에 사용되는 기능들을 제공한다.
            
            - 주요 함수 : printf, scanf, tprintf, scanf, fclose, fopen 등 |
            | math.h | - 수학 함수들을 제공한다. 
            
            - 주요 함수 : sqrt, pow, abs 등 |
            | string.h | - 문자열 처리에 사용되는 기능들을 제공한다.
            
            - 주요 함수 : strlen, strcpy, strcmp 등 |
            | stdlib.h | - 자료형 변환, 난수 발생, 메모리 할당에 사용되는 기능들을 제공한다. 
            
            - 주요 함수 : atoi, atof, srand, rand, malloc, free 등 |
            | time.h | - 시간 처리에 사용되는 기능들을 제공한다.
            
            - 주요 함수 : time, clock 등 |
    - Java의 대표적인 표준 라이브러리
        - JAVA는 라이브러리를 패키지에 포함하여 제공하는데, 각 패키지에는 JAVA 응용 프로그램 개발에 필요한 메소드들이 클래스로 정리되어 있다.
        - JAVA에서 패키지를 사용하려면 ‘import java.util’과 같이 import 문을 이용해 선언한 후 사용해야 한다.
        - import로 선언된 패키지 안에 있는 클래스의 메소드를 사용할 때는 클래스와 메소드를 마침표(.)로 구분하여 ‘Math.abs()’와 같이 사용한다.
            
            
            | 패키지 | 기능 |
            | --- | --- |
            | java.lang | - 자바에 기본적으로 필요한 인터페이스, 자료형, 예외 처리 등에 관련된 기능을 제공한다. 
            
            - import문 없이도 사용할 수 있다. 
            
            - 주요 클래스 : String, System, Process, Runtime, Math, Error 등 |
            | java.util | - 날짜 처리, 난수 발생, 복잡한 문자열 처리 등에 관련된 기능을 제공한다.
            
            - 주요 클래스 : Date, Calender, Random, StringTokenizer 등 |
            | java.io | - 파일 입,출력과 관련된 기능 및 프로토콜을 제공한다. 
            
            - 주요 클래스 : InputStream, OuputStream, Reader, Writer 등 |
            | java.net | - 네트워크와 관련된 기능을 제공한다. 
            
            - 주요 클래스 : Socket, URL, InetAddress 등 |
            | java.awt | - 사용자 인터페이스(UI)와 관련된 기능을 제공한다.
            
            - 주요 클래스 : Frame, Panel, Dialog, Button, Checkbox 등 |
    - Python의 대표적인 표준 라이브러리
        - Python에서 라이브러리를 사용하려면 ‘import random’과 같이 선언하고, 사용할 때는 마침표(.)로 구분하여 ‘random.choice()’와 같이 사용
            
            
            | 클래스 | 기능 |
            | --- | --- |
            | 내장 함수 | - Python에 기본적인 인터페이스로, import문이나 클래스명 없이 사용 가능 
            
            - 주요 메소드 : abs(), slice(), pow(), print() 등 |
            | os | - 운영체제와 상호 작용하기 위한 기능을 제공 
            
            - 주요 메소드 : getcwd(), chdir(), system() 등 |
            | re | - 고급 문자열 처리를 위한 기능 제공 
            
            - 주요 메소드 : findall(), sub() 등 |
            | math | - 복잡한 수학 연산을 위한 기능 제공 
            
            - 주요 메소드 : cos(), log() 등 |
            | random | - 무작위 선택을 위한 기능 제공 
            
            - 주요 메소드 : choice(), sample(), variance() 등 |
            | statistics | - 날짜와 시간 조작을 위한 기능 제공 
            
            - 주요 메소드 : today(), date(), strftime() 등 |
            | datetime |  |
- 예외 처리 D
    - 예외 처리(Exception Handling)
        - 예외 처리는 예외가 발생했을 때 프로그래머가 해당 문제에 대비해 작성해 놓은 처리 루틴이 수행되도록 하는 것
        - 예외가 발생했을 때 일반적인 처리 루틴은 프로그램을 종료시키거나 로그(Log)를 남기는 것
        - C++, Ada, Java, 자바스크립트와 같은 언어에는 예외 처리 기능이 내장되어 있다
        - 필요한 경우 조건문을 이용해 예외 처리 루틴을 작성
        - 대표적인 예외의 원인
            - 컴퓨터 하드웨어 문제
            - 운영체제의 설정 실수
            - 라이브러리 손상
            - 사용자의 입력 실수
            - 받아들일 수 없는 연산
            - 할당하지 못하는 기억장치 접근
    - Java의 예외 처리
        - JAVA는 잘못된 동작이나 결과에 영향을 줄 수 있는 예외를 객체로 취급하며, 예외와 관련된 클래스를 java.lang 패키지에서 제공한다.
        - JAVA에서는 try ~ catch 문을 이용해 예외를 처리한다.
        - try 블록 코드를 수행하다 예외가 발생하면 예외를 처리하는 catch 블록으로 이동하여 예외 처리 코드를 수행하므로 예외가 발생한 이후의 코드는 실행되지 않는다.
        - catch 블록에서 선언한 변수는 해당 catch 블록에서만 유효하다.
        - try ~ catch 문 안에 또 다른 try ~ catch 문을 포함할 수 있다.
        - try ~ catch 문 안에서는 실행 코드가 한 줄이라도 중괄호({ })를 생략할 수 없다.
    - JAVA의 주요 예외 객체
        
        
        | 예외 객체 | 발생 원인 |
        | --- | --- |
        | ClassNotFoundException | 클래스를 찾지 못한 경우 |
        | NoSuchMethodException | 메소드를 찾지 못한 경우 |
        | FileNotFoundException | 파일을 찾지 못한 경우 |
        | InterruptedIOException | 입,출력 처리가 중단된 경우 |
        | ArtihmeticException | 0으로 나누는 등의 산술 연산에 대한 예외가 발생한 경우 |
        | IIegalArgumentException | 잘못된 인자를 전달한 경우 |
        | NumberFormatException | 숫자 형식으로 변환할 수 없는 문자열을 숫자 형식으로 변환한 경우 |
        | ArrayIndexOutOfBoundsException | 배열의 범위를 벗어난 접근을 시도한 경우 |
        | NegativeArraySizeException | 0보다 작은 값으로 배열의 크기를 지정한 경우 |
        | NullPointerException | 존재하지 않는 객체를 참조한 경우 |

# 응용 SW 기초 기술 활용

- 운영체제의 개념 C
    - 운영체제(OS; Operating System)
        - 운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임
        - 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로 동작하는 시스템 소프트웨어의 일종
        - 다른 응용 프로그램이 유용한 작업을 할 수 있도록 환경을 제공
        - 운영체제는 프로세스, 기억장치, 주변장치, 파일 등을 관리하는 기능을 수행
        - 운영체제의 종류 : Windows, UNIX, LINUX, MacOS, MS-DOS 등
    - 운영체제의 목적
        - 운영체제의 목적에는 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등이 있다.
            
            
            | 처리 능력(Throughput) | 일정 시간 내에 시스템이 처리하는 일의 양 |
            | --- | --- |
            | 반환 시간
            (Turn Around Time) | 시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 걸린 시간 |
            | 사용 가능도(Availability) | 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도 |
            | 신뢰도(Reliability) | 시스템이 주어진 문제를 정확하게 해결하는 정도 |
    - 운영체제의 기능
        - 프로세서(처리기, Processor), 기억장치(주기억장치, 보조기억장치), 입,출력 장치, 파일 및 정보 등의 자원을 관리
        - 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공
        - 사용자와 시스템 간의 편리한 인터페이스를 제공
        - 시스템의 각종 하드웨어와 네트워크를 관리, 제어
        - 데이터를 관리하고, 데이터 및 자원의 공유 기능을 제공
- 운영체제의 종류 A
    - Windows
        - Windows는 1990년대 마이크로소프트(Microsoft) 사가 개발한 운영체제
        - Windows의 주요 특징
            
            
            | 특징 | 설명 |
            | --- | --- |
            | 그래픽 사용자 인터페이스
            (GUI; Graphic User
            Interface) | 키보드로 명령어를 직접 입력하지 않고, 마우스로 아이콘이나 메뉴를 선택하여 모든 작업을 수행하는 방식 |
            | 선점형 멀티태스킹
            (Preemptive
            Multi-Tasking) | 동시에 여러 개의 프로그램을 실행하는 멀티태스킹을 하면서 운영체제가 각 작업의 CPU 이용 시간을 제어하여 응용 프로그램 실행중 문제가 발생하면 해당 프로그램을 강제 종료시키고 모든 시스템 자원을 반환하는 바식 |
            | PnP(Plug and Play,
            자동 감지 기능) | 컴퓨터 시스템에 프린터나 사운드 카드 등의 하드웨어를 설치했을 때, 해당 하드웨어를 사용하는 데 필요한 시스템 환경을 운영체제가 자동으로 구성해 주는 기능 |
            | OLE
            (Object Linking and
            Embedding) | 다른 여러 응용 프로그램에서 작성된 문자나 그림 등의 개체(Object)를 현재 작성 중인 문서에 자유롭게 연결(Linking)하거나 삽입(Embeddin)하여 편집할 수 있게 하는 기능 |
            | 255자의 긴 파일명 | \ / * ? “ <> | 를 제외한 모든 문자 및 공백을 사용하여 최대 255자까지 파일 이름을 지정 가능 |
            | SIngle-User 시스템 | 컴퓨터 한 대를 한 사람만이 독점해서 사용 |
    - UNIX
        - UNIX는 1960년대 AT&T 벨(Bell) 연구소, MIT, General Electirc이 공동 개발한 운영체제
        - 시분할 시스템(Time Sharing System)을 위해 설계된 대화식 운영체제
        - 소스가 공개된 개방형 시스템(Open System)
        - 대부분 C언어로 작성되어 있어 이식성이 높으며 장치, 프로세스 간의 호환성이 높다
        - 다중 사용자(Multi-User), 다중 작업(Multi-Tasking)을 지원한다
        - 트리(Tree) 구조의 파일 시스템
    - UNIX 시스템의 구성
        
        
        | 구성 요소 | 설명 |
        | --- | --- |
        | 커널(Kernel) | - 하드웨어를 보호하고, 프로그램과 하드웨어 간의 인터페이스 역할 
        
        - UNIX의 가장 핵심적인 부분
        
        - 프로세스(CPU 스케줄링) 관리, 기억장치 관리, 파일 관리, 입,출력 관리, 프로세스간 통신, 데이터 전송 및 변환 등 여러가지 기능을 수행 |
        | 쉘(Shell) | - 사용자의 명령어를 인식하여 프로그램을 호출하고 명령을 수행하는 명령어 해석기 
        
        - 시스템과 사용자 간의 인터페이스를 담당 
        
        - 종류 : Bourne Shell, C Shell, Korn Shell |
        | 유틸리티 프로그램
        (Utility Program) | - 일반 사용자가 작성한 응용 프로그램을 처리하는 데 사용 
        
        - DOS에서의 외부 명령어에 해당
        
        - 종류 : 에디터, 컴파일러, 인터프리터, 디버거 등 |
    - LINUX
        - LINUX는 1991년 리누스 토발즈(Linus Torvalds)가 UNIX를 기반으로 개발한 운영체제
        - 프로그램 소스 코드가 무료 공개되어 있기 때문에 프로그래머가 원하는 기능을 추가 가능
        - 다양한 플랫폼에 설치하여 사용 가능하며, 재배포 가능
        - UNIX와 완벽하게 호환
        - 대부분의 특징이 UNIX와 동일
    - MacOS
        - MacOS는 1980년대 애플(Apple)사가 UNIX를 기반으로 개발한 운영체제
        - 아이맥(iMac)과 맥북(MacBook)등 애플 사에서 생산하는 제품에서만 사용 가능
        - 드라이버 설치 및 install과 uninstall의 과정이 단순
    - Android
        - Android는 구글(Google)사에서 개발한 리눅스 커널 기반의 개방형 모바일 운영체제
        - 모든 코드가 공개된 개방형 소프트웨어
        - 자바와 코틀린으로 애플리케이션 작성
        - 스마트폰 등의 휴대용 장치에서 주로 사용
    - iOS
        - iOS는 애플(Apple)사에서 개발한 유닉스 기반의 모바일 운영체제
        - 아이폰, 아이팟 터치, 아이패드 등에 내장
        - 애플사 고유의 모바일 운영체제로 타사 제품은 iOs를 탑재 불가능
- 기억장치 관리 C
    - 기억장치의 관리 전략
        - 기억장치의 관리 전략은 보조기억장치의 프로그램이나 데이터를 주기억장치에 적재시키는 시기, 적재 위치 등을 지정하여 한정된 주기억장치의 공간을 효율적으로 사용하기 위한 것
        - 종류
            - 반입(Fetch) 전략
            - 배치(Placement) 전략
            - 교체(Replacement) 전략
    - 반입(Fetch) 전략
        - 반입 전략은 보조기억장치에 보관중인 프로그램이나 데이터를 언제 주기억장치로 적재할 것인지를 결정하는 전략
            
            
            | 기법 | 내용 |
            | --- | --- |
            | 요구 반입
            (Demand Fetch) | 실행중인 프로그램이 특정 프로그램이나 데이터 등의 참조를 요구할 때 적재 |
            | 예상 반입
            (Anticipatory Fetch) | 실행중인 프로그램에 의해 참조될 프로그램이나 데이터를 미리 예상하여 적재 |
    - 배치(Placement) 전략
        - 배치 전략은 새로 반입되는 프로그램이나 데이터를 주기억장치의 어디에 위치시킬 것인지를 결정하는 전략
            
            
            | 기법 | 내용 |
            | --- | --- |
            | 최초 적합
            (First Fit) | 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 |
            | 최적 적합
            (Best Fit) | 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치시키는 방법  |
            | 최악 적합
            (Worst Fit) | 프로그램이나 데이터가 들어갈 수 있는 크기의 빈 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치시키는 방법 |
            - 단편화 : 주기억장치의 분할된 영역에 프로그램이나 데이터를 할당할 경우, 분할된 영역이 프로그램이나 데이터보다 작거나 커서 생기는 빈 기억 공간
                - 내부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 크기 때문에 프로그램이 할당된 후 사용되지 않고 남아 있는 빈 공간
                - 외부 단편화 : 분할된 영역이 할당될 프로그램의 크기보다 작기 때문에 프로그램이 할당될 수 없어 사용되지 않고 빈 공간으로 남아있는 분할된 전체 영역
    - 교체(Replacement) 전략
        - 교체 전략은 주기억장치의 모든 영역이 이미 사용중인 상태에서 새로운 프로그램이나 데이터를 주기억장치에 배치하려고 할 때, 이미 사용되고 있는 영역 중에서 어느 영역을 교체하여 사용할 것인지를 결정하는 전략
        - 종류 : FIFO, OPT, LRU, LFU, NUR, SCR 등
- 가상기억장치 구현 방법 C
    - 가상기억장치(Virtual Memory)
        - 가상기억장치는 보조기억장치의 일부를 주기억장치처럼 사용하는 것으로, 용량이 작은 주기억장치를 마치 큰 용량을 가진 것처럼 사용하는 기법
        - 프로그램을 여러 개의 작은 블록 단위로 나누어 가상기억장치에 보관해 놓고, 프로그램 실행 시 요구되는 블록만 주기억장치에 불연속적으로 할당하여 처리
        - 주기억장치의 이용률과 다중 프로그래밍의 효율을 높일 수 있다
        - 블록 단위로 나누어 사용하므로 연속 할당 방식에서 발생할 수 있는 단편화를 해결할 수 있다
        - 가상기억장치의 일반적인 구현 방법 : 페이징 기법, 세그먼테이션 기법
    - 페이징(Paging) 기법
        - 페이징 기법은 가상기억장치에 보관되어 있는 프로그램과 주기억장치의 영역을 동일한 크기로 나눈 후 나눠진 프로그램을 동일하게 나눠진 주기억장치의 영역에 적재시켜 실행하는 기법
        - 프로그램을 일정한 크기로 나눈 단위를 페이지(Page)라고 하고, 페이지 크기로 일정하게 나누어진 주기억장치의 단위를 페이지 프레임(Page Frame)이라고 한다
        - 외부 단편화는 발생하지 않으나 내부 단편화는 발생할 수 있다
        - 주소 변환을 위해 페이지의 위치 정보를 가지고 있는 페이지 맵 테이블(Page Map Table)이 필요
        - 페이지 맵 테이블 사용으로 비용이 증가하고, 처리 속도가 감소
    - 세그먼테이션(Segmentation) 기법
        - 세그먼테이션 기법은 가상기억장치에 보관되어 있는 프로그램을 다양한 크기의 논리적인 단위로 나눈 후 주기억장치에 적재시켜 실행시키는 기법
        - 프로그램을 배열이나 함수 등과 같은 논리적인 크기로 나눈 단위를 세그먼트(Segment)라고 하며, 각 세그먼트는 고유한 이름과 크기를 갖는다
        - 세그먼테이션 기법을 이용하는 궁극적인 이유는 기억공간을 절약하기 위해서이다
        - 주소 변환을 위해 세그먼트가 존재하는 위치 정보를 가지고 있는 세그먼트 맵 테이블(Segment Map Table)이 필요하다
        - 내부 단편화는 발생하지 않으나 외부 단편화는 발생할 수 있다
- 페이지 교체 알고리즘 B
    - 페이지 교체 알고리즘
        - 페이지 부재(Page Fault)가 발생하면 가상기억장치에서 필요한 페이지를 찾아 주기억장치에 적재해야 하는데, 이때 주기억장치의 모든 페이지 프레임이 사용중이면 어떤 페이지 프레임을 선택하여 교체할 것인지를 결정하는 기법이 페이지 교체 알고리즘
        - 종류 : OPT, FIFO, LRU, LFU, NUR, SCR 등
    - OPT(OPTimal replacement, 최적 교체)
        - OPT는 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 기법
        - 벨레이디(Belady)가 제안
        - 페이지 부재 횟수가 가장 적게 발생하는 가장 효율적인 알고리즘
    - FIFO(First In First Out)
        - FIFO는 각 페이지가 주기억장치에 적재될 때마다 그때의 시간을 기억시켜 가장 먼저 들어와서 가장 오래 있었던 페이지를 교체하는 기법
        - 이해하기 쉽고, 프로그래밍 및 설계가 간단
    - LRU(Least Recently Used)
        - LRU는 최근에 가장 오랫동안 사용하지 않은 페이지를 교체
        - 각 페이지마다 계수기(Counter)나 스택(Stack)을 두어 현시점에서 가장 오랫동안 사용하지 않은, 즉 가장 오래전에 사용된 페이지를 교체
    - LFU(Least Frequently Used)
        - LFU는 사용 빈도가 가장 적은 페이지를 교체하는 기법
        - 활발하게 사용되는 페이지는 사용 횟수가 많아 교체되지 않고 사용
    - NUR(Not Used Recenty)
        - NUR은 LRU와 비슷한 알고리즘으로, 최근에 사용하지 않은 페이지를 교체하는 기법
        - 최근에 사용되지 않은 페이지는 향후에도 사용되지 않을 가능성이 높다는 것을 전제로 LRU에서 나타나는 시간적인 오버헤드를 줄일 수 있다
        - 최근의 사용 여부를 확인하기 위해 각 페이지마다 두 개의 비트, 즉 참조 비트(Reference Bit)와 변형 비트(Modified Bit, Dirty Bit)가 사용된다.
    - SCR(Second Chance Replacement, 2차 기회 교체)
        - SCR은 가장 오랫동안 주기억장치에 있던 페이지 중 자주 사용되는 페이지의 교체를 방지하기 위한 기법
        - FIFO 기법의 단점을 보완하는데 사용
- 가상기억장치 기타 관리 사항 B
    - 페이지 크기
        - 페이징 기법을 사용하면 프로그램을 페이지 단위로 나누게 되는데, 페이지의 크기에 따라 시스템에 미치는 영향이 다르다
            
            
            | 페이지 크기가
            작을 경우 | - 페이지 단편화가 감소되고, 한 개의 페이지를 주기억장치로 이동 시키는 시간이 감소 
            
            - 불필요한 내용이 주기억장치에 적재될 확률이 적으므로 효율적인 워킹 셋 유지 가능 
            
            - 페이지 정보를 갖는 페이지 맵 테이블의 크기가 커지고, 매핑 속도가 늦어짐
            
            - 디스크 접근 횟수가 많아져서 전체적인 입, 출력 시간은 늘어남  |
            | --- | --- |
            | 페이지 크기가
            클 경우 | - 페이지 정보를 갖는 페이지 맵 테이블의 크기가 작아지고, 매핑 속도가 빨라짐
            
            - 디스크 접근 횟수가 줄어들어 전체적인 입, 출력의 효율성이 증가 
            
            - 페이지 단편화가 증가되고, 한 개의 페이지를 주기억장치로 이동시키는 시간이 늘어남  |
    - Locality
        - Locality(국부성, 지역성, 구역성, 국소성)는 프로세스가 실행되는 동안 주기억장치를 참조할 때 일부 페이지만 집중적으로 참조하는 성질이 있다는 이론
        - 스래싱을 방지하기 위한 워킹 셋 이론의 기반
        - 가상기억장치 관리와 캐시 메모리 시스템의 이론적인 근거
        - 데닝(Denning) 교수에 의해 Locality 개념이 증명
        - Locality의 종류
            
            
            | 시간 구역성
            (Temporal Locality) | 프로세스가 실행되면서 하나의 페이지를 일정 시간 동안 집중적으로 액세스하는 현상 |
            | --- | --- |
            | 공간 구역성
            (Spatial Locality) | 프로세스 실행 시 일정 위치의 페이지를 집중적으로 액세스하는 현상 |
    - 워킹 셋(Working Set)
        - 워킹 셋은 프로세스가 일정 시간 동안 자주 참조하는 페이지들의 집합
        - 데닝(Denning)이 제안한 프로그램의 움직임에 대한 모델로, 프로그램의 Locality 특징을 이용
        - 자주 참조되는 워킹 셋을 주기억장치에 상주시킴으로써 페이지 부재 및 페이지 교체 현상이 줄어들어 프로세스의 기억장치 사용이 안정
    - 스래싱(Thrashing)
        - 스레싱은 프로세스의 처리 시간보다 페이지 교체에 소요되는 시간이 더 많아지는 현상
        - 다중 프로그래밍 시스템이나 가상기억장치를 사용하는 시스템에서 하나의 프로세스 수행 과정 중에 자주 페이지 부재(Page Fault)가 발생함으로써 나타나며, 전체 시스템의 성능이 저하된다
        - 다중 프로그래밍의 정도가 높아짐에 따라 CPU의 이용률은 어느 특정 시점까지는 높아지지만, 다중 프로그래밍의 정도가 더욱 커지면 스래싱이 나타나고, CPU의 이용률은 급격히 감소하게 된다
- 프로세스의 개요 B
    - 프로세스(Process)
        - 프로세스는 일반적으로 프로세서에 의해 처리되는 사용자 프로그램, 시스템 프로그램, 즉 실행중인 프로그램을 의미
        - 프로세스는 다음과 같이 여러 가지로 정의 가능
            - PCB를 가진 프로그램
            - 실기억장치에 저장된 프로그램
            - 프로세서가 할당되는 실체로서, 디스패치가 가능한 단위
            - 프로시저가 활동중인 것
            - 비동기적 행위를 일으키는 주체
            - 지정된 결과를 얻기 위한 일련의 계통적 동작
            - 목적 또는 결과에 따라 발생되는 사건들의 과정
            - 운영체제가 관리하는 실행 단위
    - PCB(Process Control Block, 프로세스 제어 블록)
        - PCB는 운영체제가 프로세스에 대한 중요한 정보를 저장해 놓는 곳
        - 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB는 제거
        - PCB에 저장되어 있는 정보
            - 프로세스의 현재 상태
            - 포인터
            - 프로세스 고유 식별자
            - 스케줄링 및 프로세스의 우선순위
            - CPU 레지스터 정보
            - 주기억장치 관리 정보
            - 입,출력 상태 정보
            - 계정 정보
    - 프로세스 상태 전이
        - 프로세스 상태 전이는 프로세스가 시스템 내에 존재하는 동안 프로세스의 상태가 변하는 것이다.
            
            ![Untitled](시나공_필기_2권/Untitled%208.png)
            
            | 상태 | 내용 |
            | --- | --- |
            | 제출(Submit) | 작업을 처리하기 위해 사용자가 작업을 시스템에 제출한 상태 |
            | 접수(Hold) | 제출된 작업이 스풀 공간인 디스크의 할당 위치에 저장된 상태 |
            | 준비(Ready) | 프로세스가 프로세서를 할당받기 위해 기다리고 있는 상태 |
            | 실행(Run) | 준비상태 큐에 있는 프로세스가 프로세서를 할당받아 실행되는 상태 |
            | 대기(Wait),
            블록(Block) | 프로세스에 입,출력 처리가 필요하면 현재 실행 중인 프로세스가 중단되고, 입, 출력 처리가 완료될 때까지 대기하고 있는 상태 |
            | 종료
            (Terminated, Exit) | 프로세스의 실행이 끝나고 프로세스 할당이 해제된 상태 |
    - 프로세스 상태 전이 관련 용어
        
        
        | 용어 | 내용 |
        | --- | --- |
        | Dispatch | 준비 상태에서 대기하고 있는 프로세스 중 하나가 프로세서를 할당받아 실행 상태로 전이되는 과정  |
        | Wake Up | 입,출력 작업이 완료되어 프로세스가 대기 상태에서 준비 상태로 전이 되는 과정 |
        | Spooling | 입,출력장치의 공유 및 상대적으로 느린 입,출력장치의 처리 속도를 보완하고 다중 프로그래밍 시스템의 성능을 향상시키기 위해 입,출력할 데이터를 직접 입,출력장치에 보내지 않고 나중에 한꺼번에 입,출력하기 위해 디스크에 저장하는 과정 |
        | 교통량 제어기
        (Traffic Controller) | 프로세스의 상태에 대한 조사와 통보 담당 |
    - 스레드(Thread)
        - 스레드는 시스템의 여러 자원을 할당받아 실행하는 프로그램의 단위 또는 프로세스 내에서의 작업 단위로 사용
        - 하나의 프로세스에 하나의 스레드가 존재하는 경우에는 단일 스레드, 하나 이상의 스레드가 존재하는 경우에는 다중 스레드라고 한다
        - 프로세스의 일부 특성을 갖고 있기 때문에 경량(Light Weight) 프로세스라고도 한다
        - 스레드 기반 시스템에서 스레드는 독립적인 스케줄링의 최소 단위로써 프로세스의 역할을 담당
- 스케줄링 D
    - 스케줄링(Scheduling)
        - 스케줄링은 프로세스가 생성되어 실행될 때 필요한 시스템의 여러 자원을 해당 프로세스에게 할당하는 작업
        - 프로세스가 생성되어 완료될 때까지 프로세스는 여러 종류의 스케줄링 과정을 거친다
        - 스케줄링의 종류
            
            
            | 장기 스케줄링 | 어떤 프로세스가 시스템의 자원을 차지할 수 있도록 할 것인가를 결정하여 준비상태 큐로 보내는 작업 |
            | --- | --- |
            | 중기 스케줄링 | 어떤 프로세스들이 CPU를 할당받을 것인지 결정하는 작업 |
            | 단기 스케줄링 | 프로세스가 실행되기 위해 CPU를 할당받는 시기와 특정 프로세스를 지정하는 작업 |
    - 스케줄링의 목적
        
        
        | 목적 | 내용 |
        | --- | --- |
        | 공정성 | 모든 프로세스에 공정하게 할당 |
        | 처리율 증가 | 단위 시간당 프로세스를 처리하는 비율을 증가 |
        | CPU 이용률 증가 | CPU가 순수하게 프로세스를 실행하는 데 사용되는 시간 비율을 증가 |
        | 우선순위 제도 | 우선순위가 높은 프로세스를 먼저 실행 |
        | 오버헤드 최소화 | 오버헤드를 최소화 |
        | 응답 시간 최소화 | 작업을 지시하고, 반응하기 시작하는 시간을 최소화  |
        | 반환 시간 최소화 | 프로세스를 제출한 시간부터 실행이 완료될 때까지 걸리는 시간을 최소화 |
        | 대기 시간 최소화 | 프로세스가 준비상태 큐에서 대기하는 시간을 최소화 |
        | 균형 있는 자원 사용 | 메모리, 입, 출력장치 등의 자원을 균형 있게 사용 |
        | 무한 연기 회피 | 자원을 사용하기 위해 무한정 연기되는 상태를 회피 |
    - 비선점(Non-Preemptive) 스케줄링
        - 비선점 스케줄링은 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
        - 프로세스가 CPU를 할당받으면 해당 프로세스가 완료될 때까지 CPU를 사용
        - 프로세스 응답 시간의 예측이 용이
        - 일괄 처리 방식에 적합
        - 종류 : FCFS, SJF, 우선순위, HRN, 기한부 등
    - 선점(Preemptive) 스케줄링
        - 선점 스케줄링은 하나의 프로세스가 CPU를 할당받아 실행하고 있을 때 우선 순위가 높은 다른 프로세스가 CPU를 강제로 빼앗아 사용할 수 있는 스케줄링 기법
        - 우선순위가 높은 프로세스를 빠르게 처리 가능
        - 주로 빠른 응답 시간을 요구하는 대화식 시분할 시스템에 사용
        - 많은 오버헤드(Overhead)를 초래
        - 종류 : Round Robin, SRT, 선점 우선순위, 다단계 큐, 다단계 피드백 큐 등
- 주요 스케줄링 알고리즘 A
    - FCFS(First Come First Service, 선입 선출) = FIFO(First In First Out)
        - FCFS는 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
        - 가장 간단한 알고리즘
    - SJF(Shortest Job First, 단기 작업 우선)
        - SJF는 준비상태 큐에서 기다리고 있는 프로세스들 중에서 실행 시간이 가장 짧은 프로세스에게 먼저 CPU를 할당하는 기법
        - 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘
    - HRN(Highest Response-ratio Next)
        - HRN은 대기 시간과 서비스(실행) 시간을 이용하는 기법
        - 실행 시간이 긴 프로세스에 불리한 SJF 기법을 보완하기 위한 것
        - 우선순위를 계산하여 그 숫자가 가장 높은 것부터 낮은 순으로 우선순위 부여
        - 우선 순위 계산식
            - (대기 시간 + 서비스 시간) / 서비스 시간
    - RR(Round Robin)
        - RR은 각 프로세스를 시간 할당량(Time Slice, Quantum) 동안만 실행한 후 실행이 완료되지 않으면 다음 프로세스에게 CPU를 넘겨주는 기법
        - 시분할 시스템(Time Sharing System)을 위해 고안된 방식으로, 할당되는 시간의 크기가 작으면 작은 프로세스들에게 유리
        - 할당되는 시간이 클 경우 FCFS 기법과 같아지고, 할당되는 시간이 작을 경우 문맥 교환 및 오버헤드가 자주 발생되어 요청된 작업을 신속히 처리할 수 없다
    - SRT(Shortest Remaining Time)
        - SRT는 현재 실행중인 프로세스의 남은 시간과 준비상태 큐에 새로 도착한 프로세스의 실행 시간을 비교하여 가장 짧은 실행 시간을 요구하는 프로세스에게 CPU를 할당하는 기법
        - 시분할 시스템에 유용하며, 준비상태 큐에 있는 각 프로세스의 실행 시간을 추적하여 보유하고 있어야 하므로 오버헤드가 증가한다
- 환경 변수 C
    - 환경 변수(Environment Variable)
        - 환경 변수란 시스템 소프트웨어의 동작에 영향을 미치는 동적인 값들의 모임
        - 환경 변수는 변수명과 값으로 구성
        - 환경 변수는 시스템의 기본 정보를 저장
        - 환경 변수는 자식 프로세스에 상속
        - 환경 변수는 시스템 전반에 걸쳐 적용되는 시스템 환경 변수와 사용자 계정 내에서만 적용되는 사용자 환경 변수로 구분
    - Windows의 주요 환경 변수
        - Windows에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞뒤에 ‘%’를 입력해야 한다
        - Windows에서 set을 입력하면 모든 환경 변수와 값을 출력한다
            
            
            | 환경 변수 | 용도 |
            | --- | --- |
            | %ALLUSERPROFILE% | 모든 사용자의 프로필이 저장된 폴더 |
            | %APPDATA% | 설치된 프로그램의 필요 데이터가 저장된 폴더 |
            | %ComSpec% | 기본 명령 프롬프트로 사용할 프로그램명 |
            | %HOMEDRIVE% | 로그인한 계정의 정보가 저장된 드라이브 |
            | %HOMEPATH% | 로그인한 계정의 기본 폴더 |
            | %LOGOSERVER% | 로그인한 계정이 접속한 서버명 |
            | %PATH% | 실행 파일을 찾는 경로 |
            | %PATHEXT% | cmd에서 실행할 수 있는 파일의 확장자 목록 |
            | %PROGRAMFILES% | 기본 프로그램의 설치 폴더 |
            | %SYSTEMDRIVE% | Windows가 부팅된 드라이브 |
            | %SYSTEMROOT% | 부팅된 운영체제가 들어 있는 폴더 |
            | %TEMP% 또는 %TMP% | 임시 파일이 저장되는 폴더 |
            | %USERDOMAIN% | 로그인한 시스템의 도메인명 |
            | %USERNAME% | 로그인한 계정 이름 |
            | %USERPROFILE% | 로그인한 유저의 프로필이 저장된 폴더명 |
    - UNIX / LINUX의 주요 환경 변수
        - UNIX나 LINUX에서 환경 변수를 명령어나 스크립트에서 사용하려면 변수명 앞에 ‘$’을 입력해야 한다
        - UNIX나 LINUX에서는 set, env, printenv, setenv 중 하나를 입력하면 모든 환경 변수와 값을 표시한다
            
            
            | 환경 변수 | 용도 |
            | --- | --- |
            | $DISPLAY | 현재 X 윈도 디스플레이 위치 |
            | $HOME | 사용자의 홈 디렉터리 |
            | $LANG | 프로그램 사용 시 기본적으로 지원되는 언어 |
            | $MAIL | 메일을 보관하는 경로 |
            | $PATH | 실행 파일을 찾는 경로 |
            | $PS1 | 쉘 프롬프트 정보 |
            | $PWD | 현재 작업하는 디렉터리 |
            | $TERM | 로긴 터미널 타입 |
            | $USER | 사용자의 이름 |
- 운영체제 기본 명령어 B
    - Windows 기본 명령어
        
        
        | 명령어 | 기능 |
        | --- | --- |
        | DIR | 파일 목록을 표시한다 |
        | COPY | 파일을 복사한다 |
        | DEL | 파일을 삭제한다 |
        | TYPE | 파일의 내용을 표시한다 |
        | REN | 파일의 이름을 변경한다 |
        | MD | 디렉터리를 생성한다 |
        | CD | 디렉터리의 위치를 변경한다 |
        | CLS | 화면의 내용을 지운다 |
        | ATTRIB | 화면의 속성을 변경한다 |
        | FIND | 파일을 찾는다 |
        | CHKDSK | 디스크 상태를 점검한다 |
        | FORMAT | 디스크 표면을 트랙과 섹터로 나누어 초기화한다. |
        | MOVE | 파일을 이동한다 |
    - UNIX / LINUX 기본 명령어
        
        
        | 명령어 | 기능 |
        | --- | --- |
        | cat | 파일 내용을 화면에 표시한다 |
        | cd | 디렉터리의 위치를 변경 |
        | chmod | 파일의 보호 모드를 설정하여 파일의 사용 허가 지정 |
        | chown | 파일 소유자와 그룹 변경 |
        | cp | 파일 복사 |
        | rm | 파일을 삭제한다 |
        | find | 파일을 찾는다  |
        | fsck | 파일 시스템을 검사하고 보수한다 |
        | kill | PID(프로세스 고유 번호)를 이용하여 프로세스 종료 |
        | fork | 새로운 프로세스를 생성한다(하위 프로세스 호출, 프로세스 복제 명령) |
        | killall | 프로세스의 이름을 이용하여 프로세스 종료 |
        | ls | 디렉터리 내의 파일 목록을 확인한다 |
        | mkdir | 디렉터리 생성 |
        | rmdir | 디렉터리 삭제 |
        | mv | 파일을 이동 |
        | ps | 현재 실행중인 프로세스 표시 |
        | pwd | 현재 작업중인 디렉터리 경로를 화면에 표시 |
        | top | 시스템의 프로세스와 메모리 사용 현황을 표시 |
        | who | 현재 시스템에 접속해 있는 사용자 표시 |
- 인터넷 A
    - 인터넷(Internet)
        - 인터넷이란 TCP/IP 프로토콜을 기반으로 하여 전 세계 수많은 컴퓨터와 네트워크들이 연결된 광범위한 컴퓨터 통신망
        - 인터넷에 연결된 모든 컴퓨터는 고유한 IP 주소를 갖는다
    - IP 주소(Internet Protocol Address)
        - IP 주소는 인터넷에 연결된 모든 컴퓨터 자원을 구분하기 위한 고유한 주소
        - 8비트씩 4부분, 총 32비트로 구성
        - IP 주소는 네트워크 부분의 길이에 따라 A클래스부터 E클래스까지 5단계로 구성
            
            ![Untitled](시나공_필기_2권/Untitled%209.png)
            
    - 서브넷팅(Subnettin)
        - 서브네팅은 할당된 네트워크 주소를 다시 여러 개의 작은 네트워크로 나누어 사용하는 것
        - 4바이트의 IP 주소 중 네트워크 주소와 호스트 주소를 구분하기 위한 비트를 서브넷 마스크(Subnet Mask)라고 하며, 이를 변경하여 네트워크 주소를 여러 개로 분할하여 사용
        - 서브넷 마스크는 각 클래스마다 다르게 사용
    - IPv6(internet Protocol version 6)
        - IPv6는 현재 사용하고 있는 IP 주소 체계인 IPv4의 주소 부족 문제를 해결하기 위해 개발
        - 128비트의 긴 주소를 사용하여 주소 부족 문제 해결 가능
        - IPv4에 비해 자료 전송 속도가 빠름
        - 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결 가능
        - 주소의 확장성, 융통성, 연동성이 뛰어남
        - 실시간 흐름 제어로 향상된 멀티미디어 기능 지원
        - 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다
        - 기본 헤더 뒤에 확장 헤더를 더함으로써 더욱 다양한 정보의 저장이 가능해져 네트워크 기능 확장이 용이
        - IPv4와 호환성이 뛰어남
    - IPv6의 구성
        - 16비트씩 8부분, 총 128비트로 구성
        - 각 부분을 16진수로 표현하고, 콜론(:) 으로 구분
        - IPv6는 다음 세 가지 주소 체계로 나뉘어짐
            
            
            | 유니캐스트(Unicast) | 단일 송신자와 단일 수신자 간의 통신 (1 대 1 통신에 사용) |
            | --- | --- |
            | 멀티캐스트(Multicast) | 단일 송신자와 다중 수신자 간의 통신 (1 대 다 통신에 사용) |
            | 애니캐스트(Anycasy) | 단일 송신자와 가장 가까이 있는 단일 수신자 간의 통신(1 대 1 통신에 사용) |
    - 도메인 네임(Domain Name)
        - 도메인 네임은 숫자로 된 IP 주소를 사람이 이해하기 쉬운 문자 형태로 표현한 것
        - 호스트 컴퓨터 이름, 소속 기관 이름, 소속 기관의 종류, 소속 국가명 순으로 구성되며, 왼쪽에서 오른쪽으로 갈수록 상위 도메인을 의미
        - 문자로 된 도메인 네임을 컴퓨터가 이해할 수 있는 IP 주소로 변환하는 역할을 하는 시스템을 DNS(Domain Name System)라고 하며 이런 역할을 하는 서버를 DNS 서버라고 한다
- OSI 참조 모델 A
    - OSI(Open System Interconnection) 참조 모델
        - OSI 참조 모델은 다른 시스템 간의 원활한 통신을 위해 ISO(국제표준화기구)에서 제안한 통신 규약(Protocol)이다
        - OSI 7계층은 1~3계층을 하위 계층, 4~7계층을 상위 계층이라고 한다
            - 하위 계층 : 물리 계층 → 데이터 링크 계층 → 네트워크 계층
            - 상위 계층 : 전송 계층 → 세션 계층 → 표현 계층 → 응용 계층
    - 물리 계층(Physical Layer)
        - 물리 계층은 전송에 필요한 두 장치 간의 실제 접속과 절단 등 기계적, 전기적, 기능적, 절차적 특성에 대한 규칙을 정의
        - 물리적 전송 매체와 전송 신호 방식을 정의
        - RS-232C, X.21 등의 표준
        - 관련 장비 : 리피터, 허브
    - 데이터 링크 계층(Data Link Layer)
        - 데이터 링크 계층은 두 개의 인접한 개방 시스템들 간에 신뢰성 있고 효율적인 정보 전송을 할 수 있도록 시스템 간 연결 설정과 유지 및 종료를 담당
        - 송신 측과 수신 측의 속도 차이 해결을 위한 흐름 제어 기능
        - 프레임의 시작과 끝을 구분하기 위한 프레임의 동기화 기능
        - 오류의 검출과 회복을 위한 오류 제어 기능
        - 프레임의 순서적 전송을 위한 순서 제어 기능
        - HDLC, LAPB, LLC, MAC, LAPD, PPP 등의 표준
        - 관련 장비 : 랜카드, 브리지, 스위치
    - 네트워크 계층(Network Layer, 망 계층)
        - 네트워크 계층은 개방 시스템들 간의 네트워크 연결을 관리하는 기능과 데이터의 교환 및 중계 기능
        - 네트워크 연결을 설정, 유지, 해제하는 기능
        - 경로 설정(Routing), 데이터 교환 및 중계, 트래픽 제어, 패킷 정보 전송
        - X.25, IP 등의 표준
        - 관련 장비 : 라우터
    - 전송 계층(Transport Layer)
        - 전송 계층은 논리적 안정과 균일한 데이터 전송 서비스를 제공함으로써 종단 시스템(End-to-End) 간에 투명한 데이터 전송을 가능하게 함
        - OSI 7계층 중 하위 3계층과 상위 3계층의 인터페이스(Interface)를 담당
        - 종단 시스템 간의 전송 연결 설정, 데이터 전송, 연결 해제 기능
        - 주소 설정, 다중화(분할 및 재조립), 오류 제어, 흐름 제어를 수행
        - TCP, UDP 등의 표준
        - 관련 장비 : 게이트웨이
    - 세션 계층(Session Layer)
        - 세션 계층은 송수신 측 간의 관련성을 유지하고 대화 제어를 담당
        - 대화(회화) 구성 및 동기 제어, 데이터 교환 관리 기능
        - 대화의 생성, 관리, 종료를 위해 토큰을 사용
        - 동기점은 오류가 있는 데이터의 회복을 위해 사용하는 것으로, 종류에는 소동기점과 대동기점 존재
    - 표현 계층(Presentation Layer)
        - 표현 계층은 응용 계층으로부터 받은 데이터를 세션 계층에 보내기 전에 통신에 적당한 형태로 변환하고, 세션 계층에서 받은 데이터는 응용 계층에 맞게 변환하는 기능
        - 서로 다른 데이터 표현 형태를 갖는 시스템 간의 상호 접속을 위해 필요한 계층
        - 코드 변환, 데이터 암호화, 데이터 압축, 구문 검색, 정보 형식(포맷) 변환, 문맥관리 기능
    - 응용 계층(Application Layer)
        - 응용 계층은 사용자(응용 프로그램)가 OSI 환경에 접근할 수 있도록 서비스를 제공
        - 응용 프로세스 간의 정보 교환, 전자 사서함, 파일 전송, 가상 터미널 등의 서비스를 제공
- 네트워크 관련 장비 C
    - 네트워크 인터페이스 카드(NIC; Network Interface Card)
        - 네트워크 인터페이스 카드는 컴퓨터와 컴퓨터 또는 컴퓨터와 네트워크를 연결하는 장치
        - 정보 전송 시 정보가 케이블을 통해 전송될 수 있도록 정보 형태를 변경
        - 이더넷 카드(LAN 카드) 혹은 네트워크 어댑터라고도 함
    - 허브(Hub)
        - 허브는 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각각의 회선을 통합하여 관리
        - 허브는 신호 증폭 기능을 하는 리피터의 역할을 포함
        - 허브 종류
            - 더미 허브(Dummy Hub) : 네트워크에 흐르는 모든 데이터를 단순히 연결하는 기능만 제공하는 허브
            - 스위칭 허브(Switching Hub) : 네트워크상에 흐르는 데이터의 유무 및 흐름을 제어하여 각각의 노드가 허브의 최대 대역폭을 사용할 수 있는 지능형 허브
    - 리피터(Repeater)
        - 리피터는 거리가 증가할수록 감쇠하는 디지털 신호의 장거리 전송을 위해 수신한 신호를 재생시키거나 출력 전압을 높여 전송하는 장치
        - OSI 참조 모델의 물리 계층에서 동작하는 장비
        - 전송 거리의 연장 또는 배선의 자유도를 높이기 위한 용도로 사용
    - 브리지(Bridge)
        - 브리지는 LAN과 LAN을 연결하거나 LAN 안에서의 컴퓨터 그룹을 연결하는 장치
        - 네트워크의 수많은 단말기들에 의해 발생하는 트래픽 병목 현상을 줄일 수 있다
        - 네트워크를 분산적으로 구성할 수 있어 보안성을 높일 수 있다
        - 브리지를 이용한 서브넷(Subnet) 구성 시 전송 가능한 회선 수는 브리지가 n개일 때, n(n-1)/2개
    - 스위치(Switch)
        - 스위치는 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치
        - 하드웨어를 기반으로 처리하므로 전송 속도가 빠름
        - 포트마다 서로 다른 전송 속도를 지원하게 제어할 수 있다
        - 수십에서 수백 개의 포트를 제공
        - OSI 참조 모델의 데이터 링크 계층에서 사용
    - 라우터(Router)
        - 라우터는 브리지와 같이 LAN과 LAN의 연결 기능에 데이터 전송의 최적 경로를 선택하는 기능이 추가된 장치
        - 서로 다른 LAN 또는 LAN과 WAN을 연결하는 기능도 함
        - OSI 참조 모델의 네트워크 계층에서 동작하는 장비
        - 3계층, 즉 네트워크 계층까지의 프로토콜 구조가 다른 네트워크 간의 연결을 위해 프로토콜 변환 기능을 수행
    - 게이트웨이(Gateway)
        - 게이트웨이는 OSI 전 계층의 프로토콜 구조가 다른 네트워크를 연결하는 장치
        - LAN에서 다른 네트워크에 데이터를 보내거나 다른 네트워크로부터 데이터를 받아들이는 출입구 역할
        - 세션 계층, 표현 계층, 응용 계층 간을 연결하여 데이터 형식 변환, 주소 변환, 프로토콜 변환 등을 수행
- TCP/IP A
    - 프로토콜(Protocol)
        - 프로토콜은 서로 다른 기기들 간의 데이터 교환을 원활하게 수행할 수 있도록 표준화시켜 놓은 통신 규약
        - 프로토콜의 기본 요소
            
            
            | 구문(Syntax) | 전송하고자 하는 데이터의 형식, 부호화, 신호 레벨 등을 규정 |
            | --- | --- |
            | 의미(Semantics) | 두 기기 간의 효율적이고 정확한 정보 전송을 위한 협조 사항과 오류 관리를 위한 제어 정보를 규정 |
            | 시간(Timing) | 두 기기 간의 통신 속도, 메시지의 순서 제어 등을 규정 |
        - 프로토콜의 기능 : 단편화와 재결합, 캡슐화, 흐름 제어, 오류 제어, 동기화, 순서 제어, 주소 지정, 다중화, 경로 제어, 전송 서비스 등
    - TCP/IP (transmission Control Protocol/Internet Protocol)
        - TCP/IP는 인터넷에 연결된 서로 다른 기종의 컴퓨터들이 데이터를 주고받을 수 있도록 하는 표준 프로토콜
            
            
            | 프로토콜 | 내용 |
            | --- | --- |
            | TCP(Transmission
            Control Protocol) | - OSI 7계층의 전송 계층에 해당 
            
            - 가상 회선 방식을 기반으로 하는 연결형 서비스를 제공 
            
            - 패킷의 다중화, 순서 제어, 오류 제어, 흐름 제어 기능을 제공  |
            | IP(Internet
            Protocol) | - OSI 7계층의 네트워크 계층에 해당 
            
            - 데이터그램 방식을 기반으로 하는 비연결형 서비스를 제공 
            
            - 패킷의 분해/조립, 주소 지정, 경로 선택 기능을 제공 |
    - TCP/IP의 구조
        
        
        | OSI | TCP/IP | 기능 |
        | --- | --- | --- |
        | 응용 계층
        표현 계층
        세션 계층 | 응용 계층 | - 응용 프로그램 간의 데이터 송,수신 제공
        
        - TELNET, FTP, SMTP, SNMP, DNS, HTTP 등 |
        | 전송 계층 | 전송 계층 | - 호스트들 간의 신뢰성 있는 통신 제공
        
        - TCP, UDP, RTCP |
        | 네트워크 계층 | 인터넷 계층 | - 데이터 전송을 위한 주소 지정, 경로 설정을 제공 
        
        - IP, ICMP, IGMP, ARP, RARP |
        | 데이터 링크 계층
        물리 계층 | 네트워크 액세스 계층 | - 실제 데이터(프레임)를 송,수신하는 역할
        
        -Ethernet, IEEE802, HDLC, X.25, RS-232C, ARQ 등 |
    - 응용 계층의 주요 프로토콜
        
        
        | FTP(File Transfer
        Protocol) | - 컴퓨터와 컴퓨터 또는 컴퓨터와 인터넷 사이에서 파일을 주고받을 수 있도록 하는 원격 파일 전송 프로토콜 |
        | --- | --- |
        | SMTP(Simple Mail
        Transfer Protocol) | - 전자 우편을 전송하는 프로토콜 |
        | TELNET | - 멀리 떨어져 있는 컴퓨터에 접속하여 자신의 컴퓨터처럼 사용할 수 있도록 해주는 서비스
        
        - 프로그램을 실행하는 등 시스템 관리 작업을 할 수 있는 가상의 터미널(Virtual Terminal) 기능을 수행한다. |
        | SNMP(Simple Network
        Management Protocol) | - TCP/IP의 네트워크 관리 프로토콜로, 라우터나 허브 등 네트워크 기기의 네트워크 정보를 네트워크 관리 시스템에 보내는 데 사용되는 표준 통신 규약 |
        | DNS(Domain Name
        System) | - 도메인 네임을 IP 주소로 매핑(Mapping)하는 시스템 |
        | HTTP(HyperText
        Transfer Protocol) | - 월드 와이드 웹(WWW)에서 HTML 문서를 송수신 하기 위한 표준 프로토콜 |
    - 전송 계층의 주요 프로토콜
        
        
        | TCP(Transmission 
        Control Protocol) | - 양방향 연결(Full Duplex Connction)형 서비스를 제공
        
        - 가상 회선 연결(Virtual Circuit Connection)형태의 서비스를 제공
        
        - 스트림 위주의 전달(패킷 단위) 
        
        - 쇤뢰성 있는 경로를 확립하고 메시지 전송을 감독
        
        - 순서 제어, 오류 제어, 흐름 제어 기능
        
        - 패킷의 분실, 손상, 지연이나 순서가 틀린 것 등이 발생할 때 투명성이 보장되는 통신을 제공
        
        - TCP 프로토콜의 헤더는 기본적으로 20Byte에서 60Byte까지 사용 가능하지만 선택적으로 40Byte를 추가하여 최대 100Byte까지 크기 확장 가능 |
        | --- | --- |
        | UDP(User Datagram
        Protocol) | - 데이터 전송 전에 연결을 설정하지 않는 비연결형 서비스를 제공
        
        -TCP에 비해 상대적으로 단순한 헤더 구조를 가지므로, 오버헤드가 적고, 흐름 제어나 순서 제어가 없어 전송 속도가 빠르다.
        
        - 고속의 안정성 있는 전송 매체를 사용하여 빠른 속도를 필요로 하는 경우, 동시에 여러 사용자에게 데이터를 전달할 경우, 정기적으로 반복해서 전송할 경우에 사용 
        
        - 실시간 전송에 유리하며, 신뢰성보다는 속도가 중요시되는 네트워크에서 사용
        
        - UDP 헤더에는 Source Port Number, Destination Port Number, Length, Checksum등이 포함 |
        | RTCP(Real-Time
        Control Protocol) | - RTP(Real-time Transport Protocol) 패킷의 전송 품질을 제어하기 위한 제어 프로토콜
        
        - 세션(Session)에 참여한 각 참여자들에게 주기적으로 제어 정보 전송
        
        - 하위 프로토콜은 데이터 패킷과 제어 패킷의 다중화(Multiplexing)을 제공
        
        - 데이터 전송을 모니터링하고 최소한의 제어와 인증 기능만을 제공
        
        - RTCP 패킷은 항상 32비트의 경계로 끝난다. |
    - 인터넷 계층의 주요 프로토콜
        
        
        | IP(Internet Protocol) | - 전송할 데이터에 주소를 지정하고, 경로를 설정하는 기능
        
        - 비연결형인 데이터그램 방식을 사용하는 것으로 신뢰성이 보장되지 않음 |
        | --- | --- |
        | ICMP(Internet Control
        Message Protocol, 인터넷
        제어 메시지 프로토콜) | - IP와 조합하여 통신중에 발생하는 오류의 처리와 전송 경로 변경 등을 위한 제이 메시지를 관리하는 역할
        
        - 헤더는 8Byte로 구성 |
        | IGMP(Internet Group
        Management Protocol,
        인터넷 그룹 관리 프로토콜) | - 멀티캐스트를 지원하는 호스트나 라우터 사이에서 멀티캐스트 그룹 유지를 위해 사용 |
        | ARP(Address Resolution
        Protocol, 주소 분석 프로토콜) | - 호스트의 IP 주소를 호스트와 연결된 네트워크 접속 장치의 물리적 주소(MAC Address)로 변경 |
        | RARP(Reverse Address
        Resoulution Protocol) | - ARP와 반대로 물리적 주소를 IP 주소로 변환하는 기능 |
    - 네트워크 액세스 계층의 주요 프로토콜
        
        
        | Ethernet(IEEE 802.3) | CSMA/CD 방식의 LAN |
        | --- | --- |
        | IEEE 802 | LAN을 위한 표준 프로토콜 |
        | HDLC | 비트 위주의 데이터 링크 제어 프로토콜 |
        | X.25 | 패킷 교환망을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 |
        | RS-232C | 공중 전화 교환망(PSTN)을 통한 DTE와 DCE 간의 인터페이스를 제공하는 프로토콜 |
- 네트워크 관련 신기술 A
    - 네트워크 관련 신기술
        
        
        | 용어 | 의미 |
        | --- | --- |
        | IoT
        (Internet of Things,
        사물 인터넷) | - 정보 통신 기술을 기반으로 실세계(Physical World)와 가상 세계(Virtual World)의 다양한 사물들을 인터넷으로 서로 연결하여 진보된 서비스를 제공하기 위한 서비스 기반 기술 |
        | M2M(Machine to 
        Machine, 사물 통신) | - 무선 통신을 이용한 기계와 기계 사이의 통신
        
        - 변압기 원격 감시, 전기, 가스 등의 원격 검침, 무선 신용 카드 조회기, 무선 보안단말기, 버스 운행 시스템, 위치 추적 시스템, 시설물 관리 등을 무선으로 통합하여 상호 작용하는 통신 |
        | 모바일 컴퓨팅
        (Mobile Computing) | - 휴대용 기기로 이동하면서 자유로이 네트워크에 접속하여 업무를 처리할 수 있는 환경 |
        | 클라우드 컴퓨팅
        (Cloud Computing) | - 각종 컴퓨팅 자원을 중앙 컴퓨터에 두고 인터넷 기능을 갖는 단말기로 언제 어디서나 인터넷을 통해 컴퓨터 작업을 수행할 수 있는 가상화된 환경 |
        | 그리드 컴퓨팅
        (Grid Computing) | - 지리적으로 분산되어 있는 컴퓨터를 초고속 인터넷망으로 연결하여 공유함으로써 하나의 고성능 컴퓨터처럼 활용하는 기술 |
        | 모바일 클라우드 컴퓨팅
        (MCC; Mobile Cloud
        Computin) | - 소비자와 소비자의 파트너가 클라우드 서비스를 이용하여 모바일 기기로 클라우드 컴퓨팅 인프라를 구성하여 여러가지 정보와 자원을 공유하는 ICT 기술 |
        | 인터클라우드 컴퓨팅
        (Inter-Cloud 
        Computing) | - 각기 다른 클라우드 서비스를 연동하거나 컴퓨팅 자원의 동적 할당이 가능하도록 여러 클라우드 서비스 제공자들이 제공하는 클라우드 서비스나 자원을 연결하는 기술 |
        | 메시 네트워크
        (Mesh Network) | - 차세대 이동통신, 홈네트워킹, 공공 안전 등 특수 목적을 위한 새로운 방식의 네트워크 기술 
        
        - 대규모 디바이스의 네트워크 생성에 최적화 |
        | 와이선(Wi-SUN) | - 스마트 그리드와 같은 장거리 무선 통신을 필요로 하는 사물 인터넷(IoT) 서비스를 위한 저전력 장거리(LPWA; Low-Power Wide Area) 통신 기술 |
        | NDN(Named Data
        Networking) | - 콘텐츠 자체의 정보와 라우터 기능만으로 데이터 전송을 수행하는 기술 
        
        - 클라이언트와 서버가 패킷의 헤더에 내장되어 있는 주소 정보를 이용하여 연결되던 기존의 IP(Internet Protocol) 망을 대체할 새로운 인터넷 아키텍처로 떠오르고 있음 |
        | NGN(Next Generation
        Network, 차세대 통신망) | - ITU-T에서 개발하고 있는 유선망 기반의 차세대 통신망
        
        - 유선망뿐만 아니라 이동 사용자를 목표로 하며, 이동통신에서 제공하는 완전한 이동성(Full Mobility) 제공을 목표로 개발되고 있음 |
        | SDN(Software Defined
        Networking, 소프트웨어
        정의 네트워킹) | - 네트워크를 컴퓨터처럼 모델링하여 여러 사용자가 각각의 소프트웨어로 네트워킹을 가상화하여 제어하고 관리하는 네트워크  |
        | NFC(Near Field
        Communication, 
        근거리 무선 통신) | - 고주파(HF)를 이용한 근거리 무선 통신 기술
        
        - 아주 가까운 거리에서 양방향 통신을 지원하는 RFID 기술의 일종 |
        | UWD(Ultra WideBand,
        초광대역) | - 짧은 거리에서 많은 양의 디지털 데이터를 낮은 전력으로 전송하기 위한 무선 기술로 무선 디지털 펄스라고도 함 
        
        - 0.5m/W 정도의 저전력으로 많은 양의 데이터를 1km의 거리까지 전송할 수 있을 뿐만 아니라, 땅속이나 벽면 뒤로도 전송이 가능함 |
        | 피코넷(PICONET) | - 여러 개의 독립된 통신장치가 블루투스 기술이나 UWB 통신 기술을 사용하여 통신망을 형성하는 무선 네트워크 기술 |
        | WBAN(Wireless Body
        Area Network) | - 웨어러블(Wearable) 또는 몸에 심는(Implant) 혀앹의 센서나 기기를 무선으로 연결하는 개인 영역 네트워크 기술 |
        | GIS(Geographic
        Information System, 
        지리 정보 시스템) | - 지리적인 자료를 수집, 저장, 분석, 출력할 수 있는 컴퓨터 응용 시스템 
        
        - 위성을 이용해 모든 사물의 위치 정보를 제공 |
        | UNS(Ubiquitous
        Sensor Network, 
        유비쿼터스 센서
        네트워크) | - 각종 센서로 수집한 정보를 무선으로 수집할 수 있도록 구성한 네트워크 
        
        - 필요한 모든 것에 RFID 태그를 부착하고, 이를 통하여 사물의 인식정보는 물론 주변의 환경정보까지 탐지하여 이를 네트워크에 연결하여 정보를 관리 |
        | SON(Self Organizing
        Network, 자동 구성
        네트워크) | - 주변 상황에 맞춰 스스로 망을 구성하는 네트워크 
        
        - SON의 목적은 통신망 커버리지 및 전송 용량 확장의 경제성 문제를 해결하고, 망의 운영과 관리의 효율성을 높이는 것 |
        | 애드 훅 네트워크
        (Ad-hoc Network) | - 재난 현장과 같이 별도의 고정된 유선망을 구축할 수 없는 장소에서 모바일 호스트(Mobile Host) 만을 이용하여 구성한 네트워크 
        
        - 망을 구성한 후 단기간 사용되는 경우나 유선망을 구성하기 어려운 경우에 적합 |
        | 네트워크 슬라이싱
        (Network Slicing) | - 네트워크에서 하나의 물리적인 코어 네트워크 인프라(Infrastructure)를 독립된 다수의 가상 네트워크로 분리하여 각각의 네트워크를 통해 다양한 고객 맞춤형 서비스를 제공하는 것을 목적으로 하는 네트워크 기술 
        
        - 3GPP를 포함한 여러 글로벌 이동통신 표준화 단체가 선정한 5G(IMT-2020)의 핵심기술 중 하나 |
        | 저전력 블루투스 기술
        (BLE; Bluetooth Low
        Energy) | - 일반 블루투스와 동일한 2.4GHz 주파수 대역을 사용하지만 연결되지 않은 대기 상태에서는 절전모드를 유지하는 기술 |
        | 지능형 초연결망 | - 스마트 시티, 스마트 스테이션 등 4차 산업혁명 시대를 맞아 새로운 변화에 따라 급격하게 증가하는 데이터 트패픽을 효과적으로 수용하기 위해 시행되는 과학기술정보통신부 주관 사업 |
        | 파장 분할 다중화
        (WDM, Wavelength
        Division Multiplexing) | - 광섬유를 이용한 통신기술의 하나로, 파장이 서로 다른 복수의 신호를 보냄으로써 여러 대의 단말기가 동시에 통신 회선을 사용할 수 있도록 하는 것 
        
        - 파장이 다른 광선끼리는 서로 간섭을 일으키지 않는 성질을 이용한 기술 |
        | 소프트웨어 정의 데이터
        센터(SDDC, Software
        Defined Data Center) | - Linked Data와  Open Data의 합성어로, 누구나 사용할 수 있도록 웹상에 공개된 연계 데이터 
        
        - 웹상에 존재하는 데이터를 개별 URI(인터넷 식별자)로 식별하고, 각 URI에 링크 정보를 부여함으로써 상호 연결된 웹을 지향하는 모형 |
        | SSO(Single Sign On) | - 한 번의 로그인으로 개인이 가입한 모든 사이트를 이용할 수 있게 해주는 시스템
        
        - 개인정보를 각 사이트마다 일일이 기록해야 하던 불편함을 해소 가능 
        
        - 기업에서는 회원에 대한 통합관리가 가능해 마케팅을 극대화 가능 |
- 네트워크 구축 B
    - 네트워크(Network)
        - 네트워크는 두 대 이상의 컴퓨터를 전화선이나 케이블 등으로 연결하여 자원을 공유하는 것
        - 네트워크는 다른 컴퓨터의 데이터, 프로그램, 주변장치, 인터넷 등을 공유하기 위해 사용
        - 네트워크 설치 구조는 장치들의 물리적 위치에 따라 성형, 링형, 버스형, 계층형, 망형으로 나뉨
        - 네트워크는 사이트들이 분포되어 있는 지리적 범위에 따라 LAN과 WAN으로 분류
    - 성형(Star, 중앙 집중형)
        - 성형은 중앙에 중앙 컴퓨터가 있고, 이를 중심으로 단말장치들이 연결되는 중앙 집중식의 네트워크 구성 형태
        - 포인트 투 포인(Point-to-Point) 방식으로 회선을 연결
        - 단말장치의 추가와 제거가 쉽다.
        - 하나의 단말장치가 고정나더라도 다른 단말장치에는 영향을 주지 않지만, 중앙 컴퓨터가 고장나면 전체 통신망의 기능이 정지
    - 링형(Ring, 루프형)
        - 링형은 컴퓨터와 단말장치들을 서로 이웃하는 것끼리 연결시킨 포인트 투 포인트(Point-to-Point) 방식의 구성 형태
        - 단말장치의 추가/제거 및 기밀 보호가 어렵다
        - 각 단말장치에서 전송 지연이 발생할 수 있다.
        - 중계기의 수가 많아진다.
        - 데이터는 단방향 또는 양방향으로 전송할 수 있다.
    - 버스형(Bus)
        - 버스형은 한 개의 통신 회선에 여러 대의 단말장치가 연결되어 있는 형태이다.
        - 단말장치의 추가와 제거가 용이하다
        - 단말장치가 고장나더라도 통신망 전체에 영향을 주지 않기 때문에 신뢰성을 높일 수 있다.
        - 기밀 보장이 어렵다.
        - 통신 회선의 길이에 제한이 있다.
    - 계층형(Tree, 분산형)
        - 계층형은 중앙 컴퓨터와 일정 지역의 단말장치까지는 하나의 통신 회선으로 연결시키고, 이웃하는 단말장치는 일정 지역 내에 설치된 중앙 단말장치로부터 다시 연결시키는 형태
        - 분산 처리 시스템을 구성하는 방식
    - 망형(Mesh)
        - 망형은 모든 지점의 컴퓨터와 단말장치를 서로 연결한 형태로, 노드의 연결성이 높다.
        - 많은 단말장치로부터 많은 양의 통신을 필요로 하는 경우에 유리
        - 통신 회선의 총 경로가 가장 길다.
        - 통신 회선 장애 시 다른 경로를 통하여 데이터를 전송할 수 있다.
        - 모든 노드를 망형으로 연결하려면 노드의 수가 n개일 때, n(n-1)/2개의 회선이 필요하고 노드당 n-1개의 포트가 필요하다.
    - 네트워크 분류
        
        
        | 근거리 통신망
        (LAN; Local Area
        Network) | - 회사, 학교, 연구소 등에서 비교적 가까운 거리에 있는 컴퓨터, 프린터, 테이프 등과 같은 자원을 연결하여 구성
        
        - 주로 자원 공유를 목적으로 사용
        
        - 사이트 간의 거리가 짧아 데이터의 전송 속도가 빠르고, 에러 발생율이 낮다. 
        
        - 근거리 통신망에서는 주로 버스형이나 링형 구조를 사용 |
        | --- | --- |
        | 광대역 통신망
        (WAN:  Wide Area
        Network) | - 국가와 국가 혹은 대륙과 대륙 등과 같이 멀리 떨어진 사이트들을 연결하여 구성
        
        - 사이트 간의 거리가 멀기 때문에 통신 속도가 느리고, 에러 발생률이 높다. 
        
        - 일정한 지역에 있는 사이트들을 근거리 통신망으로 연결한 후 각 근거리 통신망을 연결하는 방식을 사용 |
    - LAN의 표준안
        - IEEE 802의 주요 표준 규격
            
            
            | 표준 규격 | 내용 |
            | --- | --- |
            | 802.1 | 전체의 구성, OSI 참조 모델과의 관계, 통신망 관리 등에 관한 규약 |
            | 802.2 | 논리 링크 제어(LLC) 계층에 관한 규약 |
            | 802.3 | CSMA/CD 방식의 매체 접근 제어 계층에 관한 규약 |
            | 802.4 | 토큰 버스 방식의 매체 접근 제어 계층에 관한 규약 |
            | 802.5 | 토큰 링 방식의 매체 접근 제어 계층에 관한 규약 |
            | 802.6 | 도시형 통신망(MAN)에 관한 규약 |
            | 802.9 | 종합 음성/데이터 네트워크에 관한 규약 |
            | 802.11 | 무선 LAN에 관한 규약 |
        - 802.11의 버전
            
            
            | 버전 | 내용 |
            | --- | --- |
            | 802.11
            (초기 버전) | 2.4GHz 대역 전파와 CSMA/CA 기술을 사용해 최고 2Mbps까지의 전송 속도 지원 |
            | 802.11a | 5GHz 대역의 전파를 사용하며, OFDM 기술을 사용해 최고 54Mbps 까지의 전송 속도 지원 |
            | 802.11b | 802.11 초기 버전의 개선안으로 등장, 초기 버전의 대역 전파와 기술을 사용해 최고 11Mbps의 전송 속도로 기존에 비해 5배 이상 빠르게 개선 |
            | 802.11e | 802.11의 부가 기능 표준으로, QoS 기능이 지원되도록 하기 위해 매체 접근 제어(MAC) 계층에 해당하는 부분을 수정 |
            | 802.11g | 2.4GHz 대역의 전파를 사용하지만 5GHz 대역의 전파를 사용하는 802.11a와 동일한 최고 54Mbps까지의 전송 속도 지원 |
            | 802.11n | 2.4GHz 대역과 5GHz 대역을 사용하는 규격으로, 최고 600Mbps까지의 전송 속도 지원 |
    - NAT(Network Address Translation, 네트워크 주소 변환)
        - NAT는 한 개의 정식 IP 주소에 대량의 가상 사설 IP 주소를 할당 및 연결하는 기능
        - 한 개의 IP 주소를 사용해서 외부에 접속할 수 있는 노드는 어느 시점에서 한 개로 제한되는 문제가 있지만 IP 마스커레이드(Masquerade)를 이용하여 해결 가능
- 경로 제어 / 트래픽 제어 A
    - 경로 제어(Routing)
        - 경로 제어는 송,수신 측 간의 전송 경로 중에서 최적 패킷 교환 경로를 결정하는 기능
        - 경로 제어는 경로 제어표(Routing Table)를 참조하여 이루어지며, 라우터에 의해 수행
        - 경로 제어 요소
            - 성능 기준
            - 경로의 결정 시간과 장소
            - 정보 발생지
            - 경로 정보의 갱신 시간
    - 경로 제어 프로토콜(Routing Protocol)
        
        
        | 프로토콜 | 내용 |
        | --- | --- |
        | IGP(Interior Gateway Protocol, 내부 게이트웨이 
        프로토콜) | - 하나의 자율 시스템(AS) 내의 라우팅에 사용되는 프로토콜 
        - RIP(Routing Information Protocol)
        
          - 현재 가장 널리 사용되는 라우팅 프로토콜로 거리 벡터 라우팅 프로토콜이라고도 불리며, 최단 경로 탐색에 Bellman-Ford 알고리즘이 사용
        
          - 소규모 동종의 네트워크(자율 시스템, AS) 내에서 효율적인 방법 
        
          - 최대 홉(Hop) 수를 15로 제한하므로 15를 초과하는 경우는 도달할 수 없는 네트워크를 의미하는데 이것은 대규모 네트워크에서는 RIP를 사용할 수 없음을 의미
        
          - 라우팅 정보를 30초마다 네트워크 내의 모든 라우터에 알리며, 180초 이내에 새로운 라우팅 정보가 수신되지 않으면 해당 경로를 이상 상태로 간주
        
        - OSPF(Open Shortest Path First protocol)
        
          - RIP의 잔점을 해결하여 새로운 기능을 지원하는 인터넷 프로토콜로, 대규모 네트워크에서 많이 사용
        
          - 인터넷 망에서 이요자가 최단 경로를 선정할 수 있도록 라우팅 정보에 노드 간의 거리 정보, 링크 상태 정보를 실시간으로 반영하여 최단 경로로 라우팅을 지원
        
          - 최단 경로 탐색에 다익스트라(Dijkstra) 알고리즘을 사용
        
          - 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알린다 
        
          - 하나의 자율 시스템(AS)에서 동작하면서 내부 라우팅 프로토콜의 그룹에 도달한다. |
        | EGP(Exterior Gateway Protocol,
        외부 게이트웨이 
        프로토콜) | - 자율 시스템(AS) 간의 라우팅, 즉 게이트웨이 간의 라우팅에 사용되는 프로토콜 |
        | BGP(Border
        Gateway Protocol) | - 자율 시스템(AS) 간의 라우팅 프로토콜로, EGP의 단점을 보안하기 위해 만들어졌다. 
        
        - 초기에 BGP 라우터들이 연결될 때에는 전체 경로 제어표(라우팅 테이블)를 교환하고, 이후에는 변화된 정보만을 교환한다. |
    - 트래픽 제어(Traffic Control)
        - 트래픽 제어는 네트워크의 보호, 성능 유지, 네트워크 자원의 효율적인 이용을 위해 전송되는 패킷의 흐름 또는 그 양을 조절하는 기능
        - 종류
            - 흐름 제어
            - 폭주(혼합) 제어
            - 교착상태 방지
    - 흐름 제어(Flow Control)
        - 흐름 제어란 네트워크 내의 원활한 흐름을 위해 송,수신 측 사이에 전송되는 패킷의 양이나 속도를 규제하는 기능
            
            
            | 기법 | 내용 |
            | --- | --- |
            | 정지-대기
            (Stop-and-Wait) | - 수신 측의 확인 신호(ACK)를 받은 후에 다음 패킷을 전송하는 방식
            
            - 한 번에 하나의 패킷만을 전송할 수 있다.  |
            | 슬라이딩 윈도우
            (Sliding Window) | - 확인 신호, 즉 수신 통지를 이용하여 송신 데이터의 양을 조절하는 방식
            
            - 수신 측의 확인 신호를 받지 않더라도 미리 정해진 패킷의 수만큼 연속적으로 전송하는 방식으로, 한 번에 여러 개의 패킷을 전송할 수 있어 전송 효율이 좋다. 
            
            - 송신 측은 수신 측으로부터 확인 신호(ACK) 없이도 보낼 수 있는 패킷의 최대치를 미리 약속받는데, 이 패킷의 최대치가 윈도우 크기(Window Size)를 의미한다. 
            
            - 윈도우 크기는 상황에 따라 변한다. 즉, 수신 측으로부터 이전에 송신한 패킷에 대한 긍정 수신 응답(ACK)이 전달된 경우 윈도우 크기는 증가하고, 수신 측으로부터 이전에 송신한 패킷에 대한 부정 수신 응답(NAK)이 전달된 경우 윈도우의 크기는 감소한다.  |
    - 폭주 제어(Congestion Control)
        - 흐름 제어(Flow Control)가 송,수신 측 사이의 패킷 수를 제어하는 기능이라면, 폭주 제어는 네트워크 내의 패킷 수를 조절하여 네트워크의 오버플로(Overflow)를 방지하는 기능
            
            
            | 느린 시작
            (Slow Start) | - 윈도우의 크기를 1, 2, 4, 8 — 과 같이 2배씩 지수적으로 증가시켜 초기에는 느리지만 갈수록 빨라진다 
            
            - 전송 데이터의 크기가 임계 값에 도달하면 혼잡 회피 단계로 넘어간다.  |
            | --- | --- |
            | 혼잡 회피
            (Congestion
            Avoidance) | - 느린 시작(Slow Start)의 지수적 증가가 임계 값에 도달되면 혼잡으로 간주하고 회피를 위해 윈도우의 크기를 1씩 선형적으로 증가시켜 혼잡을 예방하는 방식이다. |
- SW 관련 신기술 B
    
    
    | 인공지능
    (AI; Artificial Intelligence) | - 인간의 두뇌와 같이 컴퓨터 스스로 추론, 학습, 판단 등 인간지능적인 작업을 수행하는 시스템
    
    - 인공지능의 응용 분야 : 패턴 인식, 전문가 시스템, 로봇 공학등 |
    | --- | --- |
    | 뉴럴링크(Neurallink) | - 미국의 전기자동차 회사 테슬라(Tesla)의 CEO 일론 머스크(Elon Musk)가 사람의 뇌와 컴퓨터를 결합하는 기술을 개발하기 위해 2017년 3월 설립한 회사
    
    - 뉴럴링크가 개발하고 있는 기술은 ‘신경 레이스(Neural Lace)’로 작은 전극을 뇌에 이식함으로써 생각을 업로드하고 다운로드하는 것을 목표로 삼고 있음 |
    | 딥 러닝
    (Deep Learning) | - 인간의 두뇌를 모델로 만들어진 인공 신경망(ANN; Artificial Neural Network)을 기반으로 하는 기계 학습 기술 |
    | 전문가 시스템
    (Expert System) | - 의료 진단 등과 같은 특정 분야의 전문가가 수행하는 고도의 업무를 지원하기 위한 컴퓨터 응용 프로그램 |
    | 증강현실(AR;
    Augmented Reality) | - 실제 촬영한 화면에 가상의 정보를 부가하여 보여주는 기술로, 혼합 현실(MR; Mixed Reality)이라고도 부름 |
    | 블록 체인(Blockchain) | - P2P 네트워크를 이용하여 온라인 금융 거래 정보를 온라인 네트워크 참여자(Peer)의 디지털 장비에 분산 저장하는 기술  |
    | 분산 원장 기술
    (DLT; Distributed
    Ledger Technology) | - 중앙 관리자나 중앙 데이터 저장소가 존재하지 않고 P2P 망내의 참여자들에게 모든 거래 목록이 분산 저장되어 거래가 발생할 때마다 지속적으로 갱신되는 디지털 원장 |
    | 해시(Hash) | - 임의의 길이의 입력 데이터나 메시지를 고정된 길이의 값이나 키로 변환하는 것 |
    | 양자 암호키 분배
    (QKD; Quantum Key Distribution) | - 양자 통신을 위해 비밀키를 분배하여 관리하는 기술
    
    - 두 시스템이 암호 알고리즘 동작을 위한 비밀키를 안전하게 공유하기 위해 양자 암호키 분배 시스템을 설치하여 운영하는 방식으로 활용 |
    | 프라이버시 강화
    기술(PET; Privacy
    Enhancing 
    Technology) | - 개인정보 침해 위험을 관리하기 위한 핵심 기술
    
    - 암호화, 익명화 등 개인정보를 보호하는 기술에서 사용자가 작접 개인정보를 통제하기 위한 기술까지 다양한 사용자 프라이버시 보호 기술을 통칭 |
    | 공통 평가 기준
    (CC; Common Criteria) | - 1999년 6월 8일 ISO 15408 표준으로 채택된 정보 보호 제품 평가 기준
    
    - 정보화 순기능 역할을 보장하기 위해 정보화 제품의 정보 보호 기능과 이에 대한 사용 환경 등급을 정한 기준 |
    | 개인정보 영향평가 제도
    (PIA; Privacy Impact
    Assessment) | - 개인 정보를 활용하는 새로운 정보시스템의 도입 및 기존 정보시스템의 중요한 변경 시 시스템의 구축, 운영이 기업의 고객은 물론 국민의 사생활에 미칠 영향에 대해 미리 조사, 분석, 평가하는 제도 |
    | 그레이웨어(Grayware) | - 소프트웨어를 제공하는 입장에서는 악의적이지 않은 유용한 소프트웨어라고 주장할 수 있지만 사용자 입장에서는 유용할 수도 있고 악의적일 수도 있는 애드웨어, 트랙웨어, 기타 악성 코드나 악성 공유웨어 |
    | 매시업(Mashup) | - 웹에서 제공하는 정보 및 서비스를 이용하여 새로운 소프트웨어나 서비스, 데이터베이스 등을 만드는 기술. 즉, 다수의 정보원이 제공하는 콘텐츠를 조합하여 하나의 서비스로 제공하는 웹 사이트 또는 애플리케이션을 말한다 |
    | 리치 인터넷 애플리케이션
    (RIA; Rich Intenet
    Application) | - 플래시 애니메이션 기술과 웹 서버 애플리케이션 기술을 통합하여 기존 HTML 보다 역동적이고 인터랙티브한 웹페이지를 제공하는 신개념의 플래시 웹페이지 제작 기술 |
    | 시맨틱 웹
    (Semantic Web) | - 컴퓨터가 사람을 대신하여 정보를 읽고 이해하고 가공하여 새로운 정보를 만들어 낼 수 있도록 이해하기 쉬운 의미를 가진 차세대 지능형 웹 |
    | 증발품(Vaporware) | - 판매 계획 또는 배포 계획은 발표되었으나 실제로 고객에게 판매되거나 배포되지 않고 있는 소프트웨어 |
    | 오픈 그리드 서비스
    아키텍처(OGSA; Open
    Grid Service Architecture) | - 애플리케이션 공유를 위한 웹 서비스를 그리드 상에서 제공하기 위해 만든 개방형 표준 |
    | 서비스 지향 아키텍처
    (SOA; Service Oriented
    Architecture) | - 기업의 소프트웨어 인프라인 정보시스템을 공유와 재사용이 가능한 서비스 단위나 컴포넌트 중심으로 구축하는 정보기술 아키텍처
    
    - SOA 기반 애플리케이션 구성 계층 : 
      - 표현(Presentation) 계층
      - 업무 프로세스(Biz-Process) 계층
      - 서비스 중간(Service Intermediary) 계층
      - 애플리케이션(Application) 계층
      - 데이터 저장(Persistency) 계층 |
    | 서비스형 소프트웨어(SaaS; Service Oriented
    Architecture) | - 소프트웨어의 여러 기능 중에서 사용자가 필요로 하는 서비스만 이용할 수 있도록 한 소프트웨어 |
    | 소프트웨어 에스크로(임치)
    (Software Escrow) | - 소프트웨어 개발자의 지식재산권을 보호하고 사용자는 저렴한 비용으로 소프트웨어를 안정적으로 사용 및 유지보수 받을 수 있도록 소스 프로그램과 기술 정보 등을 제 3의 기관에 보관하는 것 |
    | 복잡 이벤트 처리
    (CEP; Complex Event
    Processing) | - 실시간으로 발생하는 많은 사건들 중 의미가 있는 것만을 추출할 수 있도록 사건 발생 조건을 정의하는 데이터 처리 방법  |
    | 디지털 트윈(Digital Twin) | - 현실속의 사물을 소프트웨어로 가상화한 모델로
    
    - 자동차, 항공, 에너지, 국방, 헬스케어 등 여러 분야에서 주목 받고 있음
    
    - 실제 물리적인 자산을 소프트웨어로 가상화함으로써 실제 자산의 특성에 대한 정확한 정보를 얻을 수 있음 
    
    - 자산 최적화, 돌발사고 최소화, 생산성 증가 등 설계부터 제조, 서비스에 이르는 모든 과정의 효율성을 향상시킬 수 있음 |
- 소프트웨어 개발 보안 활동 관련 법령 및 규정 B
    - 개인정보 보호 관련 법령
        - 개인정보 보호법
            - 개인정보의 처리 및 보호에 관한 사항을 정함으로써 개인의 자유과 권리를 보호
        - 정보통신망 이용촉진 및 정보보호 등에 관한 법률
            - 정보통신망의 이용 촉진 및 정보 통신 서비스를 이용하는 이용자들의 개인정보를 보호
        - 신용정보의 이용 및 보호에 관한 법률
            - 개인 신용정보의 효율적 이용과 체계적인 관리를 통해 정보의 유출이나 오남용을 방지
        - 위치정보의 보호 및 이용 등에 관한 법률
            - 개인 위치정보의 안전한 이용 환경을 조성하여 정보의 유출이나 오남용을 방지
        - 표준 개인정보 보호 지침
            - 개인정보의 처리에 관한 기준, 개인정보 침해의 유형 및 예방조치 등에 관한 세부사항을 규정
        - 개인정보의 안전성 확보 조치 기준
            - 개인정보 처리자가 개인정보를 처리하는데 있어 개인정보가 분실, 도난, 유출, 위조, 변조, 훼손되지 않도록 안정성 확보에 필요한 기술적, 관리적, 물리적 안전조치에 관한 최소한의 기준을 규정
        - 개인정보 영향평가에 관한 고시
            - 개인정보 영향평가를 위한 평가기관의 지정, 영향 평가의 절차 등에 관한 세부기준을 규정
    - IT 기술 관련 규정
        - RFID 프라이버시 보호 가이드라인
            - RFID 시스템의 이용자들의 프라이버시를 보호하고 안전한 FRID 이용 환경을 조성하기 위한 가이드라인
        - 위치정보의 보호 및 이용 등에 관한 법률
            - 개인 위치정보의 유출 및 오남용을 방지하기 위한 법률
        - 위치정보의 관리적, 기술적 보호조치 권고 해설서
            - 개인 위치정보의 누출, 변조, 훼손 등을 방지하기 위해 위치정보 사업자 및 위치기반 서비스 사업자가 준수해야 하는 관리적, 기술적 보호조치의 구체적인 기준
        - 바이오정보 보호 가이드라인
            - 개인 바이오정보의 보호와 안전한 활용을 위한 원칙 및 조치사항
        - 뉴미디어 서비스 개인정보 보호 가이드라인
            - 뉴미디어 서비스 이용 및 제공시 개인 정보의 침해사고를 예방하기 위한 준수사항
        - 정보보호 관리 체계(ISMS; Information Security Management System)
            - 정보 자산을 안전하게 보호하기 위한 보호 절차와 대책으로, 조직에 맞는 정보보호 정책을 수립하고, 위험에 상시 대응하는 여러 보안 대책을 통합하여 관리
            - 한국인터넷진흥원(KISA)에서는 공공 기관과 민간 기업을 대상으로 정보 보호 관리 체계를 평가하고 인증하는 업무를 수행
- HW 관련 신기술 A
    
    
    | 고가용성
    (HA; High Availability) | - 긴 시간동안 안정적인 서비스 운영을 위해 장애 발생 시 즉시 다른 시스템으로 대체 가능한 환경을 구축하는 메커니즘  |
    | --- | --- |
    | 3D Printing
    (Three Dimension
    Printing) | - 대상을 평면에 출력하는 것이 아니라 손으로 만질 수 있는 실제 물체로 만들어내는 것 
    
    - 아주 얇은 두께로 한층한층 쌓아 하나의 형태를 만들어 내는 기술을 이용 |
    | 4D Printing
    (Fourth Dimension
    Printing) | - 특정 시간이나 환경 조건이 갖추어지면 스스로 형태를 변화시키거나 제조되는 자가 조립(Self-Assembly) 기술이 적용된 제품을 3D Printing 하는 기술 |
    | RAID
    (Redundant Array
    of Inexpensive Disk,
    Redundant Array of
    Independent Disk) | - 여러 개의 하드디스크로 디스크 배열을 구성하여 파일을 구성하고 있는 데이터 블록들을 서로 다른 디스크들에 분산 저장할 경우, 그 블록들을 여러 디스크에서 동시에 읽거나 쓸 수 있으므로 디스크의 속도가 매우 향상되는데, 이 기술을 RAID 라고 한다. 
    
    - 주요 RAID 레벨 
      - RAID 0 : 스트라이핑을 적용한 방식으로, 디스크의 개수만큼 읽기/쓰기 성능이 향상
      - RAID 1 : 미러링을 적용한 방식으로, 디스크 손상을 대비할 수 있지만, 데이터를 동시에 기록하므로 쓰기 성능이 저하될 수 있음 
      - RAID 5 : 스트라이핑을 적용한 디스크에 오류 검출을 위한 패리티를 저장하는 방식으로, 스트라이핑으로 인한 읽기 성능은 향상되지만, 쓰기 성능은 패리티의 연산과 저장으로 인해 저하될 수 있음 
      - RAID 6 : 이중 패리티를 추가하여 안정성을 높인 방식으로, 금융업과 같이 데이터 손상이 치명적인 결과를 불러일으키는 산업에서 주로 사용 |
    | 4K 해상도 | - 차세대 고화질 모니터의 해상도를 지칭하는 용어 
    
    - 가로 픽셀 수가 3840이고, 세로 픽셀 수가 2160인 영상의 해상도를 말하는데, 이는 Full HDTV(1920X1080)의 가로, 세로 2배. 총 4배에 해당하는 초고화질의 영상 |
    | 앤 스크린(N-Screen) | - N개의 서로 다른 단말기에서 동일한 콘텐츠를 자유롭게 이용할 수 있는 서비스  |
    | 컴패니언 스크린
    (Companion Screen) | - TV 방송 시청 시 방송 내용을 공유하며 추가적인 기능을 수행할 수 있는 스마트폰, 태블릿PC 등을 의미함
    
    - 앤 스크린(N Screen)의 한 종류로, 세컨드 스크린(Second Screen)이라고도 불림 |
    | 신 클라이언트 PC
    (Thin Client PC) | - 하드디스크나 주변장치 없이 기본적인 메모리만 갖추고 서버와 네트워크로 운용되는 개인용 컴퓨터 
    
    - 서버 기반 컴퓨팅과 관계가 깊음  |
    | 패블릿(Phablet) | - 폰(Phone)과 태블릿(Tablet)의 합성어로, 태블릿 기능을 포함한 5인치 이상의 대화면 스마트폰 |
    | C형 유에스비
    (Universal Serial Bus
    Type-C, USB Type-C,
    USB-C) | - 범용 인터페이스 규격인 USB(Universal Serial Bus)의 표준 중 하나 
    
    - 기존 A형에 비하여 크기가 작고, 24핀으로 위아래의 구분이 없어 어느 방향으로든 연결이 가능 |
    | 멤스
    (MEMS; Micro-Electro
    Mechanical Systems) | - 초정밀 반도체 제조 기술을 바탕으로 센서, 액추에이터(Actuator)등 기계 구조를 다양한 기술로 미세 가공하여 전기기계적 동작을 할 수 있도록 한 초미세 장치  |
    | 트러스트존 기술
    (TrustZone Technology) | - 하나의 프로세서(Processor) 내에 일반 애플리케이션을 처리하는 일반 구역(Normal World)과 보안이 필요한 애플리케이션을 처리하는 보안 구역(Secure World)으로 분할하여 관리하는 하드웨어 기반의 보안 기술 |
    | 엠디스크(M-Disc,
    Millennial DISC) | - 한 번의 기록만으로 자료를 영구 보관할 수 있는 광 저장장치
    
    - 디스크 표면의 무기물층에 레이저를 이용해 자료를 조각해서 기록 
    
    - 시간이 지나도 변하지 않는 금속 활자처럼 빛, 열, 습기 등의 외부 요인에 영향을 받지 않음 |
    | 멤리스터(Memristor) | - 메모리(Memory)와 레지스터(Resister)의 합성어로, 전류의 방향과 양 등 기존의 경험을 모두 기억하는 특별한 소자 
    
    - 레지스터(Resister), 커패시터(Capacitor), 인덕터(Inductor)에 이어 네 번째 전자회로 구성 요소라 불리고 있음  |
- Secure OS C
    - Secure OS
        - Secure OS는 기존의 운영체제(OS)에 내재된 보안 취약점을 해소하기 위해 보안 기능을 갖춘 커널을 이식하여 외부의 침입으로부터 시스템 자원을 보호하는 운영체제
        - 보안 커널은 보안 기능을 갖춘 커널을 의미하며, TCB를 기반으로 참조 모니터의 개념을 구현하고 집행한다
        - 보호 방법을 구현하기 복잡한 것부터 차례로 분류하면 다음과 같다.
            - 암호적 분리(Cryptographic Separation) : 내부 정보를 암호화하는 방법
            - 논리적 분리(Logical Separation) : 프로세스의 논리적 구역을 지정하여 구역을 벗어나는 행위를 제한하는 방법
            - 시간적 분리(Temporal Separation) : 동일 시간에 하나의 프로세스만 수행되도록 하여 동시 실행으로 발생하는 보안 취약점을 제거하는 방법
            - 물리적 분리(Physical Separation) : 사용자별로 특정 장비만 사용하도록 제한하는 방법
        - Secure OS의 보안 기능
            - 식별 및 인증
            - 임의적/강제적 접근통제
            - 객체 재사용 보호
            - 완전한 조정
            - 신뢰 경로
            - 감사 및 감사기록 축소 등
    - 참조 모니터(Reference Monitor)
        - 참조 모니터는 보호 대상 객체에 대한 접근통제를 수행하는 추상머신이며, 이것을 실제로 구현한 것이 보안 커널
        - 참조 모니터는 보안 커널 데이터베이스(SKDB; Security Kernel Database)를 참조하여 객체에 대한 접근 허가 여부를 결정
        - 참조 모니터와 보안 커널의 특징
            
            
            | 격리성(Isolation) | 부정 조작이 불가능해야 함 |
            | --- | --- |
            | 검증가능성(Verifiability) | 적절히 구현되었다는 것을 확인할 수 있어야 함 |
            | 완전성(Completeness) | 우회가 불가능해야 함 |
- DB 관련 신기술 A
    - DB 관련 신기술
        
        
        | 빅데이터(Big Data) | - 기존의 관리 방법이나 분석 체계로는 처리하기 어려운 막대한 양의 정형 또는 비정형 데이터 집합 
        
        - 빅데이터가 주목받고 있는 이유는 기업이나 정부, 포털 등이 빅데이터를 효과적으로 분석함으로써 미래를 예측해 최적의 대응 방안을 찾고, 이를 수익으로 연결하여 새로운 가치를 창출하기 때문 |
        | --- | --- |
        | 브로드 데이터
        (Broad Data) | - 다양한 채널에서 소비자와 상호 작용을 통해 생성된 것으로, 기업 마케팅에 있어 효율적이고 다양한 데이터이며, 이전에 사용하지 않거나 알지 못했던 새로운 데이터나 기존 데이터에 새로운 가치가 더해진 데이터 |
        | 메타 데이터
        (Meta Data) | - 일련의 데이터를 정의하고 설명해 주는 데이터 
        
        - 컴퓨터에서는 데이터 사전의 내용, 스키마 등을 의미 
        
        - HTML 문서에서는 메타 태그 내의 내용이 메타 데이터 |
        | 디지털 아카이빙
        (Digital Archiving) | - 디지털 정보 자원을 장기적으로 보존하기 위한 작업 
        
        - 아날로그 콘텐츠는 디지털로 변환한 후 압축해서 저장하고, 디지털 콘텐츠도 체계적으로 분류하고 메타 데이터를 만들어 DB화하는 작업 |
        | 하둡(Hadoop) | - 오픈 소스를 기반으로 한 분산 컴퓨팅 플랫폼 
        
        - 일반 PC급 컴퓨터들로 가상화된 대형 스토리지를 형성하고 그 안에 보관된 거대한 데이터 세트를 병렬로 처리할 수 있도록 개발된 자바 소프트웨어 프레임워크 
        
        - 구글, 야후 등에 적용되고 있음 |
        | 맵리듀스
        (MapReduce) | - 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델
        
        - 흩어져 있는 데이터를 연관성 있는 데이터 분류로 묶는 Map 작업을 수행한 후 중복 데이터를 제거하고 원하는 데이터를 추출하는 Reduce 작업을 수행
        
        - Google에 의해 고안되었으며, 대표적인 대용량 데이터 처리를 위한 병렬 처리 기법으로 많이 사용되고 있음 |
        | 타조(Tajo) | - 오픈 소스 기반 분산 컴퓨팅 플랫폼인 아파치 하둡(Apache Hadoop) 기반의 분산 데이터 웨어하우스 프로젝트 |
        | 데이터 다이어트
        (Data Diet) | - 데이터를 삭제하는 것이 아니라 압축하고, 중복된 정보는 중복을 배제하고, 새로운 기준에 따라 나누어 저장하는 작업 |
        | 데이터 마이닝
        (Data Mining) | - 대량의 데이터를 분석하여 데이터에 내재된 변수 사이의 상호 관계를 규명하여 일정한 패턴을 찾아내는 기법 |
        | OLAP(Online
        Analytical
        Processing) | - 다차원으로 이루어진 데이터로부터 통계적인 요약 정보를 분석하여 의사결정에 활용하는 방식 
        
        - OLAP 연산 : Roll-up, Drill-down, Drill-through, Drill-across, Pivoing, Slicing, Dicing |
- 회복 / 병행제어 A
    - 회복(Recovery)
        - 횝고은 트랜잭션들을 수행하는 도중 장애가 발생하여 데이터베이스가 손상되었을 때 손상되기 이전의 정상 상태로 복구하는 작업
        - 회복 기법의 종류
            
            
            | 회복 기법 | 설명 |
            | --- | --- |
            | 연기 갱신 기법
            (Deferred Update) | - 트랜잭션이 성공적으로 완료될 때까지 데이터베이스에 대한 실질적인 갱신을 연기하는 방법 
            
            - 트랜잭션이 수행되는 동안 갱신된 내용은 일단 Log에 보관 
            
            - 트랜잭션의 부분 완료 시점에 Log에 보관한 갱신 내용을 실제 데이터베이스에 기록 
            
            - Redo 작업만 가능 |
            | 즉각 갱신 기법
            (Immediate Update) | - 트랜잭션이 데이터를 갱신하면 트랜잭션이 부분 완료되기 전이라도 즉시 실제 데이터베이스에 반영하는 방법 
            
            - 장애가 발생하여 회복 작업할 경우를 대비하여 갱신된 내용들은 Log에 보관 
            
            - Redo와 Undo 모두 사용 가능 |
            | 그림자 페이지 대체 기법
            (Shadow Paging) | - 갱신 이전의 데이터베이스를 일정 크기의 페이지 단위로 구성하여 각 페이지마다 복사본인 그림자 페이지를 별도 보관 해 놓고, 실제 페이지를 대상으로 갱신 작업을 수행하다가 장애가 발생하여 트랜잭션 작업을 Rollback시킬 때는 갱신 이후의 실제 페이지 부분을 그림자 페이지로 대체하여 회복 시키는 기법 |
            | 검사점 기법
            (Check Point) | - 트랜잭션 실행 중 특정 단게에서 재실행할 수 있도록 갱신 내용이나 시스템에 대한 상황 등에 관한 정보와 함께 검사점을 로그에 보관해 두고, 장애 발생 시 트랜잭션 전체를 철회하지 않고 검사점부터 회복 작업을 수행하여 회복시간을 절약하도록 하는 기법  |
    - 병행제어(Concurrency Control)
        - 병행제어란 다중 프로그램의 이점을 활용하여 동시에 여러 개의 트랜잭션을 병행수행할 때, 동시에 실행되는 트랜잭션들이 데이터베이스의 일관성을 파괴하지 않도록 트랜잭션 간의 상호 작용을 제어하는 것
        - 병행제어 없이 트랜잭션들이 데이터베이스에 동시에 접근하도록 허용할 경우 갱신 분실, 비완료 의존성, 모순성, 연쇄 복귀 등의 문제가 발생한다
        - 병행제어 기법의 종류
            
            
            | 기법 | 설명 |
            | --- | --- |
            | 로킹(Locking) | - 트랜잭션들이 어떤 로킹 단위를 엑세스하기 전에 Lock(잠금)을 요청해서 Lock이 허락되어야만 그 로킹 단위를 액세스할 수 있도록 하는 기법 
            
            - 주요 데이터의 액세스를 상호 배타적으로 함 |
            | 타임 스탬프 순서
            (Time Stamp
            Ordering) | - 트랜잭션과 트랜잭션이 읽거나 갱신한 데이터에 대해 트랜잭션이 실행을 시작하기 전에 시간표(Time Stamp)를 부여하여 부여된 시간에 따라 트랜잭션 작업을 수행하는 기법 
            
            - 직렬성 순서를 결정하기 위해 트랜잭션 간의 처리 순서를 미리 선택하는 기법들 중에서 가장 보편적인 방법  |
            | 최적 병행수행
            (검증 기법, 확인
            기법, 낙관적 기법) | - 병행수행하고자 하는 대부분의 트랜잭션이 판독 전용(Read Only) 트랜잭션일 경우, 트랜잭션 간의 충돌률이 매우 낮아서 병행제어 기법을 사용하지 않고 실행되어도 이 중의 많은 트랜잭션은 시스템의 상태를 일관성 있게 유지한다는 점을 이용한 기법 |
            | 다중 버전 기법 | - 타임 스탬프의 개념을 이용하는 기법 
            
            - 다중 버전 타임 스탬프 기법이라고도 함 
            
            - 타임 스탬프 기법은 트랜잭션 및 데이터들이 이용될 때의 시간을 시간표로 관리하지만, 다중 버전 기법은 갱신될 때마다의 버전을 부여하여 관리 |
    - 로킹 단위(Locking Granularity)
        - 로킹 단위는 병행제어에서 한꺼번에 로킹할 수 있는 객체의 크기를 의미
        - 데이터베이스, 파일, 레코드, 필드 등이 로킹 단위가 될 수 있다
        - 로킹 단위가 크면 로크 수가 작아 관리하기 쉽지만 병행성 수준이 낮아진다
        - 로킹 단위가 작으면 로크 수가 많아 관리하기 복잡해 오버헤드가 증가하지만 병행성 수준이 높아진다.
- 교착상태 B
    - 교착상태(Dead Lock)
        - 교착상태는 상호 배제에 의해 나타나는 문제점으로, 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상을 의미
    - 교착상태 발생의 필요 충분 조건
        - 교착상태가 발생하기 위해서는 다음의 네 가지 조건이 충족되어야 하는데, 이 네 가지 조건 중 하나라도 충족되지 않으면 교착상태가 발생하지 않는다.
            
            
            | 조건 | 설명 |
            | --- | --- |
            | 상호 배제
            (Mutual Exclusion) | 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함 |
            | 점유와 대기
            (Hold and Wait) | 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함 |
            | 비선점
            (Non-preemption) | 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함 |
            | 환형 대기
            (Circular Wait) | 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성되어 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함 |
    - 교착상태의 해결 방법
        
        
        | 기법 | 설명 |
        | --- | --- |
        | 예방 기법
        (Prevention) | - 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법 
        
        - 교착상태 발생의 네 가지 조건 중에서 어느 하나를 제거함으로써 수행 
        
        - 자원의 낭비가 가장 심한 기법 |
        | 회피 기법
        (Avoidance) | - 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법 
        
        - 주로 은행원 알고리즘(Banker’s Algorithm)이 사용됨 
        
        - 은행원 알고리즘(Banker’s Algorithm) : E. J. Dijkstra가 제안한 것으로, 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래한 기법 |
        | 발견 기법
        (Detection) | - 시스템에 교착상태가 발생했는지 점검하여 교착상태에 있는 프로세스와 자원을 발견하는 것 
        
        - 교착상태 발견 알고리즘과 자원 할당 그래프 등을 사용할 수 있음 |
        | 회복 기법
        (Recovery) | - 교착상태를 일으킨 프로세스를 종료하거나 교착상태의 프로세스에 할당된 자원을 선점하여 프로세스나 자원을 회복하는 것 |

# 제품 소프트웨어 패키징

- 소프트웨어 패키징 D
    - 소프트웨어 패키징
        - 소프트웨어 패키징이란 모듈별로 생성한 실행 파일들을 묶어 배포용 설치 파일을 만드는 것
        - 개발자가 아니라 사용자를 중심으로 진행
        - 소스 코드는 향후 관리를 고려하여 모듈화하여 패키징
    - 패키징 작업 순서
        1. 기능 식별 
            - 작성된 코드의 기능을 확인
        2. 모듈화
            - 확인된 기능 단위로 코드들을 분류
        3. 빌드 진행
            - 모듈 단위별로 실행 파일을 만듦
        4. 사용자 환경 분석
            - 웹, 모바일, PC 등 소프트웨어가 사용될 환경이나 운영체제, CPU, RAM 등의 최소 운영 환경을 정의
        5. 패키징 및 적용 시험
            - 빌드된 실행 파일들을 정의된 환경에 맞게 배포용 파일 형식으로 패키징
            - 정의된 환경과 동일한 환경에서 패키징 결과를 테스팅한 후 소프트웨어에 대한 불편사항을 사용자 입장에서 확인
        6. 패키징 변경 개선
            - 확인된 불편 사항을 반영하기 위한 패키징의 변경 및 개선 진행
        7. 배포
            - 배포 수행 시 오류가 발생하면 해당 개발자에게 전달하여 수정을 요청
- 릴리즈 노트 작성 B
    - 릴리즈 노트(Release Note)
        - 릴리즈 노트는 소프트웨어 개발 과정에서 정리된 릴리즈 정보를 최종 사용자인 고객과 공유하기 위한 문서
        - 릴리즈 노트를 통해 테스트 진행 결과와 소프트웨어 사양에 대한 개발팀의 정확한 준수 여부를 확인할 수 있다
        - 소프트웨어에 포함된 전체 기능, 서비스의 내용, 개선 사항 등을 사용자와 공유할 수 있다.
    - 릴리즈 노트 작성 항목
        
        
        | 항목 | 내용 |
        | --- | --- |
        | Header(머릿말) | 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 릴리즈 노트 날짜, 릴리즈 노트 버전 등 |
        | 개요 | 소프트웨어 및 변경사항 전체에 대한 간략한 내용 |
        | 목적 | 해당 릴리즈 버전에서의 새로운 기능이나 수정된 기능의 목록과 릴리즈 노트의 목적에 대한 간략한 개요 |
        | 문제 요약 | 수정된 버그에 대한 간략한 설명 또는 릴리즈 추가 항목에 대한 요약 |
        | 재현 항목 | 버그 발견에 대한 과정 설명 |
        | 수정/개선 내용 | 버그를 수정/개선한 내용을 간단히 설명 |
        | 사용자 영향도 | 사용자가 다른 기능들을 사용하는데 있어 해당 릴리즈 버전에서의 기능 변화가 미칠 수 있는 영향에 대한 설명 |
        | SW 지원 영향도 | 해당 릴리즈 버전에서의 기능 변화가 다른 응용 프로그램들을 지원하는 프로세스에 미칠 수 있는 영향에 대한 설명 |
        | 노트 | SW/HW 설치 항목, 업그레이드, 소프트웨어 문서화에 대한 참고 항목 |
        | 면책 조항 | 회사 및 소프트웨어와 관련하여 참조할 사항 |
        | 연락처 | 사용자 지원 및 문의 응대를 위한 연락처 정보 |
    - 릴리즈 노트 작성 순서
        1. 모듈 식별
            - 모듈별 빌드 수행 후 릴리즈 노트에 작성될 내용 확인
        2. 릴리즈 정보 확인
            - 릴리즈 노트 이름, 소프트웨어 이름, 릴리즈 버전, 릴리즈 날짜, 노트 날짜, 노트 버전 등을 확인
        3. 릴리즈 노트 개요 작성
            - 소프트웨어 및 변경사항 전체에 대한 간략한 내용 작성
        4. 영향도 체크
            - 버그나 이슈 관련 내용 또는 해당 릴리즈 버전에서의 기능 변화가 다른 소프트웨어나 기능을 사용하는데 미칠 수 있는 영향에 대해 기술
        5. 정식 릴리즈 노트 작성
            - Header(머릿말), 개요, 영향도 체크 항목을 포함하여 정식 릴리즈 노트에 작성될 기본 사항을 작성
        6. 추가 개선 항목 식별
            - 추가 버전 릴리즈 노트 작성이 필요한 경우 추가 릴리즈 노트를 작성
- 디지털 저작권 관리(DRM) B
    - 저작권
        - 저작권이란 소설, 시, 논문, 강연, 연술, 음악, 연극, 무용, 회화, 서예, 건축물, 사진, 영상, 지도, 도표, 컴퓨터 프로그램 저작물 등에 대하여 창작자가 가지는 배타적 독점적 권리로, 타인의 침해를 받지 않을 고유한 권한
        - 컴퓨터 프로그램들과 같이 복제하기 쉬운 저작물에 대해 불법 복제 및 배포 등을 막기 위한 기술적인 방법을 통칭해 저작권 보호 기술이라고 한다
    - 디지털 저작권 관리(DRM; Digital Right management)
        - 디지털 저작권 관리는 저작권자가 배포한 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술
        - 원본 콘텐츠가 아날로그인 경우에는 디지털로 변환한 후 패키저(Packager)로 DRM 패키징을 수행
        - 패키징을 수행하면 콘텐츠에는 암호화된 저작권자의 전자서명이 포함되고 저작권자가 설정한 라이선스 정보가 클리어링 하우스(Clearing House)에 등록
    - 디지털 저작권 관리의 흐름 및 구성 요소
        
        ![Untitled](시나공_필기_1권/Untitled%2035.png)
        
        | 구성 요소 | 설명 |
        | --- | --- |
        | 클리어링 하우스
        (Clearing House) | 저작권에 대한 사용 권한, 라이선스 발급, 암호화된 키 관리, 사용량에 따른 결제 관리 등을 수행하는 곳 |
        | 콘텐츠 제공자
        (Contents Provider) | 콘텐츠를 제공하는 저작권자 |
        | 패키저(Packager) | 콘텐츠를 메나 데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램 |
        | 콘텐츠 분배자
        (Contents Distributor) | 암호화된 콘텐츠를 유통하는 곳이나 사람 |
        | 콘텐츠 소비자
        (Customer) | 콘텐츠를 구매해서 사용하는 주체 |
        | DRM 컨트롤러
        (DRM Controller) | 배포된 콘텐츠의 이용 권한을 통제하는 프로그램 |
        | 보안 컨테이너
        (Security Container) | 콘텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치 |
    - 디지털 저작권 관리의 기술 요소
        
        
        | 구성 요소 | 설명 |
        | --- | --- |
        | 암호화(Encryption) | 콘텐츠 및 라이선스를 암호화하고 전자 서명을 할 수 있는 기술 |
        | 키 관리(Key Management) | 콘텐츠를 암호화한 키에 대한 저장 및 분배 기술 |
        | 암호화 파일 생성(Packager) | 콘텐츠를 암호화된 콘텐츠로 생성하기 위한 기술 |
        | 식별 기술(Identification) | 콘텐츠에 대한 식별 체계 표현 기술 |
        | 저작권 표현(Right Expression) | 라이선스의 내용 표현 기술 |
        | 정책 관리(Policy Management) | 라이선스의 발급 및 사용에 대한 정책 표현 및 관리 기술 |
        | 크랙 방지(Tamper Resistance) | 크랙에 의한 콘텐츠 사용 방지 기술 |
        | 인증(Authentication) | 라이선스 발급 및 사용의 기준이 되는 사용자 인증 기술 |
- 소프트웨어 설치 매뉴얼 작성 C
    - 소프트웨어 설치 매뉴얼
        - 소프트웨어 설치 매뉴얼은 개발 초기에서부터 적용된 기준이나 사용자가 소프트웨어를 설치하는 과정에 필요한 내용을 기록한 설명서와 안내서
        - 설치 매뉴얼은 사용자 기준으로 작성
        - 설치 시작부터 완료할 때까지의 전 과정을 빠짐없이 순서대로 설명
        - 설치 과정에서 표시될 수 있는 오류 메시지 및 예외 상황에 관한 내용을 별도로 분류하여 설명
    - 설치 매뉴얼 작성 순서
        1. 기능 식별
            - 소프트웨어의 개발 목적과 주요 기능을 흐름 순으로 정리하여 기록
        2. UI 분류
            - 설치 매뉴얼을 작성할 순서대로 UI를 분류한 후 기록
        3. 설치 파일 / 백업 파일 확인
            - 폴더 위치, 설치 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록
        4. Uninstall 절차 확인
            - 직접 Uninstall을 수행하면서 그 순서를 단계별로 자세히 기록
        5. 이상 Case 확인
            - 설치 과정에서 발생할 수 있는 다양한 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록
        6. 최종 매뉴얼 적용
            - 설치가 완료된 화면과 메시지를 캡처하여 추가
            - 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록
- 소프트웨어 사용자 매뉴얼 작성 D
    - 소프트웨어 사용자 매뉴얼
        - 소프트웨어 사용자 매뉴얼은 사용자가 소프트웨어를 사용하는 과정에서 필요한 내용을 문서로 기록한 설명서와 안내서
        - 사용자 매뉴얼은 사용자가 소프트웨어 사용에 필요한 절차, 환경 등의 제반 사항이 모두 포함되도록 작성
        - 소프트웨어 배포 후 발생될 수 있는 오류에 대한 패치나 기능에 대한 업그레이드를 위해 매뉴얼의 버전을 관리
        - 개별적으로 동작이 가능한 컴포넌트 단위로 매뉴얼을 작성
        - 사용자 매뉴얼은 컴포넌트 명세서와 컴포넌트 구현 설계서를 토대로 작성
    - 사용자 매뉴얼 작성 순서
        1. 기능 식별
            - 소프트웨어의 개발 목적과 사용자 활용 기능을 흐름 순으로 정리하여 기록
        2. 사용자 화면 분류
            - 사용자 화면을 메뉴별로 분류하여 기록
        3. 사용자 환경 파일 확인
            - 폴더 위치, 사용자 로그 파일, 백업 파일 등의 개별적인 기능을 확인하여 기록
        4. 초기화 절차 확인
            - 프로그램을 사용하기 위한 초기화 절차를 확인하고 그 단계를 순서대로 기록
        5. 이상 Case 확인
            - 소프트웨어 사용 과정에서 발생할 수 있는 다양한 이상 Case를 만들어 확인하고 해당 Case에 대한 대처법을 자세하게 기록
        6. 최종 매뉴얼 적용
            - 사용과 관련된 문의 답변(FAQ)을 정리하여 기록
            - 완성된 매뉴얼을 검토하고 고객 지원에 대한 내용을 기록
- 소프트웨어 버전 등록 A
    - 소프트웨어 패키징의 형상 관리
        - 형상 관리(SCM; Software Configuration Management)는 개발 과정에서 소프트웨어의 변경 사항을 관리하기 위해 개발된 일련의 활동
        - 형상 관리는 소프트웨어 개발의 전 단계에 적용되는 활동이며, 유지보수 단계에서도 수행
        - 형상 관리는 소프트웨어 개발의 전체 비용을 줄이고, 개발 과정의 여러 방해 요인이 최소화되도록 보증하는 것을 목적으로 함
        - 대표적인 형상 관리 도구에는 Git, SVN, CVS 등이 있다
    - 형상 관리 기능
        
        
        | 기능 | 내용 |
        | --- | --- |
        | 형상 식별 | 형상 관리 대상에 이름과 관리 번호를 부여하고, 계층(Tree) 구조로 구분하여 수정 및 추적이 용이하도록 하는 작업 |
        | 버전 제어 | 소프트웨어 업그레이드나 유지 보수 과정에서 생성된 다른 버전의 형상 항목을 관리하고, 이를 위해 특정 절차와 도구(Tool)를 결합시키는 작업 |
        | 형상 통제 | 식별된 형상 항목에 대한 변경 요구를 검토하여 현재의 기준선(Base Line)이 잘 반영될 수 있도록 조정하는 작업 |
        | 형상 감사 | 기준선의 무결성을 평가하기 위해 확인, 검증, 검열 과정을 통해 공식적으로 승인하는 작업 |
        | 형상 기록 | 형상의 식별, 통제, 감사 작업의 결과를 기록, 관리하고 보고서를 작성하는 작업 |
    - 소프트웨어의 버전 등록 관련 주요 기능
        
        
        | 항목 | 설명 |
        | --- | --- |
        | 저장소(Repository) | - 최신 버전의 파일들과 변경 내역에 대한 정보들이 저장되어 있는 곳 |
        | 가져오기(Import) | 버전 관리가 되고 있지 않은 아무것도 없는 저장소(Repository)에 처음으로 파일을 복사 |
        | 체크아웃(Check-Out) | - 프로그램을 수정하기 위해 저장소(Repository)에서 파일을 받아옴
        
        - 소스 파일과 함께 버전 관리를 위한 파일들도 받아온다. |
        | 체크인(Check-In) | - 체크아웃 한 파일의 수정을 완료한 후 저장소(Repository)의 파일을 새로운 버전으로 갱신 |
        | 커밋(Commit) | - 체크인을 수행할 때 이전에 갱신된 내용이 있는 경우에는 충돌(Conflict)을 알리고 diff 도구를 이용해 수정한 후 갱신을 완료한다. |
        | 동기화(Update) | - 저장소에 있는 최신 버전으로 자신의 작업 공간을 동기화한다. |
    - 소프트웨어 버전 등록 과정
        1. 가져오기(Import)
            - 개발자가 저장소에 신규로 파일을 추가
        2. 인출(Check-Out)
            - 수정 작업을 진행할 개발자가 저장소에 추가된 파일을 자신의 작업 공간으로 인출
        3. 예치(Commit)
            - 인출한 파일을 수정한 후 설명을 붙여 저장소에 예치
        4. 동기화(Update)
            - 커밋(Commit) 후 새로운 개발자가 자신의 작업 공간을 동기화(Update)함. 이때 기존 개발자가 추가했던 파일이 전달됨
        5. 차이(Diff)
            - 새로운 개발자가 추가된 파일의 수정 기록(Change Log)을 확인하면서 이전 개발자가 처음 추가한 파일과 이후 변경된 파일의 차이를 확인
- 소프트웨어 버전 관리 도구 C
    - 공유 폴더 방식
        - 공유 폴더 방식은 버전 관리 자료가 지역 컴퓨터의 공유 폴더에 저장되어 관리 되는 방식
        - 파일을 잘못 복사하거나 다른 위치로 복사하는 것에 대비하기 위해 파일의 변경 사항을 데이터베이스에 기록하여 관리
        - 종류 : SCCS, RCS, PVCS, QVCS 등
    - 클라이언트/서버 방식
        - 클라이언트/서버 방식은 버전 관리 자료가 서버에 저장되어 관리 되는 방식
        - 모든 버전 관리는 서버에서 수행
        - 서버에 문제가 생기면 서버가 복구되기 전까지 다른 개발자와의 협업 및 버전 관리 작업은 중단
        - 종류 : CVS, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce 등
    - 분산 저장소 방식
        - 분산 저장소 방식은 버전 관리 자료가 하나의 원격 저장소와 분산된 개발자 PC의 지역 저장소에 함께 저장되어 관리되는 방식
        - 지역 저장소에서 버전 관리가 가능하므로 원격 저장소에 문제가 생겨도 지역 저장소의 자료를 이용하여 작업 가능
        - 종류 : Gti, GNU arch, DCVS, Bazaar, Mercurial, TeamWare, Bitkeeper, Plastic SCM 등
    - Subversion(서브버전, SVN)
        - Subversion은 CVS를 개선한 것으로, 아파치 소프트웨어에 재단에서 2000년에 발표
        - 클라이언트/서버 구조로, 서버(저장소, Repository)에는 최신 버전의 파일들과 변경 사항이 관리된다.
        - 소스가 오픈되어 있어 무료로 사용할 수 있다
        - CVS의 단점이었던 파일이나 디렉터리의 이름 변경, 이동 등이 가능하다
        - Subversion의 주요 명령어
            
            
            | 명령어 | 의미 |
            | --- | --- |
            | add | - 새로운 파일이나 디렉터리를 버전 관리 대상으로 등록한다.
            
            - add로 등록되지 않은 대상은 commit이 적용되지 않는다. |
            | commit | - 버전 관리 대상으로 등록된 클라이언트의 소스 파일을 서버의 소스 파일에 적용한다. |
            | update | - 서버의 최신 commit 이력을 클라이언트의 소스 파일에 적용한다.
            
            - commit 전에는 매번 update를 수행하여 클라이언트에 적용되지 않은 서버의 변동 내역을 클라이언트에 적용한다. |
            | checkout | - 버전 관리 정보와 소스 파일을 서버에서 클라이언트로 받아온다. |
            | lock/unlock | - 서버의 소스 파일이나 디렉터리를 잠그거나 해제한다. |
            | import | - 아무것도 없는 서버의 저장소에 맨 처음 소스 파일을 저장하는 명령으로, 한 번 사용하면 다시 사용하지 않는다. |
            | export | - 버전 관리에 대한 정보를 제외한 순수한 소스 파일만을 서버에서 받아온다. |
            | info | - 지정한 파일에 대한 위치나 마지막 수정 일자 등에 대한 정보를 표시한다. |
            | diff | - 지정된 파일이나 경로에 대해 이전 리비전과의 차이를 표시한다. |
            | merge | - 다른 디렉터리에서 작업된 버전 관리 내역을 기본 개발 작업과 병합한다. |
    - Git(깃)
        - Git은 리누스 토발즈(Linus Torvalds)가 2005년 리눅스 커널 개발에 사용할 관리 도구로 개발한 이후 주니오 하마노(Junio Hamano)에 의해 유지 보수되고 있다
        - Git은 분산 버전 관리 시스템으로 2개의 저장소, 즉 지역 저장소와 원격 저장소가 존재
        - 버전 관리가 지역 저장소에서 진행되므로 버전 관리가 신속하게 처리되고, 원격 저장소나 네트워크에 문제가 있어도 작업이 가능
        - Git의 주요 명령어
            
            
            | 명령어 | 의미 |
            | --- | --- |
            | add | - 작업 내용을 지역 저장소에 저장하기 위해 스테이징 영역(Staging Area)에 추가한다.
            
            - ‘—all’ 옵션으로 작업 디렉터리의 모든 파일을 스테이징 영역에 추가할 수 있다. |
            | commit | - 작업 내역을 지역 저장소에 저장한다. |
            | branch | - 새로운 브랜치를 생성한다.
            
            - 최초로 commit을 하면 마스터(master) 브랜치가 생성된다.
            
            - commit할 때마다 해당 브랜치는 가장 최근의 commit한 내용을 가리키게 된다. 
            
            - ‘-d’ 옵션으로 브랜치를 삭제할 수 있다. |
            | checkout | - 지정한 브랜치로 이동한다.
            
            _ 현재 작업 중인 브랜치는 HEAD 포인터가 가리키는데, checkout 명령을 통해 HEAD 포인터를 지정한 브랜치로 이동시킨다. |
            | merge | - 지정한 브랜치의 변경 내역을 현재 HEAD 포인터가 가리키는 브랜치에 반영함으로써 두 브랜치를 병합한다. |
            | init | - 지역 저장소를 생성한다. |
            | remote add | - 원격 저장소에 연결한다. |
            | push | - 로컬 저장소의 변경 내역을 원격 저장소에 반영한다. |
            | fetch | - 원격 저장소의 변경 이력만을 지역 저장소로 가져와 반영한다. |
            | clone | - 원격 저장소의 전체 내용을 지역 저장소로 복제 |
- 빌드 자동화 도구 B
    - 빌드 자동화 도구
        - 빌드 자동화 도구는 빌드를 포함하여 테스트 및 배포를 자동화하는 도구
        - 애자일(Agile)과 같은 지속적인 통합(Continuous Integration) 개발 환경에서 유용하게 활용
        - 빌드 자동화 도구에는 Ant, Make, Maven, Gradle, Jenkins 등이 있으며, 이중 Jenkins와 Gradle이 가장 대표적
    - Jenkins
        - Jenkins는 JAVA 기반의 오픈 소스 형태로, 서블릿 컨테이너에서 실행되는 서버 기반 도구
        - 가장 많이 사용되는 빌드 자동화 도구
        - SVN, Git 등 대부분의 형상 관리 도구와 연동이 가능
        - 친숙한 Web GUI 제공으로 사용이 쉽다
    - Gradle
        - Gradle은 Grooby를 기반으로 한 오픈 소스 형태의 자동화 도구
        - 안드로이드 앱 개발 환경에서 사용
        - 안드로이드뿐만 아니라 플러그인을 설정하면 JAVA, C/C++, Python 등의 언어도 빌드 가능
        - Groovy를 사용해서 만든 DSL(Domain Specific Language)을 스크립트 언어로 사용