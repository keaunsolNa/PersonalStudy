# TLB (Transition Look-aside Buffer)

![Untitled](TLB%20(Transition%20Look-aside%20Buffer)%20d9f5f9d348cc4f7799163ee3f20a39ec/Untitled.png)

# 정의

- 최근에 사용한 트랜잭션을 추적하는 데 사용되는 특수 캐시다.
    - 더 빠른 검색을 위해 가상 메모리의 최근 변환을 실제 주소로 저장하는 메모리 캐시의 유형.
    - TLB에는 VPN(Virtual Page Number)와 PFN(Physical Frame Number) 정보가 쌍으로 존재하며 이를 사용해 주소 변환을 하도록 도와준다.
    - 그 외에도 실제 페이지가 주 메모리에 있는 위치에 대한 정보, 유효/유효하지 않은 비트, 수정 여부에 대한 더티 비트, page table에서 같은 page에 접근할 수 있는지 확인하는 보호 비트 등의 비트 정보가 포함되어 있다.
- 가장 최근에 사용된 페이지 테이블 항목(PTE)이 포함되어 있으며, 가상 주소가 주어지면 프로세서는 페이지 테이블 항목이 존재하는지 (TLB Hit) TLB를 검사하고 프레임 번호를 검색하여 실제 주소가 형성된다.
    - 이 시점에서 TLB가 물리적 메모리의 위치에 대한 빠른 참조를 확인한다. 과정은 다음과 같다.
        - CPU가 가상 주소(논리 주소)를 생성한다.
        - 주소는 TLB에서 확인된다.
        - 주소가 있으면 해당 프레임 번호가 검색된다
        - CPU는 페이지가 주 메모리의 어디에 있는지 확인 가능하다.
    - TLB Hit은 기본적으로 Temporal Locality 개념을 사용하여 TLB Hit Rate를 높인다.
- TLB에 페이지 테이블 엔트리가 없으면 (TLB Miss) 페이지 테이블을 처리하는 동안 해당 페이지 번호를 인덱스로 사용한다.
    - 메모리 페이지 크롤링 작업을 통해 물리적 메모리를 검색하며, 가상 메모리 주소가 변환되면 참조된 값이 TLB에 추가된다.
    - 대부분의 프로세서에는 고유한 대기 시간을 통해 가상 메모리 작업 속도를 높이기 위해 TLB가 포함되어 있다. 과정은 다음과 같다.
        - CPU는 가상 주소를 생성한다
        - 주소는 TLB에서는 확인되지만 실제로 존재하진 않는다.
        - 페이지 번호는 주 메모리에 있는 페이지 테이블과 일치한다
        - 해당 프레임 번호가 검색된다
        - CPU는 페이지가 주 메모리의 어디에 있는지 확인 가능하다
        - TLB가 새로운 PTE로 업데이트 된다.
- TLB는 먼저 페이지가 이미 주 메모리에 있는지 확인하고, 주 메모리에 없으면 페이지 오류가 발생한 다음 TLB가 새 페이지 항목을 포함하도록 업데이트한다.
- TLB를 사용하면 레지스터에 PTE를 배치할 필요가 없다. 또는 두 개의 주 메모리 참조가 필요한 주 메모리에 전체 페이지 테이블을 유지할 필요가 없다.
- TLB는 참조 지역성 개념을 기반으로 한다. 즉, 중앙 처리 장치가 자주 액세스해야 하는 페이지의 항목만 포함한다.
- TLB는 레지스터보다 저렴하고 크기가 크며, 주 메모리보다 빠르고 작은 메모리 유형이다.
- 메모리 주소가 TLB에 저장되어 있고 거기에서 검색할 수 있다면(TLB HIT) 속도가 향상된다.
- 단, TLB는 멀티태스킹 및 코드 오류로 인해 성능 문제가 발생할 수 있다.
- 캐시 스레시(cache thrash)라고 하는 성능 저하는 리소스의 과도한 사용이나 캐싱 시스템의 충돌로 인해 진행되지 않는 지속적인 컴퓨터 활동으로 인해 발생한다.

# 이슈

### Context Switches

- TLB 사용 시 Context Switch가 발생할 경우, 여러 프로세스가 각자 자신의 가상 메모리 공간이 존재하며 각자의 가상 메모리 공간이 Page로 쪼개지며 많은 프로세스가 존재할 경우, Page Table의 Index가 같은 경우가 발생할 수 있다.
    - 이 경우 어떤 정보가 어떤 프로세스의 정보인지 확인할 수 없으며, 프로세스에서 서로의 주소 공간이 아닌 곳에 접근할 수 있게 된다.
- 위 문제를 해결하기 위한 방법 중 하나는 Flush로, Context Switch가 발생할 때 기존 프로세스의 주소변환 정보를 TLB에서 모두 지워버리는 방법이 있다.
    - Flush는 TLB의 주소 변환 정보 중 Valid 비트의 값을 0으로 초기화함으로서 수행한다.
    - 단, Context Switch마다 추가 작업으로 인한 비용이 발생하며, Page Table을 매번 다시 접근해야 하는 문제가 발생한다.
        - 위의 오버헤드를 줄이기 위한 방법으로는 TLB 구조에 ASID(Address Space Indentifier)를 추가하는 방법이 있다. 프로세스마다 다른 ASID 정보를 통해 각 프로세스를 식별함으로서 HW 레벨에서 문제를 해결하는 것이다.

### Replacement Policy

- TLB에 저장 공간이 가득 찬 경우에 새로운 프로세스가 실행 될 때, TLB의 어떤 데이터를 지워야 하는지에 대한 이슈다.
    - 일반적인 방법으로는 LRU(Least Recently Used Algorithm) 혹은 Random 제거 방식이 있다.