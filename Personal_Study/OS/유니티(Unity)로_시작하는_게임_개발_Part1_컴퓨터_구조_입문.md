# 유니티(Unity)로 시작하는 게임 개발: Part 1. 컴퓨터 구조 입문

# Section 0. Majors And Programmers

- 전공자가 프로그래머가 되는 이유
    - 1단계 : 기초 프로그래밍
    - 2단계 : 미니 프로젝트
    - 3단계 : 큰 프로젝트
    - 각각은 방법론이 모두 다르다.
    - 강의의 목표는 컴퓨터에 익숙함을 가지고, 프로그래밍을 생각하면서 컴퓨터의 동작을 이해하는 것에 있다.
- 비 전공자의 접근 방법
    - 컴퓨터에 많이 노출되고, 프로그래밍을 많이 해 봐야 한다.
    - 비 전공자는 핵심적인 내용을 이해하고 외워, 장기 기억으로 만들어야 한다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled.png)
        
- 비 전공자의 학습과 연습
    - 강의 중 학습 도구로는 Evernote와 구글 Spread Sheet를 사용한다.

# Section 1. B**asic Computer Architecture**

- Binary Number And Bit
    - 10진법 : 0부터 9까지의 숫자로 수로 표현
    - 2진법 : 0부터 1까지의 숫자로 수를 표현
    - 자릿수 : 왼쪽부터 한 칸씩 올려가며 진법 수만큼 곱한 값의 의미
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%201.png)
        
    - 비트(Bit) : 2진수에서 자릿수 하나
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%202.png)
        
    - 바이트(Byte) : 8개의 비트를 모아서 사용하는 컴퓨터에서 사용하는 기본 단위
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%203.png)
        
- Principle of Computer Storage
    
    ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%204.png)
    
    ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%205.png)
    
    - 전기는 물과 유사한 성질을 가지고 있다. 단, 전기는 복사가 가능하다.
    - 정보를 저장할 공간은 메모리 공간, 저장 공간, 기억 장소로 칭할 수 있다. 이 때 복사는 같은 값으로 만들어 기억 장소를 복사하는 것이다.
- A Numerical Unit of Information
    - 정보의 숫자 단위는 Bit - Byte - kByte - MByte - GByte - TByte로 이루어진다.
        - 2의 10승 * 2의 10승 * 2의 10승—-
- Memory of Data
    - 메모리의 사용은 메모리에 생기고, 메모리에서 사용하고, 메모리에서 사라지는 과정을 거친다. 즉, 실행 시 프로그램과 데이터가 메모리에 올라갔다가 사라진다.
    - 복사는 원본에 영향을 미치지 않고 원본 파일을 복사하여 메모리에 올리는, 데이터가 같아지는 것이다.
    - 이동은 원본에 영향을 미치며 복사를 하고 난 뒤 (메모리에 올린 뒤), 원본을 지우는 것이다.
    - 데이터 메모리 : 메모리에 지정해 놓은 영역, 실행 시 데이터 메모리에 데이터가 생겨나고, 사용되고, 사라진다.
- Machine Language And Program
    - 기계어 : 컴퓨터가 받아들여 실행할 수 있는(이해할 수 있는) 언어
    - 프로그램 : 원하는 기능을 가지는 명령의 집합 (원하는 기능의 기계어의 집합)
    - 프로그래밍 : 프로그램을 만드는 작업
        - 기계어를 직접 만드는 작업
        - 프로그래밍 언어를 통해 프로그램을 만드는 작업
- Program Memory
    - 폰노이만 컴퓨터 구조 : 프로그램을 변경해서 실행할 수 있는 것.
    - 코드의 동작은 메모리의 특정 공간인 프로그램 메모리(코드 메모리, 코드를 실행하기 위해 프로그램의 복사할 영역을 지정한 영역)에 기계어를 복사, 변경해서 실행한다.
    - 폰노이만 구조에서 제일 핵심은 프로그램의 변경이며, 프로그램은 프로그램 메모리에 복사 된다.
    - 이후 프로그램 메모리에 있는 프로그램이 한 줄 한 줄 실행된다.
- Program Memory And Data Memory
    
    ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%206.png)
    
    - 실제 프로그램의 동작은 하나의 메모리 안에서 프로그램 메모리와 데이터 메모리로 나뉘어 이루어진다. 프로그램 메모리에 명령어가 저장되고, 데이터 메모리에 필요한 값들이 저장된다.
    - 즉, 프로그램 메모리에서 프로그램을 가지고 있으며, 프로그램이 실행될 때 필요한 데이터 메모리가 생겨난다. 이 때 프로그램은 다른 프로그램으로 변경도 가능하다.
    - 프로그램은 프로그래밍 메모리에 올라가고, 데이터는 데이터 메모리에 만들어진다.
    - 기계어가 실행되면서 데이터 메모리를 필요에 따라 생성하고 사용하고 해제한다.
    - 프로그램 메모리와 데이터 메모리는 구분되어 동작한다.
- CPU
    - CPU는 Centrol Processing Unit으로, 연산장치라고 한다.
    - CPU의 PC, Program Counter는 현재 실행되는 프로그램의 위치를 저장하는 역할을 한다.
    - 즉, Program Counter가 올라가면서 프로그램이 실행된다.
    - CPU : 연산을 처리하는 장치
    - 프로그램 카운터 : 실행되는 프로그램의 위치를 저장. Fit이라고도 한다.
    - 프로그램 카운터가 계속 올라가면서 실행된다.
- Clock Generator
    - 수정(Crystal)의 경우 전기 인가 시 진동(사인파, Sine Wave)이 일어난다.
    - 이 사인파를 디지털 신호로 바꾼 뒤, 해당 신호를 컴퓨터의 심장으로 사용할 수 있다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%207.png)
        
    - 클럭 발생기의 신호가 올라가는(변경되는) 순간(Rising Edge)이 프로그램이 실행되는 순간이다.
    - Rising Edge가 종료된 후, 다음 Rising Edge가 실행되는 순간이 PC(Program Counter)가 증가하는 순간이다.

# Section 2. **Principles of Programming Languages**

- Machine Language
    - 기계어는 CPU에 따라 명령의 값이 다르다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%208.png)
        
    - 명령이 다른 것 뿐만 아니라, 명령에 따라 뒤에 나오는 내용도 그 의미가 달라진다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%209.png)
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2010.png)
        
    - 기계어를 사용하기 위해서는 CPU를 정확하게 알아야 한다.
    - 각각의 명령에 따라 뒤에 나오는 구조가 변한다.
    - 단, 현대에는 기계어를 사용하여 프로그래밍을 하지 않는다.
- Introduction to Assembly Language
    - 기계어를 좀 더 인간이 읽기 쉽게 하기 위한 언어가 Assembly Language다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2011.png)
        
    - Assembly Language는 명령어에 숫자가 아닌 의미를 부여한다.
    - 따라서 Assembly Language는 명령어가 실행되는 하부 구조를 신경 쓰지 않는다.
    - 모든 프로그램 개발 언어는 High Level과 Low Level로 구분한다.
    - 즉, 모든 것을 알고 작업하지 않으며, 초보자 입장에서 하부 구조를 아는 것은 상부 구조를 쉽게 이해하기 위함에 목적이 있다.
- High And Low Level
    - High Level과 Low Level은 두 항목을 비교했을 때의 의미다. ( 기계어 → Assembly Language → C Language)
    - C언어는 Assembley Language로 변환 후 기계어로 변환된다.
    - 프로그래밍이 High Level로 발전되는 이유는 시간을 어디에 사용할 것인가에 초점을 맞춤이다. (High Level일 수록 Low Level에 대한 학습 필요가 적어진다. 물론, 알면 좋다.)
        - C#언어는 C언어를 포함하는 관계를 가진다.
- C Language And Variables
    
    ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2012.png)
    
    - C 언어에서 선언은 위와 같이 이루어진다.
    - Assembly Language는 값을 메모리에 저장하기 위해 주소를 사용하지만, C 언어는 변수 이름을 사용한다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2013.png)
        
    - 변수는 메모리의 특정 공간(주소)에 이름을 붙이는 작업이다.
- Meaning of Variable
    - 프로그래밍적 접근 방법은 코드의 의미를 살펴가면서 프로그램을 작성한다.
    - 메모리적 접근 방법은 실제 메모리의 값을 따져가면서 프로그램을 작성, 분석한다.
    - 변수를 선언하여 메모리를 사용한다.
    - 메모리의 주소가 아니라 변수의 이름을 사용하여 데이터 중심으로 프로그램을 작성한다.
    - 프로그래밍적 접근 방법으로 작성하고, 메모리적 접근 방법으로 분석한다.
- Why Compilation Is Necessary
    - Complie은 언어를 변환(C 언어 → Assembly Language)하는 것이다.
    - Assembly Language와 달리, C 언어에서 Complie이 필요한 이유는 C가 변수를 사용하며, 변수가 가지고 있는 주소 값을 알지 못 하기 때문이다.
    - 즉, 컴파일 시 변수가 어떤 메모리를 사용하는지에 대한 표(테이블)이 필요하다.
        - 이 때 변수와 주소를 Linking 한다.
    - High Level로 발전할 수록 컴퓨터의 자원보다 개발 환경의 편이성이 더 중요해진다.
    - 단, 이로 인해 Overhead(기능이 추가되면서 더 많은 성능을 필요로 하는 현상)가 증가한다.
- Types of Memory and Stack Memory
    - 언어마다 메모리의 종류는 다르다. C언어는 Stack, Heap, Static이 있다.
    - Stack은 빠르게 사용하는 쌓이는 메모리의 종류이며
    - Heap은 큰 자료를 관리하기 위한 메모리이다.
    - Static은 공통으로 공유하여 사용하는 메모리이다.
    - Stack은 아래에서 위로 쌓이는 메모리 구조를 가지고 있다.
    - Stack 메모리는 사용이 끝나면 사라진다.
    - Heap 메모리의 Heap은 늘어놓다, 모아 놓는다는 의미가 있다.
    - Heap 메모리는 주로 크기가 큰 데이터에 사용된다.
    - Static은 정적인, 고정된의 의미가 있다.
    - Static은 데이터를 공유하여 사용한다.
    - 메모리가 구분되어 있는 이유는 데이터의 종류에 따라 최대의 속도와 최적의 상황으로 사용하기 위함이다.
    - C#언어에서 기본 자료로 사용되는 변수의 메모리는 Stack으로 동작한다.
- Heap Memory
    
    ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2014.png)
    
    - Heap은 Class나 큰 크기의 데이터에 주로 사용된다.
    - Reference는 참조로, Window의 바로가기와 유사하다.
    - Reference 변수가 주소를 가지고 있다는 뜻은 실제 데이터 위치의 값을 가리킨다는 의미이다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2015.png)
        
    - 이는 일반 변수가 담고 있는 것이 실제 값인 것과의 차이이다.
    - 즉, 변수가 참조를 가지고 있다는 뜻은 변수가 실제 데이터를 가리키고 있다는 의미이다.
        - Reference와 Heap이 위와 같은 방식으로 작동한다.
- Introduction to Functions
    - 함수는 반복되는 동작을 코드로 표현한 것이다.
    - 이 때 반복되는 동작은 원하는 대로 사용할 수 있다.
        - 즉, 복잡한 동작을 함수로 대체하여 사용한다.
    - 함수는 함수의 몸체인 구현부와 사용되는 부분인 호출부로 나뉘어진다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2016.png)
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2017.png)
        
- Principle of C# delegate
    - 함수 전체를 함수의 저장 공간에 저장할 수 있다.
        
        ![Untitled](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/Untitled%2018.png)
        
    - 함수를 저장하는 것은 함수를 다른 곳에서도 사용하기 위함이다.
    - Delegate는 대리자라는 의미로, 대리자를 두고 함수를 대리자가 호출하도록 하는 기능이다.
    - Delegate가 없어도 사용에는 지장이 없지만, 타이핑을 줄이고 프로그래밍을 효율적으로 하기 위해 사용한다.
    - Delegate는 상황에 따라 다른 동작이 실현되는 것이 핵심이다.
        - Delegate가 실행 될 때, 상황에 따라 Delegate 안의 내용인 함수가 달라진다.

[수료증](유니티(Unity)로_시작하는_게임_개발_Part1_컴퓨터_구조_입문/1140493-325594-11756908.pdf)