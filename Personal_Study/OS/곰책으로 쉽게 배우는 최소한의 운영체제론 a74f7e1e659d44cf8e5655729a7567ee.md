# 곰책으로 쉽게 배우는 최소한의 운영체제론

# 본격적인 수업에 앞서

- 컴퓨터가 3층 집인 건 알고 있죠?
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled.png)
    
    - 컴퓨터는 H/W (Physical), S/W(Kernel, Logical, Vartical), User(App, Secure)의 3 계층으로 이루어져 있다.
    - 컴퓨터가 주변 기기와 통신할 때 주로 Interrupt가 발생한다.
    - 컴퓨터가 주변 기기에 요청을 할 때마다 발생하는 것이 Interrupt, 개별 요청 각각은 IRQ(Interrupt Request)
    - IRQ는 각각 번호를 가지는데, 이 번호는 운영체제마다, 장치마다 다르다.

# 컴퓨터의 구조와 성능 향상

- 인터럽트에서 DirectX까지
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%201.png)
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%202.png)
    
    - 인터럽트란 사적적 의미로는 “끼어들다’, ‘중단시키다’정도의 의미를 가진 말로 프로그램을 실행하는 도중에 얘기치 않은 상황이 발생할 경우 현재 실행중인 작업을 중단하고 발생한 상황을 처리한 후 다시 실행중인 작업으로 복귀하는 것.
    - 인터럽트의 종류는 외부 인터럽트, 내부 인터럽트, 소프트웨어 인터럽트로 나뉠 수 있다.
    - 외부 인터럽트
        - 전원 이상 인터럽트(Power fall Interrupt) : 말 그대로 정전, 파워 이상 등
        - 기계 착오 인터럽트(Machine check Interrupt) : CPU의 기능적인 오류
        - 외부 신호 인터럽트(External Interrupt)
            - 타이머에 의한 인터럽트: Preemptive 개념으로, 자원이 할당된 시간이 다 끝난 경우
            - 키보드로 인터럽트 키를 누른 경우 (Ex: control + Alt + Delete)
            - 외부장치로부터 인터럽트 요청이 있는 경우 : I/O 인터럽트가 아닌 다른 개념.
        - 입출력 인터럽트(I/O Interrupt)/
            - 입출력장치가 데이터 전송을 요구하거나 전송이 끝나 다음 동작이 수행되어야 할 경우
            - 입출력 데이터에 이상이 있는 경우
    - 내부 인터럽트
        - 잘못된 명령이나 잘못된 데이터를 사용할 때 발생하며 Trap이라 부른다.
    - 소프트웨어 인터럽트(SVC: SuperVisor Call)
        - 사용자가 프로그램을 실행시키거나 감시프로그램(Supervisor)를 호출하는 동작을 수행하는 경우
        - 소프트웨어 이용중 다른 프로세스를 실행시키면 시분할 처리를 위해 지원 할당 등의 동작이 수행된다.
    - 인터럽트 동작 순서
        1. 인터럽트 요청
        2. 프로그램 실행 중단 : 현재 실행중이던 Micro operation 까지 수행한다.
        3. 현재의 프로그램 상태 보존 : PCB(Process Control Block), PC(Program Counter)등 
        4. 인터럽트 처리루틴 실행 : 인터럽트를 요청한 장치를 식별한다.
        5. 인터럽트 서비스 루틴 실행 : 
            1. 인터럽트 원인을 파악하고 실질적인 작업을 수행한다. 
            2. 처리기 레지스터 상태를 보존한다. 
            3. 서비스 루틴 수행 중 우선순위가 더 높은 인터럽트가 발생하면 재귀적으로 1-5를 수행한다.
        6. 상태복구 : 인터럽트 발생 시 저장해둔 PC(Program counter)를 다시 복구한다.
        7. 중단된 프로그램 실행 재개 : PC의 값을 이용하여 이전에 수행중이던 프로그램을 재개한다.
    - 인터럽트 우선순위
        - 여러 장치에서  인터럽트가 동시에 발생하거나 인터럽트 서비스 루틴 수행 중 인터럽트가 발생했을 경우 우선순위를 따져서 처리한다.
            1. 전원 이상(Power fall)
            2. 기계 착오(Machine Check)
            3. 외부 신호(External)
            4. 입출력(I/O)
            5. 명령어 잘못
            6. 프로그램 검사(Program Check)
            7. SVC(SuperVisor Call)
        - 일반적으로 하드에어 인터럽트가 소프트웨어 인터럽트보다, 내부 인터럽트 보다 외부 인터럽트가 우선 순위가 높다.
    - DirectX는 user 계층에서 Kernel계층으로 GDI 엔진 등을 거치지 않고, 계층 간 인터럽트를 감소시킨다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%203.png)
        
    - 즉, DirectX는 계층 간 이동에 따른 인터럽트를 감소시키기 위함이 목적.
- DMA와 고성능 소켓
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%204.png)
    
    - DMA(Direct memory access) : 기존 인터럽트 간의 통신에서RAM과 RAM 사이의 불필요한 계층 이동을 줄이기 위한 것.
    - 파일의 송-수신을 예시로 하면, NIC에서 Driver TCP/IP, Process의 과정을 거치지 않고, NIC에서 Process의 Buffer영역에 바로 다이렉트로 파일을 보낼 수 있다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%205.png)
        
    - 가상환경의 경우, user - kernel - h/w → h/w - kernel - user 계층의 통신으로 이루어지는 기존 PC간의 통신이 아닌, 하나의 RAM 안에서 메모리 Copy 만으로 데이터 이동이 이루어질 수 있게 해 준다.
    - 즉, IOCP는 계층 간 이동에 따른 Interrecpt를 최소화하는 것으로 속도를 향상시키는 기술.

# CPU와 Process, Thread

- CPU도 당신처럼 미리 예측하고 움직인다. 첫 번째
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%206.png)
    
    - RAM은 HD, External 메모리와의 완중장치라면 CPU와 RAM 사이의 완중장치가 Cache
    - Cache는 Register와 RAM의 속도 차이를 극복하게 해 주는 역할을 한다. (Cache Memory)
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%207.png)
        
    - CPU가 연산할 때는 혼자 연산하고 RAM에게 요청하는 것이 아닌, Cache에게 미리 요청한다. 이 때 L1이 CPU의 연산 결과를 예측하고, 해당 데이터(결과)를 CPU에게 전달할 수 있다.
    - L1은 명령과 데이터를 분할하고, L2는 명령과 데이터가 합쳐져있다. L3는 코어 여러개에 갈 데이터, 명령이 모두 들어있다.
    - 예측은 항상 일치하지 않는다. 예측이 일치할 때는 Cache Hit, 일치하지 않을 때는 Cache Miss. 일반적인 CPU는 90%의 Cache Hit을 기록한다.
- CPU도 당신처럼 미리 예측하고 움직인다. 두 번째
    - CPU는 기본적으로 연산을 하고, RAM은 데이터를 다룬다.
    - GPU는 다수의 코어를 통해 단순작업을 빠르게 처리할 수 있다.
    - 현대 패러다임은 RAM에서 연산 기능을 수행하는 것을 고려하고 있다. (PIM)
    - PIM은 RAM에서 CPU가 수행하는 연산 작업의 전처리를 수행한다.
- CPU 예측이 가져올 수 있는 문제점
    - Cache에서 CPU의 연산을 예측함에 따라 생긴 문제점이 있다.
        - CPU 게이트(Meltdown and Spectre)
        - CPU는 연산 수행 시 권한 처리에 따라 거부될 수 있다. 그러나 연산 자체가 수행되지 않는 것이 아닌, 수행 이후 보여지지 않을 뿐이다. (Register에 수행 결과는 저장됨)
        - CPU 게이트는 반복된 연산 요청으로 생성된 캐시 메모리를 역추적하는 방식.
    - VM 환경에서는 비합리적 연산을 되풀이함으로써 다른 VM의 캐시 메모리에 저장되어 있는 민감정보를 탈취해갈 수 있다.
        - VM0번의 시피유 인스트럭션으로 다른 VM에 있는 커널 메모리를 (L3에 있는) 읽는 것.
- 프로세스와 Thread
    - 컴퓨터의 자원은 CPU, RAM의 2가지가 주로 나뉘어진다. 이 때 RAM과 HDD를 합쳐 Virtual Memory 형태로 관리된다.
    - 컴퓨터의 자원은 주로 프로세스에게 할당된다.
        - 프로세스 단위로 가상 메모리가 할당된다.
        - 프로세스에 스레드가 속한다.
        - 어떤 프로세스에 속한 스레드들은 해당 프로세스의 가상 메모리에 접근이 가능하다.
        - 자원을 프로세스에 할당하기 위해 필요한 것이 PCB(Process Control Block)
        - 자원을 스레드에 할당하기 위해 필요한 것은 TCB(Thread Control Block)
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%208.png)
            
    - 프로세스는 자원을 분할하여 사용한다. (시분할 사용)
    - PCB에 담겨있는 정보는 다음과 같다.
        - PID (Process ID) : 양의 정수로 이루어져있는, Process의 ID 값.
        - 메모리 관련된 정보. (Stack과 Heap의 주소값) 등
    - 프로그램을 RAM 메모리에 올려 Instance화 한 것이 프로세스.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%209.png)
        
    - 디스패치 : OS가 Queue에 있는 스레드들 중 하나를 선택해서 꺼내는 것.
- 프로세스 휴식, 보류 상태와 문맥
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2010.png)
    
    - Sleep : 휴식 상태
        - 자발적.
    - Suspend : 보류 상태
        - 외부 요인(OS, 다른 Process)에 의해 강제로 이루어진 것.
        - 의도하지 않은 것.
        - 가상 메모리 시스템에서 OS가 RAM에 있던 데이터를 CPU로 옮기거나(swap), CPU를 멈추게 할 때가 Suspend의 과정
    - Sleep이나 Suspend가 이루어지면 Ready-Queue에서 프로세스가 빠진다.
    - 빠진 프로세스는 일정 시간 후 Ready-Queue에 재진입 하게 되므로, 이전에 Ready-Queue에서 대기 중이었던 프로세스에 따라 시간이 지연된다.
    - 프로세스의 정지(타임아웃) 후 디스패치까지의 상태 변화(문맥 교환)은 다음과 같이 이루어진다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2011.png)
        
- 프로세스 생성과 복사
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2012.png)
    
    - OS의 접근 제어는 Process를 단위로 한다. (Thread는 속해있는 Process의 접근 권한을 공유한다.)
    - Process의 생성 순서
        - Memory로 복사 (실행 코드가)
        - VMS(Vitual Memory Space) 생성 [PCB 생성 ,Stack 확보  , Heap 확보, Data 확보, 코드 복수등)
    - 리눅스 계열에서의 프로세스 생성은 fork(), exec()로 이루어진다.
        - fork() 는 프로세스를 Copy해서 이루어진다. (메모리 할당)
        - exec()는 프로세스를 새로 만들지 않고, exec()에 의해 호출된 프로세스만 메모리에 남게 된다.
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2013.png)
            
- Mutil Threding과 동기화 기본
    - Thread는 하나의 프로세스 안에서 VMS(공간)을 공유한다.
    - 멀티 스레딩이 멀티 프로세싱보다 효율적인 측면에서 유리한 이유는 VMS를 공유하기 때문이다.
    - 단, Thread는 운영체제의 권한이라는 측면에서는 제약을 받는다. (권한은 운영체제가 Thread에게 부여하기 때문에)
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2014.png)
        
        - 스택은 별도의 설정이 없다면 1MB의 공간을 받는다.
    - 멀티 스레드를 사용하는 순간부터 어떤 스레드가 우선순위를 가질지, 어떤 스레드가 먼저 종료될지는 예측하기 어렵다. 이 때 등장하는 것이 Race Condition
        - Race Condition : 경쟁 조건, 두 개 이상의 프로세스가 공통 자원을 병행적으로(concurrently) 읽거나 쓰는 동작을 할 때, 공용 데이터에 대한 접근이 어떤 순서에 따라 이루어졌는지에 따라 그 실행 결과가 같지 않고 달라지는 상황
    - 단순 대입 연산을 스레드가 수행하고 있을 때, 다른 스레드가 단순 대입을 동시에 하는 것은 불가능하다.
        - 하드웨어 수준에서 단순 대입과 같은 Operation은 원자성을 보장하기 때문
    - 이런 상황에서 필요한 것이 동시성 처리. Thread를 사용함에 따라 Thread의 처리 결과는 우연성을 가지게 되므로, Thread의 종료 순서,종료 되기까지의 대기 처리 등이 필요하기 때문이다.

# CPU와 Process간 통신

- CPU Scheduling 개요
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2015.png)
    
    - OS는 기본적으로 background에서 돌아가는 Process로, Application Process를 Support 하는 역할을 한다.
    - 스케줄링이 존재하는 이유는 결국 시스템의 부하 상태를 조절하여 과부하를 막기 위함에 있다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2016.png)
        
    - Preemtive Scheduling은 모든 Process가 CPU의 자원을 선점하여 사용하려 하나, OS가 Process를 통제할 수 있는 방식
    - Non-Preemtive Scheduling는 하나의 Process가 종료될 때까지 다른 Process가 CPU의 자원을 사용할 수 없는 방식.
    - 입출력은 GUI등에 비해 CPU의 우선순위가 낮다. 그렇기에 필요해지는 개념이 비동기 통신.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2017.png)
        
- Process간 통신 개요
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2018.png)
    
    - IPC(Inter-Process Communication)란 프로세스들 사이에 서로 데이터를 주고받는 행위 또는 그에 대한 방법이나 경로
    - Process는 메모리 공간이 독립적으로 주어진다. (OS가 보장한다.)
    - 메모리는 RAM과 File(2차)로 이루어져있다.
    - 이 중 File 메모리를 사용하는 Process의 전산 자원 중 대표적인 것이 파이프
    - RAM을 사용하는 메모리의 대표적인 특징은 고정길이. 할당 단계에서 크기를 고정해야 한다.
    - RPC(Remote Procedure Call) : 원격지의 함수를 호출하는 것 (TCP 통신 이용)
        - HTTP3와 맞물려 최근에 자주 사용되고 있다.
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2019.png)
            
- 공유 자원과 Critical Section
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2020.png)
    
    - 공유 자원 : 메모리, File 정도가 가장 흔하다.
    - Process나 Thread 여러 개가 동시에 하나의 공유 자원에 접근할 때, 원자성이 보장되지 않을 경우 임계구역 문제가 발생한다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2021.png)
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2022.png)
        
    - 임계 구간(Critical Section)을 어디에서, 언제 설정할 지는 경험에 기인한다. 단, 임계 구간은 반드시 최소화해야 한다. (Rock Free)
- Critical Section 해결 방법
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2023.png)
    
    - Network I/O는 기본적으로 비동기 방식으로 이루어진다.
    - 임계구역은 전역전 의미를 가진 자료구조에 동시 Access를 할 때 흔히 발생한다.
    - 동기화 시 Thread는 Queue와 연결되어 있다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2024.png)
        
    - 전역적 의미를 가진 자료구조에 Access하는 순서를 Queue에 일임함으로서 동시성을 제어하는 것이 원리.
- 대충 넘어가는 교착 상태(Dead lock)
    - 영향을 줄 요소는 적을 수록 좋다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2025.png)
        
        - lock1, lock2라는 2개의 요소로 교착상태 발생하는 sudo code
    - 임계 구간에 영향을 미치는 4요소
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2026.png)
        
        - 점유와 대기
        - 비선점
        - 상호 배제
        - 원형 대기
    - 구조가 순환구조를 가진다면 교착 상태의 위험은 올라간다.
    - Process에 속해 있는 다수의 Thread들이 하나의 공유 자원을 공유할 경우, 별도의 Thread를 만들어 해당 Thread들을 상태 감시 하도록 함으로서 해결할 수 있다. (문제 발생 시 교착 상태의 Thread 하나를 Memory Dump 한 뒤 Terminate, 재 실행 하는 것[Stack Tracing])
    - Thread가 아닌 다수의 Process가 공유자원에 접근을 요청하는 상황에서 선점한 Process가 Suspended 됐을 경우, OS가 해당 Process를 강제 회수, 다음 Process에게 자원을 할당한다. 단, 이 때 Process에 할당되어있는 시간은 무한정이 아닌 일정 시간이 있다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2027.png)
        
    - 단, 현대 OS는 실제 Process가 아닌 가상 메모리를 통해 Process를 구현, 해당 가상 메모리를 Terminate 하는 방식으로 작동한다.

# 메모리 관리 기법

- 메모리 관리 개요
    - 메모리의 주소는 1Byte마다 붙는다. 이때 주소가 32bit 숫자로 표현되면 32bit 시스템.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2028.png)
        
    - HDD의 요소를 RAM으로 올리고, RAM에 적재된 Process를 CPU에 올리는 일련의 과정을 컨트롤 하는 것이 메모리 관리자.
    - 메모리 관리자가 하는 업무 중 가장 중요한 것이 배치(Batch)작업.
    - 모든 Process는 RAM 공간을 점유하려 하지만 RAM 공간은 한정되어있다. 따라서 메모리 관리자가 배치 작업을 통해 RAM 공간을 Process에게 할당하는 것이 중요해진다. 이 때 배치 작업의 단위를 페이지(Page)라고 한다.
    - 이 때 프로세스의 크기에 맞춰 페이지를 자르는 것이 Segmentation, 메모리에 맞춰 페이지를 자르는 것이 Paging.
        - 윈도우의 경우, 특별한 일이 없다면 Page의 단위는 4KB
- 절대 주소와 상대 주소
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2029.png)
    
    - RAM에 할당되는 물리적 주소와 App에 할당되는 Process의 주소는 다르다.
        - 후자는 가상 메모리에 할당된다.
    - 사용자 영역을 기준으로 재할당 후 위치를 확인하면 상대 주소, 운영체제 영역을 포함하면 절대 주소.
        - 상대 주소는 논리(logical) 주소 [가상 메모리 체계]
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2030.png)
            
        - 위쪽이 상대 주소, 아래 쪽이 절대 주소의 개념이 된다.
    - 컴퓨터의 주소 체계는(스택은) 두 개의 Register를 조합하여 이루어진다. (ESP, EBP)
- 메모리 Overray와 Swap
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2031.png)
    
    - 프로그램의 크기가 실제 물리 메모리보다 클 때, 전체 프로그램을 메모리에 가져오는 대신 적당한 크기로 잘라서 가져오는 방법을 메모리 Overray라고 한다.
        - 하나의 메모리에 여러 개의 프로그램을 겹겹이 쌓아 놓고 실행하는 방식
    - 메모리에 모듈을 번갈아 가져오는 방식이 Swap.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2032.png)
        
        - RAM + Swap 영역 ⇒ 메모리 공간
    - Swap에는 IN/OUT이 있다. (IN이 Swap 영역에 적재, Out이 빼는 것.)
    - 단, 이 때 Swap IN/OUT을 Page IN/OUT이라고 하기도 한다.
    - 최대 절전 모드는 RAM에 있던 작업을 HDD에 SWAP OUT하는 것.
    - HDD에서 SSD로의 전환이 성능 향상에 많은 영향을 미친 이유도 SSD가 SWAP IN/OUT 속도가 빨라진 이유가 컸다.
- 메모리 분할 방식
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2033.png)
    
    - 고정 분할 방식은 공간 할당 마다 공백(Fragment)이 생긴다.
    - 가변 분할 방식의 장단점
        - 공간을 촘촘히 사용할 수 있다.
        - Process의 종료 시 Fragment가 커진다.
        - 조각 모음 시 메모리의 Move가 필요하다.
    - 고정 분할 방식의 장단점
        - Process의 종료에 따른 공간 재할당이 수월하다. (관리가 수월하다.)
        - 공간 분할 시마다 Fragment가 생긴다.
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2034.png)
            
- 가상 메모리 개요
    - 컴퓨터마다 물리 메모리 크기가 다르다. 애플리케이션 환경에서 가상 메모리 환경을 사용함으로서 메모리 의존성을 없앨 수 있다.
    - 또한, 관리적 의미로서의 추상성을 제공함으로써 보안을 높일 수 있다. (접근 통제, 제어)
    - 메모리는 (4GB 기준으로) user와 kernel 용으로 2GB씩 나뉘어진다. 이 중 user는 OS가 할당 받아 관리하는 영역이 포함되어, 실제 메모리 용량은 약 1.7GB ~ 1.8GB 사이로 할당된다.
    - 가상 메모리에서 메모리 매니저가 관리하는 크기는 RAM 영역(물리 메모리 공간)과 SWAP 영역을 합쳐서 가상 메모리 공간으로 변환한다.
    - 이 때 변환 작업을 동적 주소 변환이라고 한다.
        - 이 때의 동적은 Runtime
    - 가상 메모리 체제에서는 Process마다 각자의 고유한 메모리 주소를 가진다.
    - 즉, 가상 메모리에서 주소(Process 상의 주소)가 같다고 해서 물리 메모리에서 공간이 같다는 것은 아니다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2035.png)
        
    - Mapping 테이블은 물리 메모리가 Segmentation으로 분할 된 경우 뿐만 아니라, Paging으로 분할 된 경우에도 동일하게 적용된다.
    - 가상 메모리 체계의 장점 중 하나는, 프로세스가 Suspend됐을 때(오작동 했을 때), 해당 프로세스가 가리키고 있던 segement를 여분의 공간으로 관리(회수)할 수 있다는 점이다.
        - → 자원 낭비의 최소화
        - 이는 곧 보안 통제(보안)가 잘 되고 있다는 의미이기도 하다.
- Paging 기법의 구현
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2036.png)
    
    - VMS(Virtual Memory Space)는 32bit 체제 기준, 4GB 배열이다.
        - → 논리적으로, 완벽하게 선형 메모리다.
    - Page는 해당 배열을 4kb 단위로 쪼갠 것이며, Page의 핵심은 배열을 일정한 단위로, 마치 block처럼 쪼개서 관리한다는 것이다.
    - 절대 주소인 기준에서 상대 주소까지의 거리를 distance, 혹은 oppset이라고 한다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2037.png)
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2038.png)
        
        - VA : Page 번호
        - Distance : 절대 주소로부터의 거리
        - invaild : 할당 된 물리 주소가 없는 페이지 테이블 공간
        - 페이지 주소를 가지고 페이지 프레임의 주소를 할당할 때, 페이지 테이블의 주소가 invaild인 경우, 실제 물리 주소가 할당되지 않았기에 Page Fault 에러가 발생하게 된다.
        - → Segmentation 기법으로 접근 시 : Segmentation Falut
- 가상 메모리 접근 권한
    
    ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2039.png)
    
    - 유저 영역의 메모리 공간은 데이터와 코드로 나뉜다. 이 중 데이터는 Stack, Heap, 정적 영역 등으로 나뉘며, 정적 영역은 RW- 권한, R— 권한으로 이루어진다. 이 중 RW-가 전역 변수의 개념.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2040.png)
        
        - 단, 유저가 권한을 변경할 수 있다는 점에 유의.
            - DEP(Data Execution Prevention) : 데이터를 담아야 할 메모리 영역에 코드를 집어 넣어 실행하는 것을 막는 기능. 데이터 영역에 담긴 기계어로 원격 코드 실행을 할 경우, Execution단계에서 OS가 막는다.
    - 권한 개념은 페이지 테이블을 의미한다고 축약할 수 있다. (정확한 개념은 아니다.)
    - DEP는 페이지 테이블의 권한 비트 레벨에서 이루어진다.
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2041.png)
        
        ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2042.png)
        

# 못 다한 이야기

- 해커가 관리자 암호 없이 관리자 권한을 얻는 방법
    - 보안 사고 관련하여 임의 코드 실행 가능이라는 문구는 해커가 OS에 대한 권한을 획득했다는 의미가 된다.
    - Process는 키보드와 마우스를 통해 통제한다. 또한, Process를 통해 Kernel(OS)를 통제한다. OS를 통해 Daemon, Service를 통제한다.
    - 컴퓨터의 로그인 절차는 GUI 상에서 입력한 계정 정보를 통해 (지식 기반 사용자 인증) Login Process를 실행한다.
        - Login Process는 입력된 정보가 옳다면, Shell Process를 실행한다. (Window라면 탐색기, Unix라면 Bash Shell)
        - Process를 사용할 권한은 Login Process가 Shell Process에 부여한다.
        - 이후 Shell Process를 통해 다른 Process를 실행하는데, 이 때 다른 Process를 실행할 권한은 Shell Process를 통해 권한을 상속 받아 실행하게 된다.
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2043.png)
            
        - 해킹을 통한 관리자 권한 획득은 관리자 권한을 가지고 있는 Process에게 무언가(정보 등)를 주입한다.
        - 주입의 목적은 오작동으로, 관리자 권한을 가지고 있는 Process가 Shell Process(혹은, 관리자 권한을 가진 악성 Process)를 실행하도록 유도하는 것.
            - → 이를 통해 관리자 권한을 획득한다.
        - 이런 침입을 막기 위한 방법이 Secure OS로, 관리자 계정의 생성을 제한하거나, 관리자 권한을 가진 Process를 실행하는 것을 모니터링 중, 허용되지 않은 접근을 차단하는 것.
            
            ![Untitled](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/Untitled%2044.png)
            
        

[수료증](%E1%84%80%E1%85%A9%E1%86%B7%E1%84%8E%E1%85%A2%E1%86%A8%E1%84%8B%E1%85%B3%E1%84%85%E1%85%A9%20%E1%84%89%E1%85%B1%E1%86%B8%E1%84%80%E1%85%A6%20%E1%84%87%E1%85%A2%E1%84%8B%E1%85%AE%E1%84%82%E1%85%B3%E1%86%AB%20%E1%84%8E%E1%85%AC%E1%84%89%E1%85%A9%E1%84%92%E1%85%A1%E1%86%AB%E1%84%8B%E1%85%B4%20%E1%84%8B%E1%85%AE%E1%86%AB%E1%84%8B%E1%85%A7%E1%86%BC%E1%84%8E%E1%85%A6%E1%84%8C%E1%85%A6%E1%84%85%E1%85%A9%E1%86%AB%20a74f7e1e659d44cf8e5655729a7567ee/certificate_(1).pdf)