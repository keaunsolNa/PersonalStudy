# 인터넷 프로그래밍 (2)

# HTML DOM 개요

- HTML 페이지와 자바스크립트 객체
    - 자바스크립트 코드
        - 브라우저로부터 3가지 유형의 객체를 제공받아 활용
            
            ![image.png](인터넷프로그래밍(2)/image.png)
            
- HTML DOM(Document Object Model)
    - HTML DOM(간단히 DOM)
        - 웹 페이지에 작성된 HTML 태그 당 객체(DOM 객체) 생성
        - 목적 : HTML 태그가 출력된 모양이나 콘텐츠를 제어하기 위해
            - DOM 객체를 통해 각 태그의 CSS3 스타일 시트 접근 및 변경
            - HTML 태그에 의해 출력된 텍스트나 이미지 변경
    - DOM 트리
        - HTML 태그의 포함관계에 따라 DOM 객체의 트리(tree) 생성
        - DOM 트리는 부모 자식 관계
    - DOM 객체
        - DOM 트리의 한 노드
        - HTML 태그 당 하나의 DOM 객체 생성
            - DOM 노드(Node), DOM 엘리먼트(Element)라고도 불림
    
    ![image.png](인터넷프로그래밍(2)/image%201.png)
    
- DOM 트리의 특징
    - DOM 트리의 루트는 document 객체
    - DOM 객체의 종류는 HTML 태그 종류만큼
    - HTML 태그 당 DOM 객체가 하나씩 생성
    - HTML 태그의 포함관계에 따라 DOM 트리에 부모 자식 관계
    - 브라우저가 HTML 태그를 화면에 그리는 과정
        - 브라우저가 DOM 트리의 틀(document 객체) 생성
        - 브라우저가 HTML 태그를 읽고 DOM 트리에 DOM 객체 생성
        - 브라우저는 DOM 객체를 화면에 출력
        - HTML 문서 로딩이 완료되면 DOM 트리 완성
        - DOM 객체 변경 시, 브라우저는 해당 HTML 태그의 출력 모양을 바로 갱신
- DOM 객체와 HTML 페이지의 화면 출력
    
    ![image.png](인터넷프로그래밍(2)/image%202.png)
    
- HTML 태그의 요소
    - HTML 태그
        - 엘리먼트(element)로도 불림
        - 다음 5가지 요소로 구성
            
            ![image.png](인터넷프로그래밍(2)/image%203.png)
            
- DOM 객체의 5가지 구성 요소
    - 프로퍼티(property)
        - HTML 태그의 속성(attribute) 반영
    - 메소드(method)
        - DOM 객체의 멤버 함수로서, HTML 태그 제어 가능
    - 컬렉션(collection)
        - 자식 DOM 객체들의 주소를 가지는 등 배열과 비슷한 집합적 정보
    - 이벤트 리스너(event listener)
        - HTML 태그에 작성된 이벤트 리스터 반영
        - 약 70여 개의 이벤트 리스너를 가질 수 있음
    - CSS3 스타일
        - HTML 태그에 설정된 CSS3 스타일 시트 정보를 반영
        - DOM 객체의 style 프로퍼티를 통해 HTML 태그의 모양 제어 가능
    
    ![image.png](인터넷프로그래밍(2)/image%204.png)
    
    ![image.png](인터넷프로그래밍(2)/image%205.png)
    
- DOM 객체의 프로퍼티와 DOM 객체사이의 관계
    
    ![image.png](인터넷프로그래밍(2)/image%206.png)
    
- DOM 객체의 구조 출력: p 객체 사례
    
    ![image.png](인터넷프로그래밍(2)/image%207.png)
    
    ![image.png](인터넷프로그래밍(2)/image%208.png)
    
    ![image.png](인터넷프로그래밍(2)/image%209.png)
    

# DOM 객체 다루기

- DOM 객체 다루기
    
    ![image.png](인터넷프로그래밍(2)/image%2010.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2011.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2012.png)
    
- innerHTML 프로퍼티
    
    ![image.png](인터넷프로그래밍(2)/image%2013.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2014.png)
    
- this 키워드
    
    ![image.png](인터넷프로그래밍(2)/image%2015.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2016.png)
    

# document 객체

- document
    - HTML 문서 전체를 대변하는 객체
        - 프로퍼티 : HTML 문서의 전반적인 속성 내포
        - 메소드 : DOM 객체 검색, DOM 객체 생성, HTML 문서 전반적 제어
    - DOM 객체를 접근하는 경로의 시작점
    - DOM 트리의 최상위 객체
        - 브라우저는 HTML 문서 로드 전, document 객체를 먼저 생성
        - document 객체를 뿌리로 하여 DOM 트리 생성
    - document 객체 접근
        - window.document 또는 document 이름으로 접근
        - document 객체는 DOM 객체가 아님
            - 연결된 스타일 시트가 없음
                
                ![image.png](인터넷프로그래밍(2)/image%2017.png)
                
- document 객체의 프로퍼티 출력
    
    ![image.png](인터넷프로그래밍(2)/image%2018.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2019.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2020.png)
    
- DOM 트리에서 DOM 객체 찾기
    - 태그 이름으로 찾기
        - document.getElementsByTagName()
            - 태그 이름이 같은 모든 DOM 객체들을 찾아 컬렉션 리턴
                
                ![image.png](인터넷프로그래밍(2)/image%2021.png)
                
    - class 속성으로 찾기
        - document.getElementsByClassName()
            - class 속성이 같은 모든 DOM 객체들을 찾아 컬렉션 리턴
                
                ![image.png](인터넷프로그래밍(2)/image%2022.png)
                
    
    ![image.png](인터넷프로그래밍(2)/image%2023.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2024.png)
    
- document.write()와 document.writeln()
    - HTML 페이지 로딩 과정
        - 브라우저는 HTML 페이지 로드 전 빈 상태 document 생성
        - 브라우저는 HTML 페이지를 위에서 아래로 해석
        - HTML 태그들을 document 객체에 담아감 (DOM 객체 생성)
        - `</html>` 태그를 만나면 document 객체를 완성하고 닫음
    - write()
        - document 객체에 담긴 HTML 콘텐츠 마지막에 HTML 태그들을 추가
            - 추가되는 HTML 태그들은 DOM 객체로 바뀌고 DOM 트리에 추가
            - 삽입된 HTML 태그들이 브라우저 화면에 출력
                
                ![image.png](인터넷프로그래밍(2)/image%2025.png)
                
    - writeln()
        - HTML 텍스트에 ‘In’을 덧붙여 출력 → 한 칸 띄는 효과
            
            ![image.png](인터넷프로그래밍(2)/image%2026.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%2027.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2028.png)
    
- document의 열기와 닫기
    - document.open()
        - 현재 브라우저에 출력된 HTML 콘텐츠를 지우고 새로운 HTML 페이지 시작
        - 즉, document 객체에 담긴 DOM 트리를 지우고 새로 시작
    - document.close()
        - 현재 브라우저에 출력된 HTML 페이지 완성
        - 더 이상 document.write() 할 수 없음
            
            ![image.png](인터넷프로그래밍(2)/image%2029.png)
            
- HTML 문서 작성 연습 페이지 만들기
    
    ![image.png](인터넷프로그래밍(2)/image%2030.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2031.png)
    

# HTML 문서의 동적 구성

- 문서의 동적 구성
    - DOM 객체 동적 생성 : document.createElement(”태그이름”)
        - 태그 이름의 DOM 객체 생성
            
            ![image.png](인터넷프로그래밍(2)/image%2032.png)
            
    - DOM 트리에 삽입
        - 부모.appendChild(DOM 객체);
        - 부모.insertBefore(DOM 객체 [, 기준 자식]);
            - 예) 생성한 <div> 태그를 <p “id=p”> 태그의 마지막 자식으로 추가
                
                ![image.png](인터넷프로그래밍(2)/image%2033.png)
                
    - var removedObj = 부모.removeChild(떼어내고자 하는 자식객체);
        
        ![image.png](인터넷프로그래밍(2)/image%2034.png)
        
    - <div> 태그의 DOM 객체 동적 생성
        
        ![image.png](인터넷프로그래밍(2)/image%2035.png)
        
- HTML 태그의 동적 추가 및 삭제
    
    ![image.png](인터넷프로그래밍(2)/image%2036.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2037.png)
    

# 이벤트

- 이벤트 개요
    - 이벤트
        - 마우스 클릭, 키보드 입력, 이미지나 HTML 문서의 로딩, 타이머의 타임아웃 등 사용자의 입력 행위나 문서나 브라우저의 상태 변화를 자바스크립트 코드에게 알리는 통지(notification)
    - 이벤트 리스너
        - 발생한 이벤트에 대처하기 위해 작성된 자바스크립트 코드
    - 이벤트 종류
        - HTML5에서 이벤트 종류는 70여가지
        - 이벤트 리스너 이름은 이벤트 이름 앞에 on을 덧붙임
            - onmousedown: modusedown 이벤트의 리스너
            - onkeydown: keydown 이벤트의 리스너
    
    ![image.png](인터넷프로그래밍(2)/image%2038.png)
    
- 이벤트 리스너 만들기
    - 3가지 방법
        - HTML 태그 내에 이벤트 리스너 작성
            - HTML 태그의 이벤트 리스너 속성에 리스너 코드 직접 작성
                
                ![image.png](인터넷프로그래밍(2)/image%2039.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2040.png)
                
        - DOM 객체의 이벤트 리스너 프로퍼티에 작성
            - DOM 객체의 이벤트 리스너 프로퍼티에 이벤트 리스너 코드 작성
                
                ![image.png](인터넷프로그래밍(2)/image%2041.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2042.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2043.png)
                
        - DOM 객체의 addEventListener() 메소드 이용
            - addEventListener(eventName, listener[, useCapture])
                
                ![image.png](인터넷프로그래밍(2)/image%2044.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2045.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2046.png)
                
    - 익명 함수로 이벤트 리스너 작성
        - 익명 함수(anonymous function)
            - 함수 이름 없이 필요한 곳에 함수의 코드를 바로 작성
            - 코드가 짧거나 한 곳에서만 사용하는 경우, 익명 함수가 편리
                
                ![image.png](인터넷프로그래밍(2)/image%2047.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2048.png)
                
                ![image.png](인터넷프로그래밍(2)/image%2049.png)
                
- 이벤트 리스너 작성 방법 4가지 비교
    
    ![image.png](인터넷프로그래밍(2)/image%2050.png)
    

# 이벤트 객체

- 이벤트 객체(event object)
    - 발생한 이벤트에 관련된 다양한 정보를 담은 객체
        - mousedown 이벤트의 경우, 마우스 좌표와 버튼 번호 등
        - keydown 이벤트의 경우, 키 코드 값 등
    - 이벤트가 처리되고 나면 이벤트 객체 소멸
    
    ![image.png](인터넷프로그래밍(2)/image%2051.png)
    
- 이벤트 객체 전달받기
    - 이벤트 객체는 이벤트 리스너 함수의 첫 번째 매개변수에 전달
        - 이름을 가진 이벤트 리스너
            
            ![image.png](인터넷프로그래밍(2)/image%2052.png)
            
        - 익명 함수의 경우
            
            ![image.png](인터넷프로그래밍(2)/image%2053.png)
            
        - HTML 태그에 이벤트 리스너: event 라는 이름으로 전달
            
            ![image.png](인터넷프로그래밍(2)/image%2054.png)
            
        
        ![image.png](인터넷프로그래밍(2)/image%2055.png)
        
- 이벤트 객체에 들어 있는 정보
    - 현재 발생한 이벤트에 관한 다양한 정보
        - 이벤트 객체의 프로퍼티와 메소드로 알 수 있음
    - 이벤트의 종류마다 조금씩 다름
        - 이벤트 객체의 공통 멤버
            
            ![image.png](인터넷프로그래밍(2)/image%2056.png)
            
    - target 프로퍼티
        - 이벤트 타겟 객체 가리킴
        - 이벤트 타겟 : 이벤트를 유발시킨 DOM 객체
            - <button> 태그의 버튼을 클릭하였으면, 이 때 click 이벤트의 이벤트 타겟은 버튼
    - 이벤트 객체의 프로퍼티 출력
        
        ![image.png](인터넷프로그래밍(2)/image%2057.png)
        
- 이벤트의 디폴트 행동 취소, preventDefault()
    - 이벤트의 디폴트 행동이란?
        - 특정 이벤트에 대한 HTML 태그의 기본 행동
        - ex )
            - `<a>`의 click 이벤트의 디폴트 행동 : 웹 페이지 이동
            - Submit 버튼의 click 이벤트의 디폴트 행동 : 폼 데이터 전송
            - `<input type=”checkbox”>`의 click 이벤트의 디폴트 행동 : 체크 박스 선택
    - 이벤트의 디폴트 행동을 막는 방법
        - 이벤트 리스너에서 false 리턴
            
            ![image.png](인터넷프로그래밍(2)/image%2058.png)
            
    - 이벤트 객체의 preventDefault() 메소드 호출
        
        ![image.png](인터넷프로그래밍(2)/image%2059.png)
        
    - 이벤트 객체의 cancelable 이벤트 객체가 true인 경우만 취소 가능
        
        ![image.png](인터넷프로그래밍(2)/image%2060.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2061.png)
        

# 이벤트 흐름

- 이벤트 흐름
    - 이벤트가 발생하면 window 객체에 먼저 도달하고, DOM 트리를 따라 이벤트 타겟에 도착하고, 다시 반대 방향으로 흘러 window 객체에 도달한 다음 사라지는 과정
    - 이벤트가 흘러가는 과정
        - 캡쳐 단계(capturing phase)
            - 이벤트가 window 객체에서 중간의 모든 DOM 객체를 거쳐 타겟 객체에 전달되는 과정
            - 이벤트가 거쳐가는 모든 DOM 객체(window 포함)의 이벤트 리스너 실행
        - 버블 단계(bubbling phase)
            - 이벤트가 타겟에서 중간의 모든 DOM 객체를 거쳐 window 객체에 전달되는 과정
            - 이벤트가 거쳐가는 모든 DOM 객체(window 포함)의 이벤트 리스너 실행
    - DOM 객체에는 캡쳐 리스너와 버블 리스너 두 개 모두 작성할 수 있음
    - 샘플 웹 페이지
        
        ![image.png](인터넷프로그래밍(2)/image%2062.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2063.png)
        
- 캡쳐 리스너와 버블 리스너
    - DOM 객체의 이벤트 리스너
        - 캡쳐 리스너와 버블 리스너를 모두 소유 가능
            - 이벤트 리스너 등록 시, 캡쳐 리스너인지 버블 리스너인지 구분
    - 캡쳐 리스너와 버블 리스너 등록
        - addEventListener()의 3번째 매개 변수 이용
            - true이면 캡쳐 리스너, false이면 버블 리스너
                
                ![image.png](인터넷프로그래밍(2)/image%2064.png)
                
        - 다른 방법의 이벤트 리스너 등록의 경우
            - 버블 리스너로 자동 등록
                
                ![image.png](인터넷프로그래밍(2)/image%2065.png)
                
- 이벤트 흐름의 예시
    
    ![image.png](인터넷프로그래밍(2)/image%2066.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2067.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2068.png)
    
- 이벤트 흐름을 중단 시키는 방법
    - 이벤트 객체의 stopPropagation() 호출
        - event.stopPropagation(); // event가 이벤트 객체일 때

# 마우스 핸들링

- 마우스 이벤트 객체의 프로퍼티
    
    ![image.png](인터넷프로그래밍(2)/image%2069.png)
    
    - onclick : HTML 태그가 클릭될 때
    - ondblclick : HTML 태그가 더블클릭될 때
    - onclick 리스너로 계산기 만들기
        
        ![image.png](인터넷프로그래밍(2)/image%2070.png)
        
- 마우스 관련 이벤트 리스너 호출
    - onmousedown
        - 마우스 버튼을 누르는 순간
    - onmouseup
        - 눌러진 버튼이 놓여지는 순간
    - onmouseover/onmouseout
        - 마우스가 태그 위로 올라오는 순간(자식 영역 포함)
    - onmouseenter/onmouseleave
        - 마우스가 태그 위로 올라오는 순간(버블 단계 없음)
    - onwheel
        - HTML 태그에 마우스 휠이 구르는 동안 계속 호출
            - 위쪽으로 굴린 경우 : wheelDelta 프로퍼티 값 양수 (120)
            - 아래쪽으로 굴린 경우 : wheelDelta 프로퍼티 값 양수(-120)
            
            ![image.png](인터넷프로그래밍(2)/image%2071.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%2072.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2073.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2074.png)
    
    - onmousemove와 마우스 위치 및 버튼
        
        ![image.png](인터넷프로그래밍(2)/image%2075.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2076.png)
        
- oncontextmenu
    - HTML 태그 위에 마우스 오른쪽 버튼 클릭
        - 디폴트로 컨텍스트 메뉴(context menu) 출력
        - ‘소스 보기’나 ‘이미지 다운로드’ 등의 메뉴
    - oncontextmenu 리스너가 먼저 호출
        - false를 리턴하면 컨텍스트 메뉴를 출력하는 디폴트 행동 취소
            
            ![image.png](인터넷프로그래밍(2)/image%2077.png)
            
    - oncontextmenu로 소스 보기나 이미지 다운로드 금지
        
        ![image.png](인터넷프로그래밍(2)/image%2078.png)
        

# 문서와 이미지 로딩, onload

- 문서의 로딩 완료와 onload
    - onload
        - window 객체에 발생
            - 웹 페이지의 로딩 완료 시 호출되는 이벤트 리스너
    - onload 리스너 작성 방법
        
        ![image.png](인터넷프로그래밍(2)/image%2079.png)
        
        - 위 둘은 같은 표현
        - `<body>`에 onload를 붙인 window 객체에 load 이벤트가 전달됨
        - documnet.onload는 최근 많은 브라우저에서 작동 안 됨
    - onload에서 사이트 이전을 알리는 경고창 출력
        
        ![image.png](인터넷프로그래밍(2)/image%2080.png)
        
- 이미지 로딩 완료와 onload
    - image 객체
        - `<img>` 태그에 의해 생성되는 DOM 객체
        - new image(); 자바스크립트 코드에 의해 생성되는 객체
    - onload
        - 이미지의 로딩이 완료되면 객체에 발생하는 이벤트
    - 새로운 이미지를 로딩하는 방법
        
        ![image.png](인터넷프로그래밍(2)/image%2081.png)
        
    - 이미지 로딩 시 주의할 점
        - 잘못된 이미지 로딩 코드
            - 이미지를 로딩하여 이미지 폭을 알아내는 코드
                
                ![image.png](인터넷프로그래밍(2)/image%2082.png)
                
        - 코드 수정
            
            ![image.png](인터넷프로그래밍(2)/image%2083.png)
            
    - onload로 이미지의 크기 알아내기
        
        ![image.png](인터넷프로그래밍(2)/image%2084.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2085.png)
        
- new image()로 이미지 로딩과 출력
    - 동적으로 이미지 객체 생성
        - new image()
            - 이미지 객체가 생겼지만 화면에 출력되지 않음
    - new image()의 이미지 객체에 이미지 로딩
        
        ![image.png](인터넷프로그래밍(2)/image%2086.png)
        
    - 로딩된 이미지 출력
        - `<img>` 태그에 할당된 브라우저 공간에 이미지 출력
            
            ![image.png](인터넷프로그래밍(2)/image%2087.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%2088.png)
    
    ![image.png](인터넷프로그래밍(2)/image%2089.png)
    

# 폼과 이벤트 활용

- onblur와 onfocus
    - 포커스
        - 포커스는 현재 키 입력에 대한 독점권
        - 브라우저는 포커스를 가지고 있는 HTML 태그 요소에 키 공급
    - onblur
        - 포커스를 잃을 때 발생하는 이벤트 리스너
        - 예) 다른 HTML 요소를 클릭하면, 현재 HTML 요소는 포커스를 잃음
    - onfocus
        - 포커스를 얻을 때 발생하는 이벤트 리스너
        - 예) 현재 HTML 요소를 클릭하면, 현재 HTML 요소가 포커스를 얻음
    - onfocus와 onblur, 입력 없이 다른 창으로 갈 수 없음
    
    ![image.png](인터넷프로그래밍(2)/image%2090.png)
    
- 라디오버튼과 체크박스
    - 라디오버튼 객체
        
        ![image.png](인터넷프로그래밍(2)/image%2091.png)
        
    - 체크박스 객체
        - `<input type=”checkbox”>` 로 만들어진 체크박스 DOM 객체
    - 선택된 라디오버튼 알아내기
        
        ![image.png](인터넷프로그래밍(2)/image%2092.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2093.png)
        
    - 체크박스로 선택한 물품 계산
        
        ![image.png](인터넷프로그래밍(2)/image%2094.png)
        
        ![image.png](인터넷프로그래밍(2)/image%2095.png)
        
- select 객체와 onchange
    - select 객체는 `<select>` 태그로 만들어진 콤보박스
        - option 객체는 `<option>` 태그로 표현되는 옵션 아이템
            
            ![image.png](인터넷프로그래밍(2)/image%2096.png)
            
        - 선택된 옵션 알아내기
            
            ![image.png](인터넷프로그래밍(2)/image%2097.png)
            
        - 옵션 선택
            
            ![image.png](인터넷프로그래밍(2)/image%2098.png)
            
        - select와 onchage 리스너
            - 선택된 옵션이 변경되면 select 객체의 oncahge 리스너 호출
                
                ![image.png](인터넷프로그래밍(2)/image%2099.png)
                
    - select 객체에서 선택한 과일 출력
        
        ![image.png](인터넷프로그래밍(2)/image%20100.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20101.png)
        
- 키 이벤트
    - onkeydown
        - 키가 눌러지는 순간 호출
        - 모든 키에 대해 작동
    - onkeypress
        - 문자 키와 `<Enter>`, `<Space>`, `<Esc>` 키에 대해서만 눌러지는 순간에 추가 호출
            - 문자 키가 아닌 경우(`<F1>`, `<Shift>`, `<PgDn>`, `<Del>`, `<Ins>` 등) 호출되지 않음
    - onkeyup
        - 눌러진 키가 떼어지는 순간 호출
    - 키 이벤트 리스너와 이벤트 객체의 프로퍼티
        
        ![image.png](인터넷프로그래밍(2)/image%20102.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20103.png)
        
- onreset과 onsubmit
    - onreset
        - reset 버튼(`<input type=”reset”>`) 클릭 시
        - false를 리턴하면 폼이 초기화되지 않음
    - onsubmit
        - submit(`<input type=”submit”>`) 버튼 클릭 시
        - false를 리턴하면 폼 전송하지 않음
    - 리스너 작성
        - onreset과 onsubmit 리스너는 `<form>` 태그에 달아야 함
        
        ![image.png](인터넷프로그래밍(2)/image%20104.png)
        

# 브라우저 관련 객체 개요

- BOM(Browser Object Mode) 객체들
    - 자바스크립트로 브라우저를 제어하기 위해 지원되는 객체들
        - HTML 페이지의 내용과 관계 없음
    - 브라우저 공통 BOM 객체들과 기능
        
        ![image.png](인터넷프로그래밍(2)/image%20105.png)
        
    - BOM의 국제 표준이 없음
        - 브라우저마다 BOM 객체들이 조금씩 다름
        - 브라우저마다 이름이 같은 BOM 객체의 프로퍼티와 메소드 상이
    
    ![image.png](인터넷프로그래밍(2)/image%20106.png)
    

# window 객체

- window 객체
    - window 객체란?
        - 열려 있는 브라우저 윈도우나 탭 윈도우의 속성을 나타내는 객체
        - 브라우저 윈도우나 탭 윈도우마다 별도의 window 객체 생성
    - window 객체의 생성의 3가지 이유
        - 브라우저가 새로운 웹 페이지를 로드할 때
        - `<iframe>` 태그 당 하나의 window 객체 생성
        - 자바스크립트 코드로 윈도우 열기 시 window 객체 생성
            - window.open(”웹페이지 URL”, “윈도우이름”, “윈도우속성”)
    - 자바스크립트 코드로 윈도우 객체에 대한 접근
        - window, 혹은 window.self, 혹은 self
- 윈도우 모양과 window 객체의 프로퍼티
    
    ![image.png](인터넷프로그래밍(2)/image%20107.png)
    
- 윈도우 열기, window.open()
    - 윈도우를 새로 열고 웹 페이지 출력
        
        ![image.png](인터넷프로그래밍(2)/image%20108.png)
        
    - 3개의 매개변수를 가진 함수
        
        ![image.png](인터넷프로그래밍(2)/image%20109.png)
        
        - sURL
            - 윈도우에 출력할 웹 페이지 주소 문자열
        - sWindowName
            - 새로 여는 윈도우의 이름 문자열로서 생략 가능
        - sFeature
            - 윈도우의 모양, 크기 등의 속성들을 표현하는 문자열
            - 속성들은 빈칸 없이 콤마(’,’)로 분리하여 작성하며 생략 가능
    - 윈도우 이름(sWindowName)
        - _blank : 이름 없는 새 윈도우를 열고, 웹 페이지 로드
        - _parent : 현재 윈도우(혹은 프레임)의 부모 윈도우에 웹 페이지 로드
        - _self : 현재 윈도우에 웹 페이지 로드
        - _top : 브라우저 윈도우에 웹 페이지 로드
    - 윈도우 열기 사례
        
        ![image.png](인터넷프로그래밍(2)/image%20110.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20111.png)
        
    - 윈도우 이름과 윈도우 열기
        - 이름 없는 윈도우 열기
            
            ![image.png](인터넷프로그래밍(2)/image%20112.png)
            
            - 버튼을 클릭할 때마다 새 윈도우를 열고 네이버 사이트 출력
        - 이름을 가진 윈도우 열기
            
            ![image.png](인터넷프로그래밍(2)/image%20113.png)
            
            - myWin 이름의 윈도우가 열려 있지 않는 경우
                - 버튼을 클릭하면, myWin 이름의 새 윈도우 열고 네이버 출력
            - myWin 이름의 윈도우가 미리 열려 있는 경우
                - 버튼을 클릭하면, 이미 열려 있는 myWin 이름의 윈도우에 네이버 출력
    - 3개의 링크를 가진 웹 페이지를 작성하고, 각 링크를 클릭하면 myWin 이름의 새 윈도우를 열고 해당 사이트를 출력하기 (myWin 윈도우는 공유)(새 윈도우는 스크린의 (300, 300) 위치에 400x300 크기로 출력)
        
        ![image.png](인터넷프로그래밍(2)/image%20114.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20115.png)
        
- 윈도우 닫기
    - 윈도우를 스스로 닫는 경우와 자신이 생성한 윈도우를 닫는 사례 보이기
        
        ![image.png](인터넷프로그래밍(2)/image%20116.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20117.png)
        

# window의 타이머 활용

- window 객체의 타이머 기능 2가지
    - 타임아웃 코드 1회 호출
        - setTimeout()/clearTimeout() 메소드
    - 타임아웃 코드 반복 호출
        - setInterval()/clearInterval() 메소드
- setTimeout()/clearTimeout()
    - setTimeout() : 타임아웃 코드 1회 실행
        
        ![image.png](인터넷프로그래밍(2)/image%20118.png)
        
        - timeOutCode : 타임아웃 자바스크립트 코드
        - msec : 밀리초 단위의 정수로서, 타임아웃 지연 시간
        - setTimeout() : msec 후에 timeOutCode를 1회 실행하도록 타이머를 설정하고, 타이머 ID를 리턴
        - clearTimeout() : 작동 중인 timerID 의 타이머를 해제
        - 예) 3초 후 경고창 출력
            
            ![image.png](인터넷프로그래밍(2)/image%20119.png)
            
        - 예) 3초가 되기 전에 타이머 해제
            
            ![image.png](인터넷프로그래밍(2)/image%20120.png)
            
    - setTimeout()로 웹 페이지 자동 연결
        - 이미지 위에 마우스를 올린 상태로 5초가 지나면 네이버에 연결, 5초 전에 이미지를 벗어나면 타이머를 해제하는 코드를 작성
            
            ![image.png](인터넷프로그래밍(2)/image%20121.png)
            
            ![image.png](인터넷프로그래밍(2)/image%20122.png)
            
- setInterval()/clearInterval()
    - setInterval() : 타임아웃 코드 반복 실행
        
        ![image.png](인터넷프로그래밍(2)/image%20123.png)
        
        - timeOutCode : 타임아웃 자바스크립트 코드
        - msec : 밀리초 단위의 정수로서, 타임아웃 지연 시간
        - setInterval() : msec 주기로 timeOutCode를 무한 반복하도록 타이머를 설정하고, 타이머의 ID를 리턴
        - clearInterval() : timerID의 타이머를 해제
        - 예) 1초 간격으로 경고창 출력
            
            ![image.png](인터넷프로그래밍(2)/image%20124.png)
            
        - 예) 타이머 해제
            
            ![image.png](인터넷프로그래밍(2)/image%20125.png)
            
    - setInterval()로 텍스트 회전
        - setInterval()을 이용하여 텍스트를 옆으로 반복 회전시키는 코드 작성 + 텍스트 위에 마우스를 클릭하면 회전 중단
            
            ![image.png](인터넷프로그래밍(2)/image%20126.png)
            
            ![image.png](인터넷프로그래밍(2)/image%20127.png)
            

# window 객체 활용

- 윈도우 위치 및 크기 조절
    - 윈도우를 오른쪽으로 5픽셀, 아래로 10픽셀 이동
        
        ```html
        window.moveBy(5, 10); 혹은 moveBy(5, 10);
        ```
        
    - 윈도우를 스크린의 (25, 10) 위치로 이동
        
        ```html
        window.moveTo(25, 10); 혹은 self.moveTo(25, 10); 
        ```
        
    - 윈도우 크기를 5픽셀 좁게, 10픽셀 길게 조절
        
        ```html
        window.resizeBy(-5, 10); 혹은
        resizeTo(self.outerWidth-5, self.outerHeight+10);
        ```
        
    - 윈도우 크기를 200 x 300으로 조절
        
        ```html
        window.resizeTo(200, 300);
        ```
        
    
    ![image.png](인터넷프로그래밍(2)/image%20128.png)
    
- 웹 페이지 스크롤
    - 웹 페이지를 위로 10픽셀 스크롤(마우스 스크롤 다운)
        
        ```html
        window.scrollBy(0, 10); // 옆으로 0, 위로 10픽셀
        ```
        
    - 웹 페이지를 왼쪽으로 10픽셀, 아래로 15픽셀 스크롤 (마우스 스크롤 업)
        
        ```html
        window.scrollBy(10, -15);
        ```
        
    - 웹 페이지의 (0, 200) 좌표 부분이 현재 윈도우의 왼쪽 상단 모서리에 출력되도록 스크롤
        
        ```html
        window.scrollTo(0, 200)
        ```
        
        - 스크롤 다운(scroll down)은 스크롤 바를 내리는 작동이며, 이에 따라 웹 페이지는 위로 이동
    - 웹 페이지가 로드 되자마자 자동으로 1초에 10픽셀씩 웹 페이지가 올라가도록 작성
        
        ![image.png](인터넷프로그래밍(2)/image%20129.png)
        
- 웹 페이지 프린트, window.print();
    - 이 코드가 실행되면 인쇄 다이얼로그가 열리고, ‘확인’ 버튼을 누르면 인쇄가 이루어짐
        
        ![image.png](인터넷프로그래밍(2)/image%20130.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20131.png)
        
- onbeforeprint와 onafterprint
    - 웹 페이지의 프린트 과정
        
        ![image.png](인터넷프로그래밍(2)/image%20132.png)
        
    - onbeforeprint와 onafterprint 활용
        - 웹 페이지에는 보이지 않는 회사 로고를 프린트 시 종이에 출력
            
            ![image.png](인터넷프로그래밍(2)/image%20133.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%20134.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20135.png)
    

# location, navigator 객체

- location 객체
    - 윈도우에 로드된 웹 페이지의 URL 정보를 나타내는 객체
    - location 객체로 현재 윈도우에 웹 페이지 열기
        
        ```html
        window.location = "http://www.naver.com";
        window.location.href = = "http://www.naver.com";
        window.location.assign("http://www.naver.com");
        window.location.replace("http://www.naver.com");
        ```
        
    - 새 윈도우에 웹 페이지 열기
        
        ```html
        var win=window.open(); // 빈 윈도우 열기
        win.location="http://www.naver.com"; // 네이버 페이지 로드
        ```
        
    - location 객체의 프로퍼티와 URL의 구성 요소와의 관계
        
        ![image.png](인터넷프로그래밍(2)/image%20136.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20137.png)
        
- navigator 객체
    - 현재 작동중인 브라우저에 대한 다양한 정보를 나타내는 객체
        
        ![image.png](인터넷프로그래밍(2)/image%20138.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20139.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20140.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20141.png)
        

# screen, history 객체

- screen 객체
    - 브라우저가 실행되는 스크린 장치에 관한 정보를 담고 있는 객체
        
        ![image.png](인터넷프로그래밍(2)/image%20142.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20143.png)
        
- history 객체
    - 윈도우에서 방문한 웹 페이지 리스트(히스토리)를 나타내는 객체
        
        ![image.png](인터넷프로그래밍(2)/image%20144.png)
        
    - history 객체를 이용하여 웹 페이지를 이동하는 코드 사례
        
        ![image.png](인터넷프로그래밍(2)/image%20145.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20146.png)
        

# HTML5와 캔버스

- HTML5와 캔버스
    - 웹 페이지에 그래픽을 출력하는 기존의 2방법
        - 사진이나 그림: <img> 태그 이용
        - 그래픽 : 자바 애플릿이나 플래시 등 플러그인 이용
    - HTML5에서 캔버스 도입
        
        ![image.png](인터넷프로그래밍(2)/image%20147.png)
        
- `<canvas>` 태그
    - 웹 페이지에 캔버스 영역 만들기
        
        ![image.png](인터넷프로그래밍(2)/image%20148.png)
        
        - width, height : 캔버스가 만들어지는 영역의 크기(픽셀 단위)로 생략 가능, 각각 디폴트 300, 150 픽셀
        - 웹 페이지에 빈 캔버스 공간 할당
            - 예) 300 x 400 크기의 캔버스 공간 할당
                
                ![image.png](인터넷프로그래밍(2)/image%20149.png)
                
    - 3개의 캔버스를 가진 HTML 페이지를 만들기
        
        ![image.png](인터넷프로그래밍(2)/image%20150.png)
        
    - 캔버스 공간 할당
        
        ```html
        <canvas id="myCanvas" width="300" height="150"></canvas>
        ```
        
    - 캔버스 객체 찾기
        
        ```html
        var canvas = document.getElementById("myCanvas")
        ```
        
    - 캔버스 컨텍스트 얻어내기 : 캔버스에 그림 그리는 도구(컨텍스트) 얻어내기
        
        ```html
        var context = canvas.getContext("2d");
        ```
        
    - 캔버스에 사각형 그리기
        
        ```html
        context.rect(60, 60, 50, 50); // context에 (60, 60)에서 50x50 크기의 사각형 그리기
        context.strokeStyle = "blue"; // 선 색을 파란 색으로 설정
        context.stroke(); // context 내에 구성된 도형을 캔버스에 그림
        ```
        
    - 캔버스의 크기, canvas의 width와 height 프로퍼티
        
        ![image.png](인터넷프로그래밍(2)/image%20151.png)
        
    - 캔버스의 스타일 제어
        
        ```html
        canvas.style.backgroundColor ="yellowgreen";
        ```
        
    
    ![image.png](인터넷프로그래밍(2)/image%20152.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20153.png)
    
- 캔버스 그래픽 좌표와 그래픽 기능
    
    ![image.png](인터넷프로그래밍(2)/image%20154.png)
    

# 도형 그리기와 채우기

- 도형 그리기
    - 캔버스가 지원하는 도형의 종류
        - 직선, 사각형, 원호
        - 외곽선 그리기, 내부 색으로 채워 그리기 모두 가능
    - 도형 그리는 과정
        - 경로(path) 만들기
        - 캔버스에 경로가 담긴 도형 모두 그리기
    - 경로(path) 만들기
        - 그리고자 하는 도형들을 컨텍스트 내 경로에 담는 과정
    - 캔버스에 도형 그리는 순서
        
        ![image.png](인터넷프로그래밍(2)/image%20155.png)
        
    - 도형 그리기 사례
        
        ![image.png](인터넷프로그래밍(2)/image%20156.png)
        
- 경로 닫기, closePath()
    - 경로의 마지막 점과 시작점을 연결하는 직선 추가
    - 더 이상 경로에 새로운 도형을 추가할 수 없음
        - beginPath()를 호출하면 새로운 경로 시작
            
            ![image.png](인터넷프로그래밍(2)/image%20157.png)
            
- 선 그리기와 삼각형 그리기
    - 선 그리는 컨텍스트 메소드
        
        ![image.png](인터넷프로그래밍(2)/image%20158.png)
        
    - 선 그리기
        - moveTo()를 이용하여 시작점을 설정하고, lineTo()로 선을 연결해 나감
        - lineTo(x, y)에 지정한 (x, y)가 끝점이 됨
    - 선으로 삼각형 그리기
        
        ![image.png](인터넷프로그래밍(2)/image%20159.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20160.png)
        
- 원호 그리기
    - 원호를 그리는 arc() 메소드
        
        ```html
        arc(x, y, radius, startAngle, endAngle, anticlockwise)
        ```
        
        - x, y, radius
            - (x, y)는 원호의 중심이고 radius는 반지름
        - startAngle
            - 원호의 시작 각도, 3시를 기점으로 시계방향으로 각도 계산
        - endAngle
            - 원호의 끝 각도, 3시를 기점으로 시계방향으로 각도 계산
        - anticlockwise
            - true이면 반시계 방향, false이면 시계방향으로 원호 그리기
            - 생략 가능하며 디폴트는 시계 방향(false)
        - (x, y)를 중심으로 반지름이 radius이고, startAngle(시작 각도) 지점과 endAngle (끝 각도) 지점을 연결하는 원호를 그림
        - 원호는 anticlockwise의 값에 따라 반시계 방향이나 시계 방향 중 하나로 그려짐
        - 각도는 3시에서 0도 시작
        - 각도는 원주율로 표현
            - 360°는 2𝜋, 90°는 𝜋/2이고, 180°는 𝜋
            - 270° → 3𝜋/2는 자바스크립트 코드 1.5*Math.PI 로 표현
            - 원주율 r = n*Math.PI/180, 여기서 n은 각도(0~360)
    - startAngle(시작 각도)와 endAngle(끝 각도)
        
        ![image.png](인터넷프로그래밍(2)/image%20161.png)
        
    - arc() 메소드로 그린 원호 사례
        
        ![image.png](인터넷프로그래밍(2)/image%20162.png)
        
    
    ![image.png](인터넷프로그래밍(2)/image%20163.png)
    
- 사각형 그리기
    - 사각형 그리는 컨텍스트 메소드
        
        ![image.png](인터넷프로그래밍(2)/image%20164.png)
        
        - 예) (10, 10)에서 100x100 크기의 사각형 그리기
            
            ```html
            context.rect(10, 10, 100, 100);
            // (10, 10)에서 100x100 크기의 사각형을 경로에 추가
            context.stroke(); // context에 구성된 사각형을 캔버스에 그린다.
            ```
            
        - strokeRect() 메소드 이용 - 캔버스에 바로 그리기
            
            ```html
            context.strokeRect(10, 10, 100, 100);
            // (10, 10)에서 100x100 크기의 사각형 그리기
            ```
            
        
        ![image.png](인터넷프로그래밍(2)/image%20165.png)
        
- 캔버스 지우기
    - 캔버스에 그려진 그래픽을 모두 지울 때
        
        ```html
        context.clearRect(0, 0, canvas.width, canvas.height);
        ```
        
        - 이 코드는 경로를 지우지는 못 함
    - 캔버스의 그래픽과 경로를 모두 지울 때
        
        ```html
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.beginPath();
        ```
        
- 도형 꾸미기
    - 선, 원호, 사각형, 글자 등의 색이나 굵기 조절
    - 선 색 : strokeStyle 프로퍼티 이용
        
        ```html
        context.strokeStyle = "blue";
        context.strokeStyle = "#0000FF";
        context.strokeStyle = "rgb(0, 0, 255)";
        ```
        
    - 채우기 색 : fillStyle 프로퍼티
        
        ```html
        context.fillStyle = "red";
        ```
        
    - 선 굵기 : lineWidth 프로퍼티
        
        ```html
        context.lineWidth = 20; // 선 굵기를 20픽셀로 지정
        ```
        
    
    ![image.png](인터넷프로그래밍(2)/image%20166.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20167.png)
    
- 칠하기
    - 도형 내부를 칠하는 기능 : 원호 내부, 사각형 내부, 텍스트 내부 칠하기
    - 칠하는 여러 방법
        - fillStyle 프로퍼티 : 원호나 사각형, 텍스트의 내부를 칠할 색 지정
        - 캔버스에 바로 칠하기, fillRect() : fillStyle의 색으로 사각형 내부 채우기
            
            ![image.png](인터넷프로그래밍(2)/image%20168.png)
            
        - 경로에 닫힌 도형 칠하기, fill() : 사각형과 원호 모두 적용
            
            ![image.png](인터넷프로그래밍(2)/image%20169.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%20170.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20171.png)
    
- 텍스트 그리기
    - 캔버스에 텍스트 그리기
        - 비트맵 이미지로 캔버스에 글자 그리기(출력)
        - 텍스트 그리기는 2가지 방법
            - 텍스트의 외곽선만 그리기 - strokeText()
            - 텍스트 외곽선 없이 내부를 채워 그리기 - fillText()
                
                ```html
                strokeText(text, x, y [, maxWidth])
                fillText(text, x, y [, maxWidth])
                ```
                
                - text: 출력하고자 하는 문자열 텍스트
                - x, y: 텍스트가 출력되는 시작점 (x, y)
                - maxWidth: 텍스트가 출력되는 최대 폭, text가 이 값보다 크면 자동으로 다른 폰트로 대체됨
                - strokeText()는 strokeStyle 색으로 (x, y) 위치에 text의 외곽선만 그리며, fillText()는 외곽선 없이 텍스트 내부를 fillStyle 색으로 칠함
    - 텍스트 그리기 사례
        - 폰트 설정 : font 프로퍼티 이용
            - 예) context.font = “50px arial”;
        - 정렬 설정 : textAlign 프로퍼티 이용
            - 예) context.textAlign = “center”
        - 텍스트 외곽선 그리기
            
            ![image.png](인터넷프로그래밍(2)/image%20172.png)
            
        - 텍스트 채워 그리기
            
            ![image.png](인터넷프로그래밍(2)/image%20173.png)
            
    
    ![image.png](인터넷프로그래밍(2)/image%20174.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20175.png)
    

# 이미지 그리기

- 이미지 그리기
    - 이미지 객체 생성
        - 파일에서 읽은 이미지를 담을 객체 필요
            
            ```html
            var img = new Image();
            ```
            
    - 이미지 그리는 과정
        - 이미지 로딩과 onload
            - 이미지 파일의 로딩이 완료된 후 이미지를 그림
                
                ![image.png](인터넷프로그래밍(2)/image%20176.png)
                
        - 이미지 그리기
            - 컨텍스트 객체의 drawImage() 메소드 이용
    - drawImage()로 이미지 그리기 사례
        1. (20, 20) 위치에 원본 크기로 그리기
        2. (20, 20) 위치에 100 x 200 크기로 그리기
        3. 캔버스에 꽉 차게 이미지 그리기
            
            ![image.png](인터넷프로그래밍(2)/image%20177.png)
            
    - 캔버스의 (20, 20)에 100 x 200 크기로 변형하여 그리기
        
        ![image.png](인터넷프로그래밍(2)/image%20178.png)
        
    - 캔버스에 꽉 차게 이미지 그리기
        
        ![image.png](인터넷프로그래밍(2)/image%20179.png)
        

# canvas 객체와 마우스 이벤트 활용

- 마우스 드래깅으로 캔버스에 그림 그리기
    - 사용자가 마우스로 드래깅하여 캔버스 위에 자유롭게 그림을 그리는 자바스크립트 응용 프로그램 작성
        
        ![image.png](인터넷프로그래밍(2)/image%20180.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20181.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20182.png)
        

# 웹과 저장 및 통신

- 웹의 저장소
    
    ![image.png](인터넷프로그래밍(2)/image%20183.png)
    
- 브라우저와 웹 서버의 통신, HTTP
    
    ![image.png](인터넷프로그래밍(2)/image%20184.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20185.png)
    
- HTTP 통신 과정 보기 실습
    
    ![image.png](인터넷프로그래밍(2)/image%20186.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20187.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20188.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20189.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20190.png)
    

# 쿠키

- 쿠키의 정의와 도입 배경
    - 쿠키란?
        - 웹 서버가 브라우저에게 지시하여 사용자 로컬 컴퓨터에 저장하는 4K 이하의 작은 데이터
    - 쿠키의 도입 배경
        - HTTP의 통신의 기본 약점
            - 브라우저와 웹서버 사이의 통신은 무상태(stateless) 프로토콜임
            - 무상태 프로토콜: 바로 이전 요청과 현재 요청이 연결되어 있음을 기억하지 않는 통신
            - 예) 지금 ‘Java’를 검색하는 사용자가 바로 전에 ‘C++’를 검색한 사용자라는 사실을 모름
        - HTTP의 무상태 프로토콜의 약점을 보완하기 위해 쿠키 도입
- 쿠키 생성 및 사용 과정
    - 쿠키는 웹 서버가 생성하여 브라우저로 보냄
        - 사용자가 어떤 웹 서버에 처음 접속할 때
        - 웹 서버가 다음 요청에서 그 사용자를 기억할 수 있도록 쿠키(쿠키이름과 값)를 만들어 전송
    - 쿠키를 받은 브라우저는 로컬 컴퓨터에 저장
    - 로컬 컴퓨터에서 동일한 웹 서버에 요청할 때 쿠키를 함께 전송
        - 웹 서버로 요청하는 경우: 웹 페이지 요청, 이미지 요청 등 모든 웹 자원 요청 포함
    - 쿠키를 받은 웹 서버는 어떤 사용자로부터 요청이 왔는지 알 수 있음
    
    ![image.png](인터넷프로그래밍(2)/image%20191.png)
    
- 쿠키 데이터 구성과 사례
    
    ![image.png](인터넷프로그래밍(2)/image%20192.png)
    
- 쿠키는 웹 페이지 사이의 정보 공유에 활용
    
    ![image.png](인터넷프로그래밍(2)/image%20193.png)
    
- 구글 웹 사이트가 남긴 쿠키 보기 실습
    
    ![image.png](인터넷프로그래밍(2)/image%20194.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20195.png)
    
- 자바스크립트로 쿠키 다루기
    - 자바스크립트 코드를 이용하여 로컬 컴퓨터에 쿠키 쓰기/읽기 가능
    - 자바스크립트에서 쿠키 접근: document.cookie
        - 윈도우에 출력된 웹 페이지를 전송한 웹 서버의 모든 쿠키들이 문자열 형태로 연결
        
        ![image.png](인터넷프로그래밍(2)/image%20196.png)
        
- 쿠키 활용 실습
    - 실습 전 준비 사항
        - 브라우저에 따라 다른 점
            - 익스플로러 경우, 웹 서버로부터 로드한 웹 페이지의 자바스크립트 코드에서만 쿠키 읽기/쓰기 가능
            - 크롬에서는 로컬 컴퓨터에서도 가능
        - 로컬 컴퓨터에 웹 서버 설치
            - 사용자 컴퓨터에 몽구스 웹 서버 다운 및 설치
            - 다음 사이트에서 몽구스(mongoose-free-6.5.exe) 다운로드
                - : [https://www.cesanta.com/products/binary](https://www.cesanta.com/products/binary)
                - : [http://www.webprogramming.co.kr/download](http://www.webprogramming.co.kr/download)
    - 자바스크립트로 방문자 이름과 방문 횟수 관리 실습
        - 실습 과정
        - ex12-01.html을 몽구스 웹 서버 (예: C:/webserver/12/) 폴더에 저장
        - ex12-01.html을 출력 [http://localhost/12/ex12-01.html](http://localhost/12/ex12-01.html)
        
        ![image.png](인터넷프로그래밍(2)/image%20197.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20198.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20199.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20200.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20201.png)
        

# 웹 스토리지(Web Storage)

- 웹 스토리지 필요성
    - 웹은 웹 애플리케이션의 형태로 진화
        - 웹 문서를 보여주기나 검색, 구매 등 정보 소통 수단을 넘어섬
        - 웹 애플리케이션 사례: 게임, 그림 그리기, 학습
    - 웹 애플리케이션은 실행 도중 로컬 컴퓨터에 데이터 저장 공간 필요
        - 예)  게임 웹 애플리케이션: 사용자 이름, 점수, 최고 점수자의 이름과 점수 등
        - 예)  쇼핑몰: 사용자가 구입하려고 담은 리스트
    - HTML5에서 웹 스토리지(web storage) 도입
        - 사용자 로컬 컴퓨터의 저장 공간
        - 웹 서버의 저장 부담과 네트워크 트래픽 감소
        - HTML5 웹 스토리지는 오직 자바스크립트로만 읽고 쓸 수 있음
    - 쿠키의 한계
        - 쿠키의 크기는 4KB로 제한: 충분한 양의 정보 저장 한계
        - 쿠키는 불필요한 트래픽 발생
            - 브라우저가 웹 서버에 요청을 보낼 때마다 함께 전송하기 때문
        - 쿠키는 윈도우마다 독립적인 값을 저장 불가
            - 브라우저의 모든 윈도우들이 공유하므로
- 웹 스토리지 종류와 특징
    
    ![image.png](인터넷프로그래밍(2)/image%20202.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20203.png)
    
- 세션 스토리지
    - 세션: 연결된 웹 사이트와 윈도우
    - 윈도우에 웹 사이트가 로드될 때 세션 스토리지 생성
        - 한 윈도우에 여러 세션 스토리지 생성 가능
    - 윈도우가 닫힐 때 세션 스토리지 소멸
        
        ![image.png](인터넷프로그래밍(2)/image%20204.png)
        
    - 세션 스토리지의 공유 범위
        - 윈도우마다 세션 스토리지 별도 생성
            - 윈도우 사이에서는 공유되지 않음
    - 세션 스토리지 공유
        - 윈도우에 로드된 웹 사이트의 모든 웹 페이지들이 세션 스토리지 공유
    - 세션 스토리지의 용도
        - 한 윈도우에서 연결된 웹 사이트의 웹 페이지들끼리 데이터를 주고 받는 임시 저장 공간
        
        ![image.png](인터넷프로그래밍(2)/image%20205.png)
        
- 로컬 스토리지
    - 로컬 스토리지의 생성과 소멸, 공유
        - 윈도우에 상관없이 웹 서버(웹 사이트) 당 하나 씩 생성
        - 브라우저 종료하거나 컴퓨터가 커져도 존재
        - 웹 사이트의 모든 웹 페이지가 로컬 스토리지 공유
    - 로컬 스토리지의 용도
        - 오프라인 상태에서 웹 애플리케이션이 로컬 컴퓨터의 로컬 스토리지에 저장 가능
        
        ![image.png](인터넷프로그래밍(2)/image%20206.png)
        
- 자바 스크립트로 웹 스토리지 다루기
    - Storage 인터페이스: 자바스크립트로 웹 스토리지 읽기/쓰기
        - 브라우저가 제공
            
            ![image.png](인터넷프로그래밍(2)/image%20207.png)
            
    - 윈도우에 웹 페이지가 로드되면, 세션 스토리지와 로컬 스토리지 자동 생성
        - sessionStorage, localStorage, window.sessionStorage, window.localStorage
        - Storage 인터페이스의 프로퍼티와 메소드
        - 자바스크립트 코드로 웹 스토리지 액세스를 위한 객체
    - sessionStorage와 localStorage 다루기
        
        ![image.png](인터넷프로그래밍(2)/image%20208.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20209.png)
        
    - 세션 스토리지의 모든 아이템 출력
        
        ![image.png](인터넷프로그래밍(2)/image%20210.png)
        
- 응용 실습 : Chrome 브라우저로 세션 스토리지에 아이템 저장/검색
    - 세션 스토리지를 조작하는 웹 페이지 작성
        
        ![image.png](인터넷프로그래밍(2)/image%20211.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20212.png)
        
    - 개발자 도구로 세션 스토리지 보기
        
        ![image.png](인터넷프로그래밍(2)/image%20213.png)
        
    - 세션 스토리지에 아이템 쓰기
        
        ![image.png](인터넷프로그래밍(2)/image%20214.png)
        
    - 세션 스토리지에서 아이템 검색
        
        ![image.png](인터넷프로그래밍(2)/image%20215.png)
        
    - 다른 웹사이트 방문 후 돌아와 세션 스토리지 확인
        
        ![image.png](인터넷프로그래밍(2)/image%20216.png)
        

# 웹 스토리지 이벤트

- storage 이벤트
    - 웹 스토리지 변경 시 발생
        - 아이템 추가, 삭제, 전체 삭제, 아이템 값 변경 등의 경우
        - 웹 스토리지를 변경한 윈도우 외 다른 모든 윈도우에게 전달
        - window 객체만 storage 이벤트 받을 수 있음
    - StorageEvent 객체
        - 웹 스토리지 변경 정보를 담은 이벤트 객체
            
            ![image.png](인터넷프로그래밍(2)/image%20217.png)
            
    - storage 이벤트 처리
        
        ![image.png](인터넷프로그래밍(2)/image%20218.png)
        
- 로컬 스토리지에 storage 이벤트 실습
    - storage 이벤트 실습 코드 : storageEvent.html
        
        ```html
        <!DOCTYPE html>
        <html>
        <head><title>로컬 스토리지에 StorageEvent</title>
        </head>
        <body>
        <h3>로컬 스토리지에 StorageEvent</h3>
        <hr>
        품목명 : <input id="item" type="text" size="10">
        개수 : <input id="count" type="text" size="10">
        <button id="save" onclick="store()">저장</button>
        <button id="retrieve" onclick="retrieve()">검색</button><p>
        로컬 스토리지의 변경 내용(storage 이벤트):<br>
        <textarea id="textarea" cols="60" rows="6"></textarea>
        <script>
        window.addEventListener("storage", storageEventListener, false);
        function storageEventListener(e) { // e는 StorageEvent 객체
        var eventDetail = "key:\t\t\t" + e.key + "\n" +
        "oldValue:\t\t" + e.oldValue + "\n" +
        "newValue:\t\t" + e.newValue + "\n" +
        "storageArea:\t" + e.storageArea + "\n" +
        "url:\t\t\t" + e.url;
        document.getElementById("textarea").innerHTML = eventDetail;
        //<textarea>에 출력
        }
        </script>
        <script>
        var item = document.getElementById("item");
        var count = document.getElementById("count");
        function store() {
        if (!window.localStorage) {
        alert("로컬스토리지를 지원하지 않습니다.");
        return;
        }
        localStorage.setItem(item.value, count.value);
        }
        function retrieve() {
        if (!window.localStorage) {
        alert("로컬스토리지를 지원하지 않습니다.");
        return;
        }
        var val = localStorage.getItem(item.value);
        if(val == null)
        alert(item.value + "는 구입 리스트에 없습니다.");
        else
        count.value = val;
        }
        </script>
        </body>
        </html>
        ```
        
    - Chrome 브라우저로 두 윈도우에 각각 storageEvent.html 열기
        
        ![image.png](인터넷프로그래밍(2)/image%20219.png)
        
    - 윈도우 1에서 (골뱅이, 200) 아이템을 로컬 스토리지에 저장
        
        ![image.png](인터넷프로그래밍(2)/image%20220.png)
        
    - 윈도우 1에서 (골뱅이, 200) 아이템의 ‘값’을 200에서 50으로 수정
        
        ![image.png](인터넷프로그래밍(2)/image%20221.png)
        

# 오디오/비디오 제어

- HTML5의 오디오/비디오 제어
    - `<audio>`,` <video>`  태그
        - HTML5에서 플러그인의 도움 없이 오디오/비디오 삽입
    - 자바스크립트 코드로 미디어 재생/중단 등 미디어 제어
        
        ![image.png](인터넷프로그래밍(2)/image%20222.png)
        
        ![image.png](인터넷프로그래밍(2)/image%20223.png)
        
- 자바스크립트로 오디오 제어
    - `<audio>` 태그에 로드된 오디오 제어
        
        ![image.png](인터넷프로그래밍(2)/image%20224.png)
        
        ```html
        <!DOCTYPE html>
        <html>
        <head><title>자바스크립트로 오디오 제어</title></head>
        <body>
        <h3>자바스크립트로 오디오 제어</h3>
        <hr>
        <audio id="audio" src="media/EmbraceableYou.mp3"></audio>
        <div id="msg">이곳에 오디오 제어 메시지 출력</div>
        <button id="play" onclick="control(event)">play</button>
        <button id="pause" onclick="control(event)">pause</button>
        <button id="replay" onclick="control(event)">replay</button>
        <button id="vol-" onclick="control(event)">vol-</button>
        <button id="vol+" onclick="control(event)">vol+</button>
        <button id="mute on/off" onclick="control(event)">mute on/off</button>
        <script>
        var div = document.getElementById("msg");
        var audio = document.getElementById("audio");
        function control(e) {
        var id = e.target.id;
        if(id == "play") { // play 버튼 클릭
        audio.play(); // 재생
        div.innerHTML = "재생중입니다.";
        }
        else if(id == "pause") { // pause 버튼 클릭
        audio.pause(); // 일시 중지
        div.innerHTML = "일시중지되었습니다.";
        }
        else if(id == "replay") { // replay 버튼 클릭
        audio.load(); // src에 지정된 미디어 다시 로딩
        audio.play(); // 처음부터 다시 재생
        div.innerHTML = audio.src + "를 처음부터 재생합니다.";
        }
        }
        else if(id == "vol-") { // vol- 버튼 클릭
        audio.volume -= 0.1; // 음량 0.1 감소
        if(audio.volume < 0.1) audio.volume = 0;
        div.innerHTML = "음량 0.1 감소." + "현재 " + audio.volume;
        }
        else if(id == "vol+") { // vol+ 버튼 클릭
        audio.volume += 0.1; // 음량 0.1 증가
        if(audio.volume > 0.9) audio.volume = 1.0;
        div.innerHTML = "음량 0.1 증가." + "현재 " + audio.volume;
        }
        else if(id == "mute on/off") { // mute on/off 버튼 클릭
        audio.muted = !audio.muted; // 음소거 토글
        if(audio.muted) div.innerHTML = "음소거";
        else div.innerHTML = "음소거 해제";
        }
        }
        </script>
        </body></html>
        ```
        
        ![image.png](인터넷프로그래밍(2)/image%20225.png)
        
- 자바스크립트로 비디오 제어
    - `<video>` 태그에 로드된 비디오 제어
        
        ```html
        <video id="video" width="320" height="240" autoplay controls>...</video>
        ```
        
    - 비디오 DOM 객체 알아내기
        
        ```html
        var video = document.getElementById("video");
        ```
        
    - width, height와 videoWidth, videoHeight 프로퍼티
        
        ![image.png](인터넷프로그래밍(2)/image%20226.png)
        
    - `<video>` 태그에 로드된 비디오 제어
        - loadedmetadata 이벤트
            - 비디오 파일의 로드 완료 시, video 객체에 loadedmetadata 이벤트 발생
            - 예) 비디오의 해상도 알아내기: 비디오가 로드되어야 비로소 videoWidth, videoHeight 프로퍼티가 정확한 값을 가짐
                
                ```html
                video.onloadedmetadata = function f(e) {
                alert(video.videoWidth + "," + video.videoHeight);
                }
                ```
                
    - 비디오를 원본 크기로 재생
        
        ![image.png](인터넷프로그래밍(2)/image%20227.png)
        
- 오디오와 비디오의 onended 리스너
    - onended 리스너
        - 오디오/비디오의 재생이 완료되었을 때 호출되는 이벤트 리스너
            
            ```html
            <audio id="audio" src="media/EmbraceableYou.mp3" autoplay controls>
            </audio>
            <script>
            var audio = document.getElementById("audio");
            audio.onended = function (e) { // ended 이벤트 처리 코드
            }
            </script>
            ```
            
        - loop 속성이 설정되면 onended 이벤트 리스너 호출되지 않음
            
            ```html
            <audio arc="..." loop> <!-- loop 속성이 있으면 ended 이벤트 발생하지 않음 -->
            ```
            
    - 오디오 재생이 끝나면 웹 페이지를 노란색으로 변경
        
        ![image.png](인터넷프로그래밍(2)/image%20228.png)
        
- 미디어 소스 변경/미디어 로드
    - 현재 재생 중인 미디어 변경(3단계)
        - audio.src="media/Aegukga.mp3"; // 새로운 미디어 지정
        - audio.load(); // src에 지정된 미디어 새로 로딩, 생략 가능
        - audio.play(); // 로딩된 미디어 재생

# Geolocation 객체를 이용한 위치 정보 서비스

- 위치 정보 서비스
    - HTML5의 위치 정보 서비스란?
        - 컴퓨터/모바일 장치의 위도와 경도를 자바스크립트 코드에게 공급
    - geolocation 객체
        - 위치 정보 서비스를 제공하는 자바스크립트 객체
            
            ```html
            navigator.geolocation, window.navigator.geolocation
            ```
            
    - 위치 정보 서비스 2가지
        - 현재 위치 서비스: 요청 시 현재 위치를 알려주는 서비스
        - 반복 위치 서비스: 위치가 변경될 때마다 반복하여 알려주는 서비스
            
            ![image.png](인터넷프로그래밍(2)/image%20229.png)
            
    - 브라우저의 위치 정보 서비스 지원 여부
        
        ```html
        if(navigator.geolocation) { // 브라우저가 위치 정보 서비스를 제공
        }
        ```
        
- 현재 위치 얻기
    - getCurrentPosition() 메소드 호출
        - getCurrentPosition()은 호출 즉시 현재 위치를 리턴하는 것이 아님
        - 위치가 파악되면 호출될 콜백 함수 positionCallback (Position) 등록
            
            ```html
            navigator.geolocation.getCurrentPosition(found); // found()를 콜백 함수로 등록
            ...
            // 위치가 파악되면 found() 호출, 위치 정보가 있는 position 객체가 매개 변수로 전달
            function found(position) {
            var lat = position.coords.latitude; // 위도
            var lon = position.coords.longitude; // 경도
            alert("현재위치(" + lat + ", " + lon + ")");
            }
            ```
            
        
        ```html
        <!DOCTYPE html>
        <html>
        <head><title>getCurrentPosition()로 현재 위치 파악</title></head>
        <body>
        <h3>getCurrentPosition()로 현재 위치 파악</h3>
        <hr>
        <div id="msg">이곳에 위치 정보 출력</div>
        <div id="map"></div>
        <script>
        if(!navigator.geolocation)
        alert("지원하지 않음");
        else // found() 콜백 함수 등록
        navigator.geolocation.getCurrentPosition(found); 
        // 위치가 파악되면 found()가 호출
        // 위치 정보 들어 있는 position 객가 매개 변수로 넘어온다.
        function found(position) {
        var now = new Date(position.timestamp);
        var lat = position.coords.latitude; // 위도
        var lon = position.coords.longitude; // 경도
        var acc = position.coords.accuracy; // 정확도
        // 위도와 경도의 소수점 이하 자리가 너무 길어 유효 숫자 6자리로 자름
        lat = lat.toPrecision(6); lon = lon.toPrecision(6);
        var text = "현재 시간 " + now.toUTCString() + "<br>";
        text += "현재 위치 (위도 " + lat + "°, 경도 " + lon + "°)<br>";
        text += "정확도 " + acc + "m<br>";
        document.getElementById("msg").innerHTML = text;
        var img = new Image();
        img.src = "https://maps.googleapis.com/maps/api/staticmap?center="
        + lat
        + "," + lon + "&zoom=13&size=400x300&sensor=false&markers
        =color:red%7Clabel:C%7C"+lat +"," +lon;
        document.getElementById("map").appendChild(img);
        // 구글 지도 이미지를 div의 자식으로 붙임
        }
        </script></body></html>
        ```
        
        ![image.png](인터넷프로그래밍(2)/image%20230.png)
        
    - 삼성 갤럭시 탭에서도 잘 동작
        - Google Geolocation 서비스를 받기 위해서는 API_KEY를 Google Developers Console에서 발급받아 사용해야 함
        - 현재 대부분 모바일 장치에서는 API_KEY가 받아져 있기 때문에 이 예제는 모바일 단말기에서는 잘 작동함
            
            ![image.png](인터넷프로그래밍(2)/image%20231.png)
            
- 반복 위치 서비스
    - 위치 변경 시마다 현재 위치 얻기
        - watchPosition() 호출
            - 위치가 변경될 때마다 호출되는 콜백 함수 등록
            - watchPosition()의 리턴 값: 반복 위치 서비스 id
            
            ```html
            var watchID = navigator.geolocation.watchPosition(changed);
            // changed()를 콜백 함수로 등록하고, 반복 위치 서비스 시작
            ...
            // 위치가 바뀌면 changed() 호출,
            //위치 정보가 있는 position 객체가 매개 변수로 전달
            function changed(position) {
            var lat = position.coords.latitude; // 변경된 위도
            var lon = position.coords.longitude; // 변경된 경도
            alert("(" + lat + ", " + lon + ") 위치로 변경됨");
            }
            ```
            
    - 반복 위치 서비스 중단
        - clearWatch() 호출
        - watchPosition()가 리턴한 id로 반복 위치 서비스 중단
            
            ```html
            navigator.geolocation.clearWatch(watchID);
            // watchID의 반복 위치 서비스 중단
            ```
            
            ```html
            <!DOCTYPE html>
            <html>
            <head><title>watchPosition()으로 반복 위치 서비스</title></head>
            <body>
            <h3>watchPosition()으로 반복 위치 서비스</h3>
            <hr>
            <div id="msg">이곳에 위치 정보 출력</div>
            <div id="map"></div>
            <script>
            if(!navigator.geolocation)
            alert("지원하지 않음");
            else {
            var options = {
            // 3 개의 값을 가진 전역 객체. watchPosition()의 마지막 매개 변수로 전달
            enableHighAccuracy: false,
            timeout: 5000,
            maximumAge: 0 };
            var img = new Image();
            var count=0;
            var watchID;
            // changed() 콜백 함수 등록하고, 반복된 위치 서비스를 시작
            watchID = navigator.geolocation.watchPosition(changed, null, options);
            }
            //위치가 바뀌면 changed()가 호출되고, 위치 정보가 들어 있는 position 객체가 매개 변수로 넘어옴
            function changed(position) {
            if(count == 5) { // clearWatch() 테스트를 위해 5번만 서비스
            navigator.geolocation.clearWatch(watchID); // 반복 서비스 종료
            document.getElementById("msg").innerHTML = "위치 서비스 종료";
            return;
            }
            var lat = position.coords.latitude; // 변경된 위도
            var lon = position.coords.longitude // 변경된 경도
            var text = count + ": (위도 " + lat + "°, 경도 " + lon + "°)로 변경됨<br>";
            document.getElementById("msg").innerHTML = text; // 위치 정보 출력
            // 지도 이미지 갱신
            img.src = "https://maps.googleapis.com/maps/api/staticmap?center=" + lat
            + "," + lon + "&zoom=13&size=400x300&sensor
            =false&markers=color:red%7Clabel:C%7C"+lat +"," +lon;
            if(count == 0) // 처음이면 구글 지도 이미지 부착
            document.getElementById("map").appendChild(img);
            // 지도 이미지 부착
            count++; // 갱신 회수 증가
            }
            </script></body></html>
            ```
            
    - 삼성 갤럭시 탭에서도 반복 위치 서비스 작동
        
        ![image.png](인터넷프로그래밍(2)/image%20232.png)
        

# 웹 워커(Web Workers)

- 웹 워커(Web Workers)란?
    - 백그라운드 태스크를 만드는 기능
        - 자바스크립트 코드를 백그라운드에서 별도로 실행시킬 수 있는 HTML5 표준 기능
        - 백그라운드 태스크를 워커 태스크라고 부름
    - 실행 시간이 긴 계산 작업에 적합
        - 워커 태스크는 윈도우와 사용자 인터페이스 사용 불가능
    - 웹 워커의 특징
        - 백그라운드 태스크로 실행할 자바스크립트 코드는 파일 형태로 저장
        - 동일 도메인(same origin) 원칙 준수
            - 자바스크립트 파일은 웹 페이지와 동일한 웹 사이트에 저장
        - 로컬 컴퓨터의 웹 페이지에서는 작동하지 않음
            - 웹 서버 설치 및 작동 필요
- 워커 객체와 워커 태스크
    - 워커 태스크(Worker Task)
        - 웹 워커 기능을 이용하여 만든 백그라운드 태스크
    - 워커 태스크 만들기
        - 워커 태스크를 만들 자바스크립트 코드(add1to10.js) 준비
            
            ```html
            // 1에서 10까지 더하고 결과 전송
            var sum = 0;
            for(var i=1; i<=10; i++) {
            sum += i;
            }
            postMessage(sum); // sum을 메인 태스크에 전송
            ```
            
        - 워커 태스크와 워커 객체 생성
            
            ![image.png](인터넷프로그래밍(2)/image%20233.png)
            
- var addWorker = new Worker(”add 1 to 10.js”);
    - 워커 태스크
        - 독립적으로 실행되는 작업 단위
    - 워커 객체
        - 워커 태스크로부터 이벤트와 데이터 주고 받기
        - 워크 태스크 중단 등, 워커 태스크를 제어하는 객체
    
    ![image.png](인터넷프로그래밍(2)/image%20234.png)
    
- 워커(Worker) 객체의 메소드와 이벤트 리스너
    
    ![image.png](인터넷프로그래밍(2)/image%20235.png)
    

# 워커 태스크의 이벤트 처리

- 워커 태스크의 실행 환경
    
    ![image.png](인터넷프로그래밍(2)/image%20236.png)
    
- 워커 태스크에서 워커 객체로 message 이벤트 보내기
    
    ![image.png](인터넷프로그래밍(2)/image%20237.png)
    
- message 이벤트 보내는 과정
    - 워커 태스크에서 postMessage() 호출
        - 매개 변수에 보내고자 하는 데이터 전달
            
            ```html
            postMessage(sum); // sum = 55
            ```
            
    - 데이터를 MessageEvent 객체로 만들어 전달
        - 워커 객체에서 MessageEvent 객체를 통해 데이터 수신
        - MessageEvent 객체의 프로퍼티
            
            ![image.png](인터넷프로그래밍(2)/image%20238.png)
            
    - 워커 객체의 onmessage 리스너
        - onmessage 리스너: 워커 태스크가 보내는 message 이벤트를 받는 코드
            
            ```html
            addWorker.onmessage = function (e) { // e에 MessageEvent 객체가 전달
            alert(e.data); // e.data는 “55”
            }
            ```
            
- 1~10까지 더하는 워커 태스크 만들기 예제
    
    ![image.png](인터넷프로그래밍(2)/image%20239.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20240.png)
    
- 메인 태스크에서 워커 태스크로 message 이벤트 보내기
    
    ![image.png](인터넷프로그래밍(2)/image%20241.png)
    
- 메인 태스크와 워커 태스크 사이의 데이터 전송
    
    ![image.png](인터넷프로그래밍(2)/image%20242.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20243.png)
    
    ![image.png](인터넷프로그래밍(2)/image%20244.png)
    
- 워커 태스크 종료
    
    ![image.png](인터넷프로그래밍(2)/image%20245.png)
    
- 1초 단위로 메시지를 보내는 워커 태스크 만들기
    
    ![image.png](인터넷프로그래밍(2)/image%20246.png)
    
    ```html
    <!DOCTYPE html>
    <html>
    <head><title>타이머를 가진 웹 워커 만들기</title></head>
    <body>
    <h3>타이머를 가진 웹 워커 만들기</h3>
    <hr>
    <div><span id="timer">타이머카운트</span></div>
    <button id="start" onclick="start()">start</button>
    <button id="stop" onclick="stop()">stop</button>
    <script>
    var addWorker = new Worker("timer.js"); // 워커 태스크 생성
    addWorker.onmessage = function (e) {
    document.getElementById("timer").innerHTML = e.data;
    }
    function start() {
    addWorker.postMessage("start");
    }
    function stop() {
    addWorker.postMessage("stop");
    }
    </script>
    </body>
    </html>
    ```
    
    ```jsx
    var count=1;
    var timerID=null; // 타이머 ID
    onmessage = function (e) { // 브라우저로부터 메시지 수신
    if(e.data == "start") {
    if(timerID != null) return; // 타이머 작동중이면 리턴
    timerID = setInterval(myCallback, 1000); // 1초 간격
    myCallback() 호출
    }
    else if(e.data == "stop") {
    if(timerID == null) return; // 타이머 작동하지 않으면 리턴
    clearInterval(timerID);
    close(); // 워커 태스크 종료. 더 이상 메시지 받지 않음
    }
    }
    function myCallback() { // 1초 간격으로 호출
    postMessage(count); // 카운트 값을 브라우저로 전송
    count++; // 카운트 값 증가
    }
    ```