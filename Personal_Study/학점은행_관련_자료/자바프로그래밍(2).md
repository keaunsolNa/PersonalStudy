# 자바 프로그래밍 (2)

# 클래스와 구조체의 차이

- 클래스와 구조체의 차이
    
    ![image.png](자바프로그래밍(2)/image.png)
    

# 은닉성

- 은닉성
    
    ![image.png](자바프로그래밍(2)/image%201.png)
    
    ![image.png](자바프로그래밍(2)/image%202.png)
    
- 접근 지정자
    - Private
    - Default
- 논리 연산자 사용 시 주의 사항
    - 논리 곱, 논리 합 연산 시 불필요할 경우 두 번째 피 연산자 내의 연산은 수행하지 않음

# 생성자

- 생성자
    - 생성자(Constructor)는 멤버 함수와 유사함
    - 클래스와 동일한 이름 사용
    - 매개 변수를 가짐
    - 반환 값이 없음
    - 오류 발생 처리 방법에 따라 객체가 생성되지 않을 수 있음
- 기본 생성자(Default Constructro)
    - 매개 변수가 없음

# Method overload

- Method overload
    - 동일한 이름의 멤버 함수(생성자 함수)가 공존할 수 있음
    - 매개 변수 구성의 차이로 구분함
        
        ![image.png](자바프로그래밍(2)/image%203.png)
        
        ![image.png](자바프로그래밍(2)/image%204.png)
        
        ![image.png](자바프로그래밍(2)/image%205.png)
        

# 상속의 개념과 설계

- 상속의 개념과 설계
    - 일반화 vs 구체화
    - Is -a 관계
    - 종속과문강목계
    - 클래스 재활용
        
        ![image.png](자바프로그래밍(2)/image%206.png)
        
- final
    - final class
        - 상속 금지
    - final 변수
        - 상수
        - 값 변경 불가 (지역 변수와 멤버 변수 모두에 적용 가능)
    - final 멤버 함수
        - 오버라이딩(overriding) 불가
- 추상 클래스
    - 객체를 생성할 수 없는 클래스
- super와 super()
    - super
        - 상위 클래스
        - this 안에 포함되어 있음
    - super()
        - 상위 클래스의 생성자
        - 생성자 첫 머리에 자리함
        - 사용하지 않을 경우 컴파일러가 기본 생성자 super() 추가

# package와 import

- package 와 import
    - 유사한 클래스의 모음
    - 디렉토리 구조
    - 필요할 때, import로 사용
- 접근 지정자
    
    ![image.png](자바프로그래밍(2)/image%207.png)
    
    - private
        - 무조건 접근 금지
    - protected
        - 자식 클래스에서만 접근 가능
        - 단, 동일 패키지 내의 클래스라면 자식 클래스가 아니어도 접근 허용
    - default
        - 패키지 외부에서의 접근을 금지
        - 무제한 허용
    - public
        - 모든 클래스에게 문호가 열려 있음

# 메소드 오버라이딩

- 멤버 함수 오버라이딩
    - 부모 클래스의 멤버 함수와 동일한 멤버 함수를 자식 클래스에서 재정의
    - 자식 클래스의 속성 추가에 따른 기능 변화 등
    - 접근 지정자의 범위는 넓어져야 함
- 멤버 변수 오버라이딩
    - 동일한 이름의 멤버 변수 재정의
    - 좋은 접근은 아니다

# 객체 지향에서의 형 변환

- 객체 지향에서의 형 변환
    - 부모 클래스와 자식 클래스
    - Is-a 관계에 집중
    - 자동 형 변환과 강제 형 변환
    - 생성 당시의 속성 유지
        
        ![image.png](자바프로그래밍(2)/image%208.png)
        

# 형 변환을 돕는 연산자

- 형 변환을 돕는 연산자
    - instanceof

# 예외 처리

- JAVA에서 기본 제공하는 예외 클래스
    
    ![image.png](자바프로그래밍(2)/image%209.png)
    
- JVM이 처리하는 ERROR
    
    ![image.png](자바프로그래밍(2)/image%2010.png)
    
- 개발자가 설계하는 Exception
    
    ![image.png](자바프로그래밍(2)/image%2011.png)
    
    ![image.png](자바프로그래밍(2)/image%2012.png)
    
    ![image.png](자바프로그래밍(2)/image%2013.png)
    
    ![image.png](자바프로그래밍(2)/image%2014.png)
    
    ![image.png](자바프로그래밍(2)/image%2015.png)
    
- Exception 객체 던지고 받기
    - throw
        - return과 유사
        - Exception 객체를 던지면서 해당 함수는 종료됨
        - 생성자의 경우에는 객체가 생성되지 않음
    - throws
        - 함수가 Exception 객체를 던질 수 있음을 호출자에게 알림
        - 복수개의 Excpetion 종류를 쉼표로 구분하여 나열할 수 있음
    - try-catch
        - try 블록에서 발생한 예외는 catch 블록에서 처리
        - 상속 관계를 고려해야 함
            - 부모 클래스의 catch 뒤에 자식 클래스의 catch는 수행되지 않음
        - 예외 발생 유무에 상관 없이 무조건 수행해야 하는 내용은 finally 블록에 배치
        
        ![image.png](자바프로그래밍(2)/image%2016.png)
        

# 다형성의 이해

- 다형성의 이해
    - 상속
    - 오버라이딩
    - 반복

# 파일 관리 및 입출력

- 파일 관련 클래스
    - 파일 관리 클래스
        - File
    - 파일 입력 클래스
        - Scanner, BufferedReader, FileReader
    - 파일 출력 클래스
        - PrintWriter, BufferedWriter, FileWriter

# 인터페이스의 탄생 배경과 특징

- 인터페이스의 탄생 배경
    - 전역 상수 보관
    - 함수 원형을 통한 다형성
- 인터페이스의 특징
    - 멤버 상수만 존재 : public final static
    - 원래는 abstract 멤버 함수만 존재(최근 default 멤버 함수 포함)
    - 객체를 생성할 수 없음
    - 다중 상속 가능
    - 오버라이딩을 활용한 다형성 제공

# static 멤버의 필요성

- static 멤버 변수
    - 필요성
        - 동일 클래스 객체간 정보 공유
        - 전 프로그램이 공유하는 정보 관리
            - 은닉성 주의
            - 상수인 경우 유용
    - 특징
        - 클래스를 기반으로 접근 가능
        - 공유 정보
- static 멤버 함수
    - 필요성
        - 객체 생성 전
            - 예 : main()
        - 객체 정보와 무관한 서비스
    - 특징
        - 객체를 기반으로 하지 않음
        - non-static 멤버 접근 시 주의 요망
        
        ![image.png](자바프로그래밍(2)/image%2017.png)
        

# 링크드 리스트의 개념

- 링크드 리스트의 개념
    - 배열과 유사
    - 중간 삽입 및 삭제 용이
    - 크기 변경 시 비용 절감
    - 메모리 사용량 증가
    
    ![image.png](자바프로그래밍(2)/image%2018.png)
    
    ![image.png](자바프로그래밍(2)/image%2019.png)
    
    ![image.png](자바프로그래밍(2)/image%2020.png)
    
    ![image.png](자바프로그래밍(2)/image%2021.png)
    
    ![image.png](자바프로그래밍(2)/image%2022.png)
    
    ![image.png](자바프로그래밍(2)/image%2023.png)
    
    ![image.png](자바프로그래밍(2)/image%2024.png)
    

# 2차원 배열 초기화

- 2차원 배열 초기화
    
    ![image.png](자바프로그래밍(2)/image%2025.png)
    

# 객체 기반 알고리즘

- 객체 기반 알고리즘
    - MyLinkedList 기반 미로 찾기 알고리즘
    - 상속과 위치 정보 추가

# 재귀 호출

- 재귀 호출
    - 함수 내에서 동일한 함수를 호출
    - 반복 수행
    - 반복 구문의 단순화
    - 함수 스택 추가 사용
    - 작업 수행 속도 손실 발생

# API와 SPI의 개념 이해

- API와 SPI
    - API : Application Programming Interface
        - 서비스 제공
        - 함수 혹은 클래스
    - SPI : Service Provider Interface
        - 서비스 제공 요구
        - 함수 혹은 인터페이스
- JAVA에서의 API와 SPI
    
    ![image.png](자바프로그래밍(2)/image%2026.png)
    
- 인터페이스를 구현한 SPI의 예
    - java.lang.iterable
        - 객체를 반복문에서 효과적으로 사용할 수 있도록 함
    - java.io.Serializable
        - 객체 정보의 입출력을 일렬화하는 데 사용
    - java.lang.Runnable
        - 객체를 thread로 사용할 수 있도록 함
    - java.lang.Comparable
        - 객체 간의 비교를 클래스 개발자가 정의할 수 있도록 함

# 인터페이스 implements

- 인터페이스 implements 문법
    
    ![image.png](자바프로그래밍(2)/image%2027.png)
    
- 인터페이스 implements와 클래스 extends
    
    ![image.png](자바프로그래밍(2)/image%2028.png)
    
    - extends 키워드는 상속을 표현
    - 클래스
        - 하나의 클래스만 상속할 수 있음
            - 일반화와 구체화의 과정
        - 하나 이상의 인터페이스를 implements 할 수 있음
    - 인터페이스
        - 다수의 인터페이스를 extends 할 수 있음
        - 클래스를 상속할 수 없음
        - 인터페이스의 변수 선언은 모두 public final static이며, 상수임
            - 생략해도 컴파일러는 인터페이스에 자동으로 public final static을 추가
        - 인터페이스 기반으로 객체를 생성할 수 없음
            - 당연히 인터페이스는 생성자를 가지지 않음
        - 멤버 함수는 기본적으로 abstract
            - 생략된 경우, 컴파일러가 자동으로 추가함
        - 함수 본체를 가지는 멤버 함수를 가질 수 있음
            - 이 경우 default 키워드를 동반해야 하며, 이는 JAVA API 업그레이드를 위한 조치
            - 단, 가급적 사용하지 말 것
        - implements는 상속과 유사하여 형 변환이 허용됨
            - 다형성으로 이어짐
- 사칙 연산 계산기 구현 예제
    - 제한 조건
        - 문자열로 산술식을 입력 받을 것
        - 더하기, 빼기, 곱하기, 나누기만 포함할 것
        - 괄호는 포함하지 않을 것
        - 나누기의 결과는 정수 부분만 취할 것
        - 0으로 나누는 경우는 없는 것으로 할 것
            
            ![image.png](자바프로그래밍(2)/image%2029.png)
            
            ![image.png](자바프로그래밍(2)/image%2030.png)
            
            ![image.png](자바프로그래밍(2)/image%2031.png)
            
            ![image.png](자바프로그래밍(2)/image%2032.png)
            
            ![image.png](자바프로그래밍(2)/image%2033.png)
            
            ![image.png](자바프로그래밍(2)/image%2034.png)
            
            ![image.png](자바프로그래밍(2)/image%2035.png)
            
            ![image.png](자바프로그래밍(2)/image%2036.png)
            

# 제너릭의 필요성

- Generic
    - 컴파일러가 보장해주는 클래스 형 변환
    - 다수의 객체를 효과적으로 관리하는 데 유용함
- 간단한 Generic의 예
    
    ![image.png](자바프로그래밍(2)/image%2037.png)
    
    ![image.png](자바프로그래밍(2)/image%2038.png)
    
    ![image.png](자바프로그래밍(2)/image%2039.png)
    
- LinkedList 클래스의 contains() 멤버 함수
    - public boolean contains(Object o)
    - Returns true if this list contains the specified element. More formally, returns true if and only if this list contains at least one element e such that (o == null ? e == null : o,equals(e)).
    - Specufued by’
        - contains in interface Collection<E>
        - contains in interface Deque<E>
        - contains in interface List<E>
    - Overrides
        - contains in class AbstractCollection<E>
    - Parameters
        - o - element whose presence in this list is to be tested
    - Returns
        - true if this list contains the specified element
- Comparable<T> interface의 compareTo() 멤버 함수
    - int compareTo(T o)
    - Compares this object with the specified object for order. Returns a negative integer, zero, or a positive integer as this object is less than, equals to, or greater than the specified object.
    - The implementor must ensure sgn(x.compareTo(y) == -sgn(y.compareTo(x)) for all x and y. (this implies that x.compareTo(y) must throw an exception if y.compareTo(x) throws an exception.)
    - The implementor must also ensure that the relation is transitive: (x.compareTo(y)>0 && y.compareTo(z) >0) implies x.compareTo(z) >0
    - Finally, the implementor must ensure that x.compareTo(y)==0 implies that sgn(x.compareTo(z)) == sgn(y.compareTo(z)), for all z.
    - It is strongly recommended, but not strictly required that (x.compareTo(y)==0) == (x.equals(y)). Generally speaking, any class that implements the Comparable interface and violates this condition should clearly indicate this fact. The recommended language is “Note: this class has a natural ordering that is inconsistent with equals.”
    - In the foregoing description, the notation sgn(expression) designates the mathematical signum function, which is defined to return one of -1, 0, or 1 according to whether the value of expression is negative, zero of positive.
    - Parameters
        - o – the object to be compared.
    - Returns
        - a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.
    - Throws
        - NullPointerException – if the specified object is null
        - ClassCastException – if the specified object’s type prevents it from being compared to this object.
- Collection.sort()
    - public static <T extends Comparable<? super T>> void sort(List<T> list)
    - Sorts the specified list into ascending order, according to the natural ordering of its elements. All elements in the list must implement the Comparable interface. Furthermore, all elements in the list must be mutually comparable (that is, e1.compareTo(e2) must not throw a ClassCastException for any elements e1 and e2 in the list.)
    - This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
    - The specified list must be modifiable, but need not be resizable.
    - Implementation Note
        - This implementation defers to the List.sort(Comparator) method using the specified
        list and a null comparator.
    - Type Parameters
        - T – the class of the objects in the list
    - Parameters
        - list – the list to be sorted.
    - Throws
        - ClassCastException – if the list contains elements that are not mutually comparable (for example, strings and integers.)
        - UnsupportedOperationException – if the specified list’s list-iterator does not support the set operation.
        - IllegalArgumentException – (optional) if the implementation detects that the natural ordering of the list elements is found to violate the Comparable contract
    - See Also
        - List.sort(Comparator)
- Iterator 객체를 반환하는 LinkedList의 멤버 함수
    - public ListIterator<E> listIterator(int index)
    - Returns a list-iterator of the elements in this list (in proper sequence), starting at the specified position in the list. Obeys the general contract of List.listIterator(int).
    - The list-iterator is fail-fast: if the list is structurally modified at any time after the Iterator is created, in any way except through the list-iterator’s own remove or add methods, the list-iterator will throw a ConcurrentModificationException. Thus, in the face of concurrent modification, the iterator fails quickly and cleanly, rather than risking arbitrary, non-deterministic behavior at an undetermined time in the future.
    - Specified by
        - listIterator in interface List<E>
        - listIterator in class AbstractSequentialList<E>
    - Parameters
        - index – index of the first element to be returned from the list-iterator (by a call to next)
    - Returns
        - a ListIterator of the elements in this list (in proper sequence), starting at the specified position in the list
    - Throws
        - IndexOutOfBoundsException – if the index is out of range (index < 0 || index > size( ))
    - See Also
        - List.listIterator(int)
- 인터페이스 Iteraot<E>의 멤버 함수
    
    ![image.png](자바프로그래밍(2)/image%2040.png)
    
- 인터페이스 Iterable
    
    ![image.png](자바프로그래밍(2)/image%2041.png)
    

# Java에서 지원하는 제너릭 클래스 사용

- LinkedList 클래스
    
    ![image.png](자바프로그래밍(2)/image%2042.png)
    

# for-each 문법

- The for-each loop
    - Iterating over a collection is uglier than it needs to be. Consider the following method, which takes a collection of timer tasks and cancels them.
        
        ![image.png](자바프로그래밍(2)/image%2043.png)
        
    - The iterator is just clutter. Furthermore, it is an opportunity for error. The iterator variable occurs three times in each loop: that is two chances to get it wrong. The for-each construct gets rid of the clutter and the opportunity for error. Here is how the example looks with the for-each construct.
        
        ![image.png](자바프로그래밍(2)/image%2044.png)
        

# 제너릭 클래스와 함수 선언

- 제너릭 클래스와 인터페이스 선언
    - 클래스 이름 뒤에 중괄호 <, >에는 클래스를 매개 변수처럼 나열
        - 타입 매개 변수라 부르며, 개수 제한은 없음
    - 타입 매개 변수는 클래스(인터페이스 포함)여야만 함
        - 기본형을 필요로 한다면, 매칭된 클래스를 사용할 것
            
            ![image.png](자바프로그래밍(2)/image%2045.png)
            
    - 타입 매개 변수를 static 멤버 변수에 적용하면 안 됨
        - Generic Class 선언 /w static member variable
            
            ![image.png](자바프로그래밍(2)/image%2046.png)
            
        - 서로 다른 타입 매개 변수를 가진 Generic Class 생성
            
            ![image.png](자바프로그래밍(2)/image%2047.png)
            
    - 타입 매개 변수를 static 멤버 변수에 적용하면 안 됨
        
        ![image.png](자바프로그래밍(2)/image%2048.png)
        
        - dogList 객체를 기반으로 호출한 함수에서는 LinkedList<Dob>.headElement로 static 멤버 변수에 접근(1)
        - catList 객체를 기반으로 호출한 함수에서는 LinkedList<Cat>.headElement로 static 멤버 변수에 접근(2)
        - 타입 매개 변수는 컴파일 과정에만 사용(3)
    - 클래스의 타입 매개 변수를 static 멤버 함수에 적용하면 안 된다
    - 별도의 타입 매개 변수를 사용한 static 멤버 함수는 선언 가능
    - 상속 관계를 이용하여 타입 매개 변수를 제한할 수 있음
        - <T extends MyTime>은 MyTime 클래스와 자식 클래스로 제한
        - <T super MyTime>은 MyTime 클래스와 부모 클래스로 제한
        - Implements는 사용하지 않음
    - 타입 매개 변수 ?는 와일드 카드
        - <? extends T>의 경우 T 클래스와 자식 클래스면 무엇이든 가능
    - compareTo(T o)
        
        ![image.png](자바프로그래밍(2)/image%2049.png)
        
- 제너릭 클래스와 인터페이스 사용
    
    ![image.png](자바프로그래밍(2)/image%2050.png)
    
    - 클래스 이름에 타입 매개 변수까지 담은 전체를 클래스 이름으로 간주
        - 당연하다고 판단할만한 상황에서는 타입 매개 변수는 생략 가능
    - 타입 매개 변수는 컴파일 과정에서만 사용되고, 실행 코드가 생성될 때는 제거
        - 타입 매개 변수가 다른 동일한 클래스는 컴파일 단계에서는 구분되지만, 실행 과정에서는 구분할 수 없음
    - 타입 매개 변수를 사용하여 객체를 생성하면 오류 발생
        
        ![image.png](자바프로그래밍(2)/image%2051.png)
        
    - 제너릭 타입 매개 변수를 사용한 배열 생성도 컴파일 오류를 발생시킴
        
        ![image.png](자바프로그래밍(2)/image%2052.png)
        
    - 제너릭 객체 배열 생성을 금지함
        
        ![image.png](자바프로그래밍(2)/image%2053.png)
        
- 제너릭 함수 선언
    - 타입 매개 변수는 반환 타입 앞에 두어야 함
        - 제너릭 클래스의 타입 매개 변수를 사용하는 경우에는 생략
    - 타입 매개 변수는 반환 타입 혹은 매개 변수의 타입으로 사용 가능
        
        ![image.png](자바프로그래밍(2)/image%2054.png)
        
- 제너릭 함수 사용
    - <타입 매개 변수, …>의 경우, 당연할 때는 생략 가능
        
        ![image.png](자바프로그래밍(2)/image%2055.png)
        

# 제너릭 클래스 만들기 예제

- STACK이란?
    - Last In First Out
    - Push / Pop
        
        ![image.png](자바프로그래밍(2)/image%2056.png)
        
- 중위 표기법을 후위 표기법으로 변환
    
    ![image.png](자바프로그래밍(2)/image%2057.png)
    
    1. 중위 표기법에서 하나씩 읽어 들일 것
        - 더 이상 읽어 들일 문자가 없으면 STACK에 저장된 연산자를 꺼내서(Pop) LinkedList에 추가
    2. 피연산자면 LinkedList 끝에 추가하고, 1을 다시 수행
    3. 종료 괄호를 만나면
        1. STACK에 저장된 연산자를 꺼낼 것(Pop)
        2. 만약 꺼낸 연산자가 시작 괄호이면 1을 다시 수행
        3. 그렇지 않으면, 꺼낸 연산자를 LinkedList의 꼬리에 추가하고, 3-a를 다시 수행
    4. 시작 괄호는 STACK에 저장(Push)할 것
    5. 연산자(A라 가정)이면 STACK 최 상단에 위치한 연산자(B라 가정)와 비교
        1. STACK이 비어 있다면 A를 스택에 저장(Push)하고, 1을 다시 수행
        2. 만약 A의 우선 순위가 B의 우선 순위보다 높으면 연산자 A를 스택에 저장(Push)
        3. 그렇지 않으면, B를 STACK에서 꺼내서(Pop) LInkedList 끝에 추가하고, 5를 다시 수행
    
    ![image.png](자바프로그래밍(2)/image%2058.png)
    
    ![image.png](자바프로그래밍(2)/image%2059.png)
    
    ![image.png](자바프로그래밍(2)/image%2060.png)
    
    ![image.png](자바프로그래밍(2)/image%2061.png)
    
    ![image.png](자바프로그래밍(2)/image%2062.png)
    
- 후위 표기법 연산
    1. LInkedList에서 하나씩 꺼냄(pop)
        - 더 이상 가져올 것이 없을 때, STACK에는 단 하나의 값이 남는데, 이 값이 결과 값
    2. 숫자는 STACK에 저장하고, 다시 1을 수행
    3. 연산자를 만나면 STACK에서 피 연산자 두 개(무조건 두 개 이상 존재)를 꺼내서(pop) 연산하고, 그 결과 값을 STACK에 저장(push). 이후 다시 1을 수행
    
    ![image.png](자바프로그래밍(2)/image%2063.png)
    
    ![image.png](자바프로그래밍(2)/image%2064.png)
    
    ![image.png](자바프로그래밍(2)/image%2065.png)
    
    ![image.png](자바프로그래밍(2)/image%2066.png)
    
- Java API가 제공하는 LinkedList와 유사한 LinkedList 구현
    - MyGenericLinkedListControl<T> 객체
        
        ![image.png](자바프로그래밍(2)/image%2067.png)
        
- 클래스 상속 관계도
    
    ![image.png](자바프로그래밍(2)/image%2068.png)
    

# 중첩 클래스의 필요성

- 중첩 클래스(Nested Class)란?
    - 클래스 안에 멤버로 선언한 클래스
    - 함수 안에 선언한 클래스
- 관련 용어 정리
    - Enclosing Class(Outer Class, 외부 클래스)
        - 중첩 클래스를 가진 클래스
    - Top-Level Class
        - 중첩 클래스를 제외한 클래스

# 중첩 클래스의 종류와 특성

- 지역 클래스(Local Class) - 사용 목적과 특징
    - 함수 내에서만 사용할 목적으로 선언한 클래스
    - 함수 밖에서는 접근 및 사용할 수 없는 클래스
    - 생성한 객체는 참조 변수로 접근할 수 있음
    - Class String
        - public final class String
        - extends Object
        - implements Serializable, Comparable<String>, CharSequence
    - compareTo
        - public int compareTo(String anotherString)
        - Compares two strings lexicographically. The comparison is based on the Unicode value of each character in the strings. The character sequence represented by this String object is compared lexicographically to the character sequence represented by the argument string. The result is a negative integer if this String object lexicographically precedes the argument string. The result is a positive integer if this String object lexicographically follows the argument string. The result is zero if the strings are equal; compareTo returns 0 exactly when the equals(Object) method would return true
        - This is the definition of lexicographic ordering. If two strings are different, then either they have different characters at some index that is a valid index for both strings, or their lengths are different, or both. If they have different characters at one or more index positions, let k be the smallest such index; then the string whose character at position k has the smaller value, as determined by using the < operator, lexicographically precedes the other string. In this case, compareTo returns the difference of the two character values at position k in the two string -- that is, the value:
            - this.charAt(k)-anotherString.charAt(k)
        - If there is no index position at which they differ, then the shorter string lexicographically precedes the longer string. In this case, compareTo returns the difference of the lengths of the strings -- that is, the value:
            - this.charAt(k)-anotherString.charAt(k)
        - Specified by
            - compareTo in interface Comparable<String>
        - Parameters
            - anotherString - the String to be compared.
        - Returns
        - the value 0 if the argument string is equal to this string; a value less than 0 if this string is lexicographically less than the string argument; and a value greater than 0 if this string is lexicographically greater than the string argument.
    - Interface Comparator<T>
        - Type Parameters
            - T – the type of objects that may be compared by this comparator
        - All Known Implementing Classes
            - Collator, RuleBasedCollator
        - Functional Interface
            - This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.
        - @FunctionalInterface
            - public interface Comparator<T>
        
        ![image.png](자바프로그래밍(2)/image%2069.png)
        
        ![image.png](자바프로그래밍(2)/image%2070.png)
        
        ![image.png](자바프로그래밍(2)/image%2071.png)
        
        ![image.png](자바프로그래밍(2)/image%2072.png)
        
    - Collections.sort
        - public static <T> void sort(List<T> list, Comparator<? super T> c)
        - Sorts the specified list according to the order induced by the specified comparator. All elements in the list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list).
        - This sort is guaranteed to be stable: equal elements will not be reordered as a result of the sort.
        - The specified list must be modifiable, but need not be resizable.
        - Implementation Note
            - This implementation defers to the List.sort(Comparator) method using the specified list and comparator.
        - Type Parameters
            - T - the class of the objects in the list
        - Type Parameters
            - list - the list to be sorted.
            - c - the comparator to determine the order of the list. A null value indicates that the elements' natural ordering should be used.
        - Throws
            - ClassCastException - if the list contains elements that are not mutually comparable using the specified comparator.
            - UnsupportedOperationException - if the specified list's list-iterator does not support the set operation.
            - IllegalArgumentException - (optional) if the comparator is found to violate the Comparator contract
        - See Also
            - List.sort(Comparator)
    - List.sort
        - default void sort(Comparator<? super E> c)
        - Sorts this list according to the order induced by the specified Comparator.
        - All elements in this list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list).
        - If the specified comparator is null then all elements in this list must implement the Comparable interface and the elements' natural ordering should be used.
        - This list must be modifiable, but need not be resizable.
        - Implementation Requirements
            - The default implementation obtains an array containing all elements in this list, sorts the array, and iterates over this list resetting each element from the corresponding position in the array. (This avoids the n2 log(n) performance that would result from attempting to sort a linked list in place.)
        - Implementation Note
            - This implementation is a stable, adaptive, iterative mergesort that requires far fewer than n lg(n) comparisons when the input array is partially sorted, while offering the performance of a traditional mergesort when the input array is randomly ordered. If the input array is nearly sorted, the implementation requires approximately n comparisons. Temporary storage requirements vary from a small constant for nearly sorted input arrays to n/2 object references for randomly ordered input arrays.
            - The implementation takes equal advantage of ascending and descending order in its input array, and can take advantage of ascending and descending order in different parts of the same input array. It is well-suited to merging two or more sorted arrays: simply concatenate the arrays and sort the resulting array.
            - The implementation was adapted from Tim Peters's list sort for Python (TimSort). It uses techniques from Peter McIlroy's "Optimistic Sorting and Information Theoretic Complexity", in Proceedings of the Fourth Annual ACM-SIAM Symposium on Discrete Algorithms, pp 467-474, January 1993.
        - Parameters
            - c - the Comparator used to compare list elements. A null value indicates that the elements' natural ordering should be used
        - Throws
            - ClassCastException - if the list contains elements that are not mutually comparable using the specified comparator
            - UnsupportedOperationException - if the list's list-iterator does not support the set operation
            - IllegalArgumentException - (optional) if the comparator is found to violate the Comparator contract
            - Since 1.8
- 지역 클래스(Local Class) - 문법 정리
    - 접근 지정자를 적용하지 않음
        - 사용 범위를 함수 안으로 제한하기 때문에 불필요
    - 지역 변수를 사용한다면, 해당 지역 변수는 컴파일러가 자동으로final로 지정됨
        - 지역 클래스의 객체는 멤버 함수가 종료 후에도 유지 참조하는 경우가 있음
        - 반면 지역 변수는 멤버 함수 종료와 함께 사라지기 때문에 final로 보전함
        - 그래야 비 정상적인 메모리 접근을 피할 수 있음
    - 외부 클래스 멤버를 접근할 수 있음
        - 만약 함수가 static이면 static 멤버만 접근이 가능
        - 함수가 non-static이면 함수를 호출할 때 기반이 된 객체의 non-static 멤버를 접근할 수 있음
    - static 클래스로 선언할 수 없음
        - 클래스의 멤버가 아님
        - non-static이어서 외부 클래스의 non-static 멤버를 접근할 수 있음
- 무명 클래스(Anonymous Class)
    - 사용 목적
        - 클래스의 이름을 만들지 않고 객체를 만들 수 있음
        - 재사용할 클래스가 아닌 경우 사용
        - Functional Interface를 implements 하는 경우 많이 사용
            - 추상 멤버 함수가 하나 뿐인 Interface를 Functional Interface라 함
    - 무명 클래스 선언
        - 상위_클래스_이름 변수_이름 = new 상위_클래스_이름()
        - {
             // 무명 클래스 선언 블록
        };
- 람다식
    - 사용 목적
        - Functional Interface를 implements 하는 무명 클래스의 간략화
        - 함수를 매개 변수로 사용함
    - 문법 정리
        - 선언
            - (매개변수 목록) → { // 오버라이딩 멤버 함수 본체 }
        - 람다식의 형 변환
            - Object obj = (Object)(Functional Interface 이름) 람다식;
    - 람다식 만들기
        - 매개 변수의 타입 선언부를 생략할 수 있음
            - 추론이 가능한 경우가 많기 때문
            - 타입을 생략할 때는 모든 매개 변수의 타입을 생략해야 함
        - 매개 변수가 하나인 경우, 매개 변수 목록의 소괄호는 생략 가능 (단, 매개 변수 타입도 생략된 상태여야 함)
        - 함수 본체가 하나의 문장으로 구성된다면, 중괄호 {}와 마침표 ; 도 생략할 수 있음
        - 하나뿐인 문장이 return 문이면, return 키워드 생략도 가능
        - 단, 하나의 문장이 멤버 함수 호출 등이면 다음의 규칙에 따라 간략화 가능
            
            ![image.png](자바프로그래밍(2)/image%2073.png)
            
- 멤버가 된 클래스- 클래스 내부에서만 사용할 목적인 중첩 클래스
    - 클래스의 멤버로 선언된 클래스
        
        ![image.png](자바프로그래밍(2)/image%2074.png)
        
        ![image.png](자바프로그래밍(2)/image%2075.png)
        
        ![image.png](자바프로그래밍(2)/image%2076.png)
        
        - 이 클래스의 객체는 LinkedList 관리 객체가 관리하는 노드 관련 정보를 필요로 함
        - Iterator 클래스를 Top-Level class로 선언하고 노드 객체를 다루려면 LinkedList 관리 클래스에 (최소한) default 접근 지정자를 가진 멤버 함수를 선언해야 함
            - 동일 패키지 내의 Top-Level Class도 접근할 수 있게 되나, 은닉성에서 멀어짐
        - 내부 클래스를 사용하면 외부 클래스와 private 멤버를 상호 접근할 수 있음
            - 그렇지만 멤버 변수를 직접 접근하는 방법은 권장하지 않음
            - private 멤버 함수를 통해 접근할 것
            - 규칙은 아니지만, 멤버로 선언하는 내부 클래스는 가급적 private로 선언하기를 권장함
- 멤버가 된 클래스 - Top Level 클래스도 사용 가능한 중첩 클래스
    - 상속 관계가 아니지만, 상호 멤버의 자유로운 접근이 필요한 경우
    - 접근이 자유로운 만큼 설계 시 주의 필요
    - Interface Map.Entry<K,V>
        - All Known Implementing Classes
            - AbstractMap, SimpleEntry, AbstractMap.SimpleImmutableEntry
        - Enclosing interface
            - Map<K,V>
        - public static interface Map.Entry<K,V>
            - A map entry (key-value pair). The Map.entrySet method returns a collectionview of the map, whose elements are of this class. The only way to obtain a reference to a map entry is from the iterator of this collection-view. These Map.Entry objects are valid only for the duration of the iteration; more formally, the behavior of a map entry is undefined if the backing map has been modified after the entry was returned by the iterator, except through the setValue operation on the map entry.
    - binarySearch
        
        ![image.png](자바프로그래밍(2)/image%2077.png)
        
        - public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key)
        - Searches the specified list for the specified object using the binary search algorithm. The list must be sorted into ascending order according to the natural ordering of its elements (as by the sort(List) method) prior to making this call. If it is not sorted, the results are undefined. If the list contains multiple elements equal to the specified object, there is no guarantee which one will be found.
        - This method runs in log(n) time for a "random access" list (which provides near-constant-time positional access). If the specified list does not implement the RandomAccess interface and is large, this method will do an iterator-based binary search that performs O(n) link traversals and O(log n) element comparisons.
        - Type Parameters
            - T - the class of the objects in the list
        - Parameters
            - list - the list to be searched.
            - key - the key to be searched for.
        - Returns
            - the index of the search key, if it is contained in the list; otherwise, (-(insertion point) - 1). The insertion point is defined as the point at which the key would be inserted into the list: the index of the first element greater than the key, or list.size() if all elements in the list are less than the specified key. Note that this guarantees that the return value will be >= 0 if and only if the key is found.
        - Throws
            - ClassCastException - if the list contains elements that are not mutually comparable (for example, strings and integers), or the search key is not mutually comparable with the elements of the list.
    - ArrayList의 sort
        - public void sort(Comparator<? super E> c)
        - Description copied from interface: List
            - Sorts this list according to the order induced by the specified Comparator.
            - All elements in this list must be mutually comparable using the specified comparator (that is, c.compare(e1, e2) must not throw a ClassCastException for any elements e1 and e2 in the list).
            - If the specified comparator is null then all elements in this list must implement the Comparable interface and the elements' natural ordering should be used.
            - This list must be modifiable, but need not be resizable.
        - Specified by
            - sort in interface List<E>
        - Parameters
            - c - the Comparator used to compare list elements. A null value indicates that the elements' natural ordering should be used
    - ArrayList의 forEach
        - public void forEach(Consumer<? super E> action)
        - Description copied from interface: Iterable
            - Performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Unless otherwise specified by the implementing class, actions are performed in the order of iteration (if an iteration order is specified). Exceptions thrown by the action are relayed to the caller.
        - Specified by
            - forEach in interface Iterable<E>
        - Parameters
            - action - The action to be performed for each element
    - Interface Consumer<T>
        - @FunctionalInterface
            - public interface Consumer<T>
            - Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects.
            - This is a functional interface whose functional method is accept(Object).
    - Interface Consumer<T>의 accept
        - void accept(T t)
        - Performs this operation on the given argument.
        - Parameters
            - t - the input argument

# Java SWING package의 구성

- Java SWING이란?
    - AWT에서 SWING로
    - AWT가 네이티브 플랫폼에 의존한 반면, SWING은 순수 Java로 구현
        - 경량 / 플랫폼 독립성
    - 더블 버퍼링 자체 지원
    - 그래픽 요소 추가
- Java SWING package
    
    ![image.png](자바프로그래밍(2)/image%2078.png)
    
    - Container
        - 다른 Component(Container 포함)를 담을 수 있음
    - Component
        - 다른 Component를 담을 수 없음
        - Container의 상위 클래스
        - 크기 / 모양 / 위치 / 색 / 폰트
        - 그리기 / 이동 / 삭제 / 이벤트 처리
    - 최상위 Container(Top Level Container)
        - JFrame / JDialog / JApplet
            
            ![image.png](자바프로그래밍(2)/image%2079.png)
            

# Event 관리

- Event의 발생과 전달
    
    ![image.png](자바프로그래밍(2)/image%2080.png)
    
- Event Class
    
    ![image.png](자바프로그래밍(2)/image%2081.png)
    
    ![image.png](자바프로그래밍(2)/image%2082.png)
    
    ![image.png](자바프로그래밍(2)/image%2083.png)
    
- Event Listener Interface
    
    ![image.png](자바프로그래밍(2)/image%2084.png)
    
    ![image.png](자바프로그래밍(2)/image%2085.png)
    
    ![image.png](자바프로그래밍(2)/image%2086.png)
    
    ![image.png](자바프로그래밍(2)/image%2087.png)
    
- Event Adapter Class
    
    ![image.png](자바프로그래밍(2)/image%2088.png)
    

# SWING package 활용

- Layout manager
    
    ![image.png](자바프로그래밍(2)/image%2089.png)
    
- SWING Component
    
    ![image.png](자바프로그래밍(2)/image%2090.png)
    
- Graphics Class
    - 이미지 파일 사용
    - 다양한 그리기 지원

# 멀티 태스킹의 개념

- 멀티 태스킹의 개념
    - 다중 작업
    - 종류
        - Multi Processing
        - Multi Threading
    
    ![image.png](자바프로그래밍(2)/image%2091.png)
    
    ![image.png](자바프로그래밍(2)/image%2092.png)
    

# 멀티 스레딩의 개념

- 멀티 스레딩의 개념
    
    ![image.png](자바프로그래밍(2)/image%2093.png)
    

# Java에서의 멀티 스레딩 문법과 동작 원리

- 개요
    
    ```java
    class 클래스_이름 implements Runnable
    {
    	public void run( )
    	{
    		// thread가 수행할 작업
    	}
    }
    ```
    
    - Interface Runnable
        - All Known Subinterfaces
            - RunnableFuture<V>, RunnableScheduledFuture<V>
        - All Known Implementing Classes
            - AsyncBoxView.ChildState, ForkJoinWorkerThread, FutureTask, RenderableImageProducer, SwingWorker, Thread, TimerTask
        - Functional Interface
            - This is a functional interface and can therefore be used as the assignment target for a lambda expression or method reference.
        - @FunctionalInterface
            - public interface Runnable
            - The Runnable interface should be implemented by any class whose instances are intended to be executed by a thread. The class must define a method of no arguments called run.
            - This interface is designed to provide a common protocol for objects that wish to execute code while they are active. For example, Runnable is implemented by class Thread. Being active simply means that a thread has been started and has not yet been stopped.
            - In addition, Runnable provides the means for a class to be active while not subclassing Thread. A class that implements Runnable can run without subclassing Thread by instantiating a Thread instance and passing itself in as the target. In most cases, the Runnable interface should be used if you are only planning to override the run() method and no other Thread methods. This is important because classes should not be subclassed unless the programmer intends on modifying or enhancing the fundamental behavior of the class.
        - Sinces JDK1.0
        - See Also
            - Thread, Callable
        
        ![image.png](자바프로그래밍(2)/image%2094.png)
        
        - runnable 객체 생성
            
            ```java
            클래스_이름 객체_이름 = new 클래스_이름( );
            ```
            
        - thread 객체 생성
            
            ```java
            Thread thread = new Thread(객체_이름);
            ```
            
        - thread 등록 및 수행
            
            ```java
            thread.start( )
            ```
            
- Thread 관리 Method
    - sleep
        - public static void sleep(long millis) throws InterruptedException
        - Causes the currently executing thread to sleep (temporarily cease execution) for the specified number of milliseconds, subject to the precision and accuracy of system timers and schedulers. The thread does not lose ownership of any monitors.
        - Parameters
            - millis - the length of time to sleep in milliseconds
        - Throws
            - IllegalArgumentException - if the value of millis is negative
            - InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is
            thrown.
    - join
        - public final void join() throws InterruptedException
        - Waits for this thread to die.
        - An invocation of this method behaves in exactly the same way as the invocation join(0)
        - Throws
            - InterruptedException - if any thread has interrupted the current thread. The interrupted status of the current thread is cleared when this exception is
            thrown.
- Therad의 데이터 공유
    - Thread는 메모리 영역을 공유함
    - 동시에 발생한 정보 수정 요구는 어떻게 처리해야 하는가?
    - 동기화의 필요성 대두
        
        ```java
        synchronized(obj)
        {
        	// 동기화 구간
        }
        ```
        
        ```java
        synchronized 멤버 함수_이름(매개변수_리스트)
        {
        	// 멤버 함수 BODY
        }
        ```
        
    - 데이터의 소유권을 내려 놓아야 하는 상황
        - wait
            - public final void wait() throws InterruptedException
            - Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).
            - The current thread must own this object's monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object's
            monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can reobtain ownership of the monitor and resumes execution.
            - As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:
                
                ```java
                synchronized (obj) {
                	while (<condition does not hold>)
                		obj.wait();
                		... // Perform action appropriate to condition
                }
                ```
                
            - This method should only be called by a thread that is the owner of this object's monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.
            - Throws
                - if the current thread is not the owner of the object's monitor.
                - InterruptedException - if any thread interrupted the current thread before or while the current thread was waiting for a notification. The interrupted status of the current thread is cleared when this exception is thrown.
        - notify
            - public final void notify()
            - Wakes up a single thread that is waiting on this object's monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object's monitor by calling one of the wait methods.
            - The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object
            - This method should only be called by a thread that is the owner of this object's monitor. A thread becomes the owner of the object's monitor in one of three ways:
                - By executing a synchronized instance method of that object.
                - By executing the body of a synchronized statement that synchronizes on the object.
                - For objects of type Class, by executing a synchronized static method of that class.
                - Only one thread at a time can own an object's monitor.
                - Throws
                    - IllegalMonitorStateException - if the current thread is not the owner of this object's monitor.
    - 안전한 Thread 종료
        - 갑작스러운 종료는 데이터 소유권 등에 문제를 야기할 수 있음
        - 종료 상황을 인지하고, 마무리를 하고 종료할 수 있도록 함

# 네트워크 프로그램

- Socket Program: TCP/IP
    - 주소
        - 통신 상대 지정
        - IP 주소와 Domain Name
    - 포트 번호
        - 하나의 시스템에 다수의 통신 프로그램 동작 허용
        - Protocol의 구분에도 사용됨
- Client - Server Programming
    
    ![image.png](자바프로그래밍(2)/image%2095.png)
    

# 데이터의 동기화를 보장하는 프로그램 구현

- 데이터의 동기화를 보장하는 프로그램 구현
    - 자원을 공유하는 상황의 제어
    - 다수의 접속자들이 있는 통신 프로그램에서 흔히 발생
    - 하나의 규약에서 다수의 포트를 사용하는 경우도 있음