# C언어 1 (2)

# 함수의 개념

- 개요
    - 함수의 필요성
        
        ![image.png](C언어1(2)/image.png)
        
    - 함수(Function)
        
        ![image.png](C언어1(2)/image%201.png)
        
    - 함수의 특징
        - 함수는 프로그램을 구성하는 기본적인 구성 요소
        - 함수는 서로 구별되는 이름을 가짐
        - 함수는 특정한 작업을 수행함
        - 함수는 입력을 받을 수 있고 결과를 반환할 수 있음
        - 함수는 이름으로 호출되며 입력과 출력을 가짐
        - 함수는 내부 구현 방법을 모르더라도 사용할 수 있음
- 모듈화(Module)
    - 코드의 분할
    - 코드의 계층화
    - 논리적으로 같은 등급의 소스파일은 계속해서 분할
    - 어떠한 소스파일/함수에서 일어나는 일의 책임을 그 소스파일과 그 함수가 지도록 함
    - 전체 프로그램을 많은 함수들로 분리하여 작성
    - 모듈화의 필요성
        
        ![image.png](C언어1(2)/image%202.png)
        
    - 함수의 장점
        - 소스 코드의 중복성 최소화
            - 소스 코드의 양 축소
            - 프로그램 간결성 증가
        - 함수의 재사용성
        - 복잡한 문제의 단순화(모듈화)
        - 각 함수는 특징적인 한 가지 작업(기능)만 담당
        - 소스코드의 가독성 증가
- 함수의 종류
    - 사용자 정의 함수(user-defined function)
        - 프로그래머가 직접 작성
    - 라이브러리 함수(library function)
        - 컴파일러에서 지원되는 함수
        - printf(), scanf() 등
        - 프로그래머가 필요로 하는 다양한 기능 제공
        - 프로그래머는 보다 쉽게 프로그래밍 가능
        - 개발 기간 단축
        - 수학적인 계산, 문자열 조작, 입/출력 등 수행

# 함수 정의 및 구조

- 함수의 정의
    - 함수를 정의하는 목적 : 함수를 사용하기 위해
    - 함수의 정의 : 함수가 무엇을 할지를 결정하는 것
    - 함수의 호출 : 함수를 사용하는 것, 함수의 이름을 써주는 것
    
    ![image.png](C언어1(2)/image%203.png)
    
- 함수의 구조
    - 함수의 구조
        - 함수 헤더 : 반환형, 함수형, 매개변수(인자, 파라미터)
        - 함수 몸체 : 작업에 필요한 문장들
            
            ![image.png](C언어1(2)/image%204.png)
            
    - 반환형(Return Type)
        - 함수가 처리를 종료한 후에 호출한 곳으로 반환하는 데이터의 유형
        - 반환형 생략가능 : int형으로 가정됨
        - 종류
            - void : 반환 겂이 없음
            - int, float, double, char 등
    - 함수명
        - 함수의 이름
        - 식별자 규칙을 따름
        - 하나의 프로그램 안에 동일한 함수명이 2개 이상 존재할 수 없음
        - 함수의 목적을 설명하는 동사 또는 동사 + 명사
        - 좋은 예
            - square() : 정수를 제곱하는 함수
            - avg() : 평균을 구하는 함수
            - setValue() : 값을 설정하는 함수
            - get_name() : 이름을 반환하는 함수
    - 매개변수
        - 인자(argument), 파라미터(parameter)
        - 함수의 입력부분
        - 함수를 호출하면서 특정한 값을 전달할 때 사용함
        - 종류
            - 실매개변수 : 호출하는 함수(caller)의 매개변수
            - 형식매개변수 : 호출된 함수(callee)의 매개변수
    - 함수 몸체
        - 중괄호 {} 로 둘러싸인 블록
        - 실제로 실행되는 명령어들의 모임
            - 반환 값(return value)
                - 함수가 호출된 곳으로 반환하는 작업의 결과값
                - 반드시 하나만 가능
            - return 명령어
                - 함수가 종료되면서 값을 반환하는 명령어
                - 반환하는 값의 자료형과 반환형이 일치해야 함

# 매개변수 전달방식의 이해

- 매개변수
    - 매개변수
        - 함수를 호출할 때 호출되는 함수로 정보를 전달하는 수단
    - 구분
        - 실 매개변수(actual parameter) : 함수 호출 시의 매개변수
        - 형식 매개변수(formal parameter) : 호출될 때의 매개변수
    - 실 매개변수와 형식 매개변수
        - 개수와 자료형이 일치해야 함
        - 변수 이름은 같거나 달라도 됨
    - 매개변수 전달 방식
        - 값에 의한 호출(call by value)
            - 실 매개변수의 값을 복사하여 형식 매개변수에 전달
        - 참조에 의한 호출(call by reference)
            - 실 매개변수와 형식 매개변수가 동일한 기억 공간을 사용
- 값에 의한 호출(call by value)
    - 값에 의한 호출
        - C언어에서 기본적으로 사용하는 매개변수 전달방식
        - 실 매개변수의 값만 복사하여 형식 매개변수에 전달
        - 형식 매개변수
            - 실 매개변수의 값을 저장하기 위한 별도의 기억 공간 필요
            - 값 변경 시, 실 매개변수와 무관
        - 호출된 함수
            - 형식 매개변수만 조작 가능
            - 실 매개변수에 접근 불가능
        - 실 매개변수와 형식 매개변수가 서로 다른 변수 취급
        - C 언어에서 기본적으로 사용하는 매개변수 전달방식
        - 실 매개변수의 값만 복사하여 형식 매개변수에 전달
        - 일반적인 사용 예
            
            ![image.png](C언어1(2)/image%205.png)
            
        - 문제가 되는 사용 예
            
            ![image.png](C언어1(2)/image%206.png)
            
- 참조에 의한 호출(call by reference)
    - 참조(reference) : 기억공간의 주소
    - 참조에 의한 호출
        - 실 매개변수와 형식 매개변수가 동일한 기억 공간을 사용하는 방법
        - 실 매개변수와 형식 매개변수를 같은 변수 취급
        - 형식 매개변수의 값이 변경되면 실 매개변수도 변경됨
        - C언어에서 지원하지 않음
        - 포인터 사용
    - 포인터 사용 예
        
        ![image.png](C언어1(2)/image%207.png)
        

# 함수 원형

- 함수의 사용
    - 함수를 사용할 때
        - 함수명을 써주는 것 = 함수 호출
        - 함수 호출되기 전까지는 전혀 실행되지 않음
            
            ![image.png](C언어1(2)/image%208.png)
            
            ![image.png](C언어1(2)/image%209.png)
            
            ![image.png](C언어1(2)/image%2010.png)
            
            ![image.png](C언어1(2)/image%2011.png)
            
- 함수 원형
    - 함수 원형(function prototyping)
        - 컴파일러에게 함수에 대하여 미리 알리는 것
            - 함수명, 매개변수의 개수와 자료형, 함수의 반환형
        - 함수 헤더에 세미콜론(;)만 추가
        - 매개변수의 이름은 생략 가능
            
            ![image.png](C언어1(2)/image%2012.png)
            
    - 함수 원형의 사용 예
        
        ![image.png](C언어1(2)/image%2013.png)
        
- 함수 선언
    - 함수 사용 순서
        
        ![image.png](C언어1(2)/image%2014.png)
        
    - 함수 선언의 필요성
        - 프로그램에 대한 전체적인 구조 파악 용이
        - 오류 발생 시 수정 용이

# 함수 호출 및 반환

- 함수 호출
    - 함수 호출(function call)
        - 함수 안의 문장들은 호출되기 전까지는 전혀 실행되지 않음
        - 함수를 호출하면
            - 현재 실행하고 있는 코드는 잠시 중단되고
            - 호출된 함수(callee)로 이동하여
                - 함수 몸체 안의 문장들이 순차적으로 실행되고
                - 함수의 실행이 끝나면
            - 호출한 함수(caller)의 해당 위치로 되돌아가서
                - 잠시 중단되었던 코드가 다시 실행됨
- 함수 반환
    - return 명령의 기능
        - 함수의 종료
        - 반환값(return value)의 전달
    - 반환값(return value)
        - 함수가 호출한 곳으로 반환하는 작업의 결과값
        - 오직 하나만 가능
    - 반환형(return type)
        - void, char, int, long, double 등
        - 생략하면 int형을 가정
        - 반환값은 반환형과 일치해야 함
- 함수 동작 과정
    - 함수 호출
    - 매개변수 전달
    - 함수 실행
    - 반환값 전달
        
        ![image.png](C언어1(2)/image%2015.png)
        

# 표준 라이브러리 함수

- 개요
    - 표준 라이브러리 함수
        - 컴파일러에서 제공하는 함수
        - 라이브러리 지원이 잘 되어 있음
        - C 언어가 많이 사용되고 강력한 이유
        - 라이브러리 함수 사용하기
            - 함수 원형 포함
            - 헤더 파일을 포함
    - 표준 라이브러리 함수의 종류
        - 표준 입출력
        - 수학 연산
        - 문자열 처리
        - 시간 처리
        - 오류  처리
        - 데이터 검색과 정렬
- 난수 함수
    - 난수(random number)
        - 규칙성이 없이 임의로 생성되는 수
        - 암호학이나 시뮬레이션, 게임 등에서 필수적
    - 의사 난수(pseudo random number)
        - 초기값에 따라서 나오는 순서가 결정되어 있는 난수
    - 시드(seed)
        - 씨앗
        - 난수 생성시에 씨앗값
        - 시드값이 달라지면 이후 생성되는 모든 난수값이 달라짐
    - time(NULL)
        - 1970년 1월 1일 0시부터 현재까지 경과된 시간을 초단위로 반환하는 함수
        - time.h에 정의되어 있음
        - time_t 형 : 시간을 나타내는 산술형의 typedef 명
        - 원형
            
            ![image.png](C언어1(2)/image%2016.png)
            
    - srand()
        - 난수발생기의 시드값을 설정하는 함수
        - 난수를 초기화 시켜줌
        - stdlib.h에 정의되어 있음
        - 원형
            
            ![image.png](C언어1(2)/image%2017.png)
            
        - 프로그래밍이 실행될 때마다 다르도록 하기 위한 예
            
            ![image.png](C언어1(2)/image%2018.png)
            
    - rand()
        - 의사 난수 생성 함수(난수 발생 순서 일정함)
        - stdlib.h에 정의되어 있음
        - 0 ~ RAND_MAX 까지의 정수 생성
        - RAND_MAX : rand()가 생성할 수 있는 최대 난수(0x7fff=32767)
        - srand()로 난수 초기화가 가능
        - 원형
            
            ![image.png](C언어1(2)/image%2019.png)
            
        - 사용 예
            - 생성되는 수의 범위를 1 ~ 45번 사이로 제한하는 경우
                
                ![image.png](C언어1(2)/image%2020.png)
                
- 수학 함수
    - math.h에 정의되어 있음
    - 일반적으로 double 형의 매개 변수와 반환 값을 가짐
    - 예
        
        ![image.png](C언어1(2)/image%2021.png)
        
    - abs() 함수
        - 절대값 함수
            
            ![image.png](C언어1(2)/image%2022.png)
            
    - pow() 함수
        - 제곱 함수
            
            ![image.png](C언어1(2)/image%2023.png)
            
    - sqrt()
        - 제곱근 함수
            
            ![image.png](C언어1(2)/image%2024.png)
            
    - 함수를 사용하는 이유
        - 소스 코드의 중복성을 없애줌
            - 프로그램 간결화
        - 한 번 제작된 함수는 재사용 가능
        - 복잡한 문제를 단순한 부분으로 분해 가능(모듈화)
            - 개발 과정 쉬워짐
            - 보다 체계적이 됨
            - 유지보수 쉬워짐

# 기억 클래스의 종류

- 개요
    - 기억 클래스(Storage Class)
        - 기억장치에 어떤 방법으로 데이터를 저장할 것인지를 결정
        - 데이터를 어디에(레지스터, 주기억장치) 저장할 것인지 결정
        - 변수를 주기억장치의 어느 위치에 배치할 것인지 결정
        - 주소 할당 밥법 결정
    - 변수에 대한 주소 할당 영역
        - CPU의 레지스터
        - 주기억장치의 일반적인 메모리
        - 주기억장치의 스택
        - 해당 변수에 대한
            - 유효 범위
            - 유효 기간
    - 자료형(Data Type)
        - 변수의 성격과 크기를 지정
    - 기억 클래스(Storage Class)
        - 변수의 유효 범위(scope)와 유효 기간(life time) 결정
    - 기억 클래스 지정자(Storage Class Specifier)
        - C언어에서 제공하는 기억 클래스의 종류와 명령어
            - 자동 변수 auto
            - 레지스터 변수 register
            - 정적 변수 static
            - 외부 변수 extern
- 기억 클래스의 종류
    - 기억 클래스
        - 변수의 유효 범위와 유효 기간을 결정
    - 변수의 유효 기간
        - 메모리의 할당 방식에 따라 달라짐
    - 변수의 유효 기간에 따라
        - 정적 할당(Static Allocation)
            - 프로그램 시작부터 종료 때까지
            - 정적 변수와 외부 변수
        - 동적 할당(Dynamic Allocation)
            - 변수들이 선언된 블록이 끝날 때까지
            - 자동 변수와 레지스터 변수
    - 유효 기간에 따른 변수의 종류
        
        ![image.png](C언어1(2)/image%2025.png)
        
    - 유효 범위에 따른 변수의 종류
        - 변수가 선언된 위치에 따라 구분됨
    - 변수가 선언된 위치에 따른 변수의 종류
        - 지역 변수(Local Variable)
            - 함수 또는 블록 내부에서 선언된 변수
            - 해당 함수/블록 안에서만 사용 가능
        - 전역 변수(Global Variable)
            - 함수 또는 블록 밖에서 선언된 변수
            - 프로그램 전체에서 사용 가능
    - 변수의 유효 범위에 따른 변수의 종류
        
        ![image.png](C언어1(2)/image%2026.png)
        
- 기억 클래스의 정리
    - 기억 클래스의 종류
        - 유효 범위와 유효 기간으로 구분
        
        ![image.png](C언어1(2)/image%2027.png)
        

# 지역 변수

- 변수의 속성
    - 변수의 속성
        - 기본 속성 + 범위, 생존시간, 연결
            
            ![image.png](C언어1(2)/image%2028.png)
            
- 지역 변수의 특징
    - 지역 변수(Local Variable)
        - 블록 안에서 선언되는 변수
        - 변수가 선언된 블록 안에서만 사용 가능
    - 지역 변수의 선언 위치
        - 사용하기 전에 선언하면 됨
    - 이름이 같은 지역 변수
        - 다른 블록 안에 동일한 이름의 변수 허용
    - 지역 변수의 저장
        - 변수 선언 시, 스택(Stack)에 저장
        - 선언된 블록이 종료되면
            - 메모리는 자동 반환됨
            - 변수는 자동 사라짐
    - 지역 변수의 초기값
        - 자동 초기화 되지 않음
        - 쓰레기 값(Garbage Value)
    - 함수의 매개 변수
        - 함수의 매개 변수도 일종의 지역 변수
        - 함수 호출 시 전달되는 인수 값으로 초기화 됨
        - 함수가 시작되면 생성되고 함수가 종료되면 소멸됨
- 지역 변수의 사용
    
    ![image.png](C언어1(2)/image%2029.png)
    
    ![image.png](C언어1(2)/image%2030.png)
    

# 전역 변수

- 전역 변수의 특징
    - 전역 변수
        - 함수 외부에서 선언되는 변수
        - 프로그램 전체에서 사용가능
    - 전역 변수의 초기값
        - 컴파일러에 의해 0으로 자동 초기화 됨
    - 전역 변수의 생존 기간
        - 프로그램 시작과 동시에 생성됨
        - 프로그램이 종료되기 전까지 메모리에 존재함
    - 스파게티 코드(Spaghetti code)
        - 전역 변수들로 인하여 코드가 꼬이는 현상
        - 마치 스파게티처럼 복잡하게 꼬여 있다는 의미
    - 전역 변수 사용 기준
        - 거의 모든 함수에서 사용하는 공통적인 데이터는 전역 변수 사용
        - 일부의 함수들만 사용하는 데이터는 함수의 인수로 전달
- 전역 변수의 사용
    
    ![image.png](C언어1(2)/image%2031.png)
    
    ![image.png](C언어1(2)/image%2032.png)
    
- 지역 변수와 전역 변수
    - 변수의 이름이 같은 경우
        - 전역 변수와 지역 변수의 이름이 같은 경우
        - 지역 변수가 전역 변수보다 우선됨
        - 지역 변수가 전역 변수를 가린다고 함
            
            ![image.png](C언어1(2)/image%2033.png)
            

# 함수의 생존 시간

- auto
    - 변수의 유효 범위(Scope)
        - 변수를 사용할 수 있는 범위
    - 변수의 생존 시간(Lifetime)
        - 변수가 생존하는 시간
    - 생존 시간에 따른 변수 분류
        - 정적 할당(Static Allocation)
            - 프로그램이 종료되면 저장 공간이 반납되는 방법
        - 자동 할당(Automatic Allocation)
            - 블록이 종료되면 저장 공간이 반납되는 방법
    - 변수 선언 위치
        - 전역 변수
            - 정적 할당
        - 지역 변수
            - 기본적으로 자동 할당
            - 저장 유형 지정자로 정적 할당 가능
    - 저장 유형 지정자(Storage Class Specifier)
        - 저장 유형을 지정하는 수식어
        - 종류 : auto, register, static, extern
    - 변수 선언 시 저장 유형을 지정하는 수식어를 붙일 수 있음
        - 변수나 함수 선언 시, 어디에 저장되는지를 지정함
        - 생략 시, 변수가 선언되는 위치에 따라 변수의 저장 유형이 자동 결정됨
    - 자동 변수(Automatic Variable)
        - auto 지정자(생략 가능)
        - 함수나 블록 내에 선언되는 지역 변수
        - 선언 시 생성되고 블록이 종료되면 자동 소멸됨
        - 메모리 효율적 사용
        - 프로그램 최적화 시에 가장 빠르게 동작할 수 있는 메모리에 저장
    - 사용 방법
        - auto 자료형 변수이름;
            
            ![image.png](C언어1(2)/image%2034.png)
            
    - 자동 변수의 유효 범위
        
        ![image.png](C언어1(2)/image%2035.png)
        
        ![image.png](C언어1(2)/image%2036.png)
        
- static
    - 정적 변수(Static Variable)
        - static 지정자
        - 블록 내에서만 사용되며, 프로그램 종료 시 메모리 반납
        - 일반적인 메모리에 저장
        - 자동 초기화 = 0
        - 초기화는 딱 1회만 수행
        - 선언 위치에 따라 : 유효기간 같고 유효 범위 다름
            - 내부 정적 변수(Internal static variable)
            - 외부 정적 변수(External static variable)
    
    ![image.png](C언어1(2)/image%2037.png)
    
- register
    - 레지스터 변수(Register Variable)
        - register 지정자
        - 블록 내에서만 사용되며, 블록이 끝나면 반납
        - 지역변수로만 사용 가능
        - CPU의 레지스터에 저장
            - 처리 속도가 빠르기 때문에 반복문의 반복 횟수 카운트하는 변수 사용 등
    - 레지스터 변수(Register Variable) 사용시 제약사항
        - 정수형과 문자형으로만 사용 가능
        - 변수의 개수에 제한 있음(일반적으로 3개) : 개수 초과 시 나머지 변수들은 자동 변수 할당
        - 주소 연산자(&) 사용 불가
- extern
    - 외부 변수(External Variable)
        - 함수 밖에서 선언된 변수
        - 프로그램 종료될 때 반환됨
        - 파일 외부에서도 사용 가능
        - 파일 간의 데이터 공유 가능
        - 프로그램이 복잡해 질 수 있음
        - 외부 정적 변수 : 파일 내에서만 사용 가능
        - extern
            - 정의된 외부 변수를 참조하겠다는 의미에 불과
            - 외부 변수를 초기화할 수 없음
    
    ![image.png](C언어1(2)/image%2038.png)
    

# 재귀 함수의 개념

- 재귀 함수
    - 재귀 함수, 순환 함수(Recursive Function)
        - 자기 자신을 호출하는 함수
        - 탈출 조건이 반드시 필요함
        - 프로그램이 간결해 지는 장점이 있음
        - 일정한 규칙을 가지고 반복적으로 처리되는 작업에 적합
        - 대표적인 예
            - 팩토리얼(Factorial)문제, 하노이탑 문제
    - 순환
        - 함수 수행 중에 자기 자신을 다시 호출(recursive call) 하는 것
- 재귀 함수의 특징
    - 재귀 함수의 특징
        - 일정한 규칙을 갖고 동일한 유형의 작업을 반복 처리하는 경우에 사용
    - 재귀 함수의 단점
        - 스택(Stack) 이라는 메모리 공간을 많이 사용함
    - 일반적인 함수 호출 과정
        - 호출 받은 함수를 처리하고 원래 위치로 돌아오기 위해 주소와 매개변수 값을 스택에 보관함
        - 호출 받은 함수는 스택에 있는 실 매개변수의 값을 꺼내서 형식 매개변수에 대입함
        - 호출 받은 함수의 처리 종료 후, 스택에 보관된 주소를 꺼내서 원래의 위치로 돌아옴
            
            ![image.png](C언어1(2)/image%2039.png)
            
    - 재귀 함수의 단점
        - 스택(stack)이라는 메모리 공간을 많이 사용
        - 스택 공간이 많이 필요
        - 스택에 정보를 저장하고 꺼내는데 많은 시간이 사용됨
        - 스택 공간이 넘치는 오버플로우(overflow) 발생 가능
        - 일반적인 함수에 비해 함수 호출 회수가 많기 때문에 메모리를 많이 사용
- 재귀 함수의 사용
    - 팩토리얼 문제
        
        ![image.png](C언어1(2)/image%2040.png)
        
        ![image.png](C언어1(2)/image%2041.png)
        

# 배열의 개념

- 개요
    - 변수(Variable)
        - 오직 하나의 값만 저장할 수 있음
    - 배열(Array)
        - 많은 값을 한꺼번에 저장할 수 있는 저장 장소
        - 동일한 타입의 데이터가 여러 개 저장되는 저장 장소
        - 같은 종류의 대량의 데이터를 효율적이고 간편하게 처리하는 방법
    - 배열의 필요성
        - 예) 10명 학생의 점수를 저장하기
            
            ![image.png](C언어1(2)/image%2042.png)
            
            ![image.png](C언어1(2)/image%2043.png)
            
- 배열 요소와 인덱스
    - 배열 요소(array element) 또는 배열 원소
        - 배열을 구성하는 각 항목
    - 인덱스(index), 첨자(subscript)
        - 배열 요소의 번호
    - 배열의 크기
        
        ![image.png](C언어1(2)/image%2044.png)
        
    - 배열의 특징
        - 메모리의 연속적인 공간에 저장됨
        - 서로 관련된 데이터를 차례로 접근하기 쉬움
        - 배열을 사용하려면 먼저 배열을 선언해야 함
- 배열의 선언
    - 배열의 선언
        
        ![image.png](C언어1(2)/image%2045.png)
        
        - 자료형 : 배열 원소들의 타입
        - 배열 이름 : scores
        - 배열 크기 : 배열 원소 개수 10개
        - 인덱스(배열 번호)는 항상 0부터 시작, 0 ~ (배열크기 - 1)
    - 배열 선언의 예
        
        ![image.png](C언어1(2)/image%2046.png)
        
    - 배열 선언 시 주의사항
        - 배열 크기는 반드시 지정해야 함
        - 배열 크기는 항상 상수 이어야 함
        - 배열 크기로 사용할 수 없는 경우
            
            ![image.png](C언어1(2)/image%2047.png)
            
    - #define 사용
        - 기호 상수로 배열 크기 지정
        - 배열 선언 시 배열의 크기를 기호 상수로 지정하면 수정이 쉬움
            
            ![image.png](C언어1(2)/image%2048.png)
            

# 배열과 반복문

- 배열 접근
    
    ![image.png](C언어1(2)/image%2049.png)
    
    - 잘못된 인덱스 문제
        - 인덱스가 배열의 크기를 벗어나게 되면 프로그램에 치명적인 오류를 발생시킴
        - C에서는 프로그래머가 인덱스가 범위를 벗어나지 않았는지를 확인하고 책임을 져야 함
        
        ![image.png](C언어1(2)/image%2050.png)
        
- 반복문 이용
    - 배열의 가장 큰 장점
        - 반복문을 사용하여 배열의 원소를 간편하게 처리할 수 있다는 점
            
            ![image.png](C언어1(2)/image%2051.png)
            
    - 배열 저장
        
        ![image.png](C언어1(2)/image%2052.png)
        
    - 반복문을 이용하여 배열 저장
        
        ![image.png](C언어1(2)/image%2053.png)
        
    - 기호 상수를 이용한 예제
        
        ![image.png](C언어1(2)/image%2054.png)
        
    - 반복문을 이용하여 난수로 초기화하기
        
        ![image.png](C언어1(2)/image%2055.png)
        
    - 반복문을 이용하여 배열에 성적을 입력받아 저장
        
        ![image.png](C언어1(2)/image%2056.png)
        

# 배열의 초기화

- 개요
    - 배열의 초기화
        - 원소들의 초기값을 콤마로 분리
        - 중괄호 사용
        - 순서대로 대입
            
            ![image.png](C언어1(2)/image%2057.png)
            
    - 주의 사항
        - 초기값의 개수가 배열 크기보다 큰 경우
            
            ![image.png](C언어1(2)/image%2058.png)
            
    - 초기값의 개수가 배열의 크기보다 작으면
        - 앞에 있는 요소들만 초기화
        - 나머지 배열 요소들은 모두 0으로 초기화
            
            ![image.png](C언어1(2)/image%2059.png)
            
    - 배열의 모든 요소를 0으로 초기화
        
        ![image.png](C언어1(2)/image%2060.png)
        
    - 배열의 크기 없이 초기값만 있는 경우
        - 컴파일러가 자동으로 초기값들의 개수만큼 배열의 크기를 잡음
            
            ![image.png](C언어1(2)/image%2061.png)
            
- 초기화 예제
    
    ![image.png](C언어1(2)/image%2062.png)
    
    ![image.png](C언어1(2)/image%2063.png)
    
    ![image.png](C언어1(2)/image%2064.png)
    
- 배열의 사용
    - 배열 요소의 개수 계산
        
        ![image.png](C언어1(2)/image%2065.png)
        
    - 배열의 복사
        - 배열의 요소를 하나씩 복사함
            
            ![image.png](C언어1(2)/image%2066.png)
            
    - 배열의 비교
        - 배열 내용 전체를 다른 배열 내용 전체와 같은지 비교
            
            ![image.png](C언어1(2)/image%2067.png)
            
        - 원소를 하나씩 비교
            
            ![image.png](C언어1(2)/image%2068.png)
            

# 함수에서 배열 사용

- 배열과 함수
    - 배열을 함수로 전달할 경우
        - 배열의 원본이 매개변수를 통해서 전달됨
            
            ![image.png](C언어1(2)/image%2069.png)
            
    - 배열 요소를 함수로 전달할 경우
        - 원본이 아닌 복사본이 전달됨
            
            ![image.png](C언어1(2)/image%2070.png)
            
- 예제
    - 학생들의 성적을 저장
        
        ![image.png](C언어1(2)/image%2071.png)
        
    - 배열을 조작하는 함수
        
        ![image.png](C언어1(2)/image%2072.png)
        
- 배열 원본 변경 금지
    - const 키워드 사용
        - 배열이 함수의 매개 변수로 전달되는 경우 함수 안에서 배열 요소들의 값을 변경할 수 없도록 할 수 있음
            
            ![image.png](C언어1(2)/image%2073.png)
            

# 정렬과 탐색 프로그램

- 개요
    - 정렬(Sorting)
        - 크기순으로 나열하는 것
        - 컴퓨터 공학분야에서 가장 기본적이고 중요한 알고리즘 중의 하나
        - 자료 탐색에 있어서 필수적
        - 오름차순(Ascending order) / 내림차순(Descending order)
    - 탐색(Search)
        - 많은 시간이 요구되는 작업
        - 효율적으로 수행하는 것이 매우 중요
    - swap 알고리즘
        - 두 변수의 값을 서로 교환할 때
            
            ![image.png](C언어1(2)/image%2074.png)
            
- 선택 정렬(Selection Sort)
    - 두 개의 배열(비어있는 배열과 정렬되지 않은 배열)
    - 가장 작은 숫자를 선택하여 왼쪽 배열로 이동하는 작업 반복
    - 정렬되지 않은 배열이 공백 상태가 될 때 까지
        
        ![image.png](C언어1(2)/image%2075.png)
        
    - 정렬이 안 된 숫자들 중에서 최소값을 선택하여 배열의 첫 번째 요소와 교환
    - 첫 번째 요소를 제외한 나머지 원소들 중에서 반복
        
        ![image.png](C언어1(2)/image%2076.png)
        
    - 정렬이 안 된 숫자들 중에서 최소값을 선택하여 배열의 첫 번째 요소와 교환
        
        ![image.png](C언어1(2)/image%2077.png)
        
        ![image.png](C언어1(2)/image%2078.png)
        
- 순차 탐색(Sequential Search)
    - 탐색 방법 중에서 가장 간단하고 직접적인 방법
    - 배열의 원소를 순서대로 하나씩 꺼내서 탐색키와 비교하여 원하는 값을 찾아가는 방법
        
        ![image.png](C언어1(2)/image%2079.png)
        
    - 배열의 원소를 순서대로 탐색키와 비교하여 원하는 값을 찾아가는 방법
        
        ![image.png](C언어1(2)/image%2080.png)
        
- 이진 탐색(Binary Search)
    - 속도가 빠른 탐색 기법
    - 정렬된 배열의 중앙에 있는 값을 탐색키와 비교
        
        ![image.png](C언어1(2)/image%2081.png)
        
    - 한 번 비교할 때마다 탐색의 범위가 절반으로 줄어듦
    - 탐색전에 반드시 정렬되어 있어야 함
    - 데이터의 삽입이나 삭제가 빈번할 시에는 적합하지 않음
    - 주로 고정된 데이터에 대한 탐색에 적합
    - 이진 탐색 과정의 예
        
        ![image.png](C언어1(2)/image%2082.png)
        
    - 이직 탐색 코드 - main()
        
        ![image.png](C언어1(2)/image%2083.png)
        
    - 이진 탐색 코드
        
        ![image.png](C언어1(2)/image%2084.png)
        

# 포인터 개념

- 개요
    - 컴퓨터의 메모리(Memory)
        - 바이트(Byte) 단위로 주소를 붙임
        - 첫 번째 바이트의 주소는 0, 두 번째 바이트의 주소는 1, …
        - 주소(address)로 메모리에 접근 가능
            
            ![image.png](C언어1(2)/image%2085.png)
            
    - 변수
        - 메모리에 저장됨
        - 컴파일러에 의해 메모리 공간의 비어있는 위치에 할당됨
        - 자료형에 따라 메모리에 차지하는 공간이 달라짐
    - 포인터(Pointer)
        - 메모리의 주소를 가지고 있는 변수
- 변수와 메모리
    - 변수의 크기에 따라 차지하는 메모리 공간이 달라짐
    - 일반적인 PC 환경
        - char형 변수는 1바이트 차지
        - int형 변수는 4바이트 차지
        - float형 변수는 4바이트 차지
    - 메모리 배치의 예
        
        ![image.png](C언어1(2)/image%2086.png)
        
- 주소 연산자 &
    - 주소 연산자(Address of operator) &
        - C 언어에서 변수의 주소를 계산하는 연산자
        - 변수의 이름을 받아서 변수의 주소를 반환함
            
            ![image.png](C언어1(2)/image%2087.png)
            
    - 주소 연산자 사용 예
        
        ![image.png](C언어1(2)/image%2088.png)
        
    - 변수의 주소
        
        ![image.png](C언어1(2)/image%2089.png)
        

# 포인터 선언

- 개요
    - 포인터
        - 변수의 주소를 가지고 있는 변수
        - 포인터 변수
        - 사용하기 전에 선언되어야 함
        - 포인터 이름은 식별자 규칙을 따름
        - 포인터 선언 형식
            
            ![image.png](C언어1(2)/image%2090.png)
            
        - 포인터 변수 선언 결과
            
            ![image.png](C언어1(2)/image%2091.png)
            
    - 다양한 자료형의 포인터변수 선언
        
        ```c
        int *p ;
        char *pc ;
        float *pf ;
        double *pd ;
        ```
        
    - 선언의 예
        
        ```c
        int *p1, *p2, *p3 ; ;
        ```
        
    - 잘못된 선언의 예
        
        ```c
        int *p1, p2, p3 ;
        // p2와 p3는 정수형 변수임
        ```
        
- 초기화
    - 포인터와 변수의 연결
        
        ![image.png](C언어1(2)/image%2092.png)
        
    - 다양한 포인터의 초기화
        
        ```c
        char c = 'A' ; // 문자형 변수 c
        float f = 36.5 ; // 실수형 변수 f
        double d = 3.141592 ; // 실수형 변수 d
        char *pc = &c ; // 문자를 가리키는 포인터 pc
        float *pf = &f ; // 실수를 가리키는 포인터 pf
        double *pd = &d ; // 실수를 가리키는 포인터 pd
        ```
        
- 예제
    - 다양한 포인터의 선언
        
        ![image.png](C언어1(2)/image%2093.png)
        

# 간접 참조 연산자

- 개요
    - 포인터
        - 메모리의 주소를 저장할 수 있는 변수
        - 포인터를 통하여 값을 읽거나 변경 가능
    - 간접 참조(dereferencing, indirection)
        - 포인터가 가리키는 주소에 저장된 내용을 읽음
        - 포인터를 통하여 메모리에 접근
    - 간접 참조 연산자
        - 포인터가 가리키는 값을 가져오는 연산자
    - 간접 참조의 예
        
        ```c
        int i = 10 ;
        int *p ;
        p = &i ;
        printf("%d == %d \n", i, *p) ;
        *p = 50 ;
        printf("%d == %d \n", i, *p) ;
        ```
        
        ![image.png](C언어1(2)/image%2094.png)
        
- & 연산자와 * 연산자
    - & 연산자
        - 변수의 주소를 반환함
        - 변수의 주소를 구하여 포인터에 대입할 때 사용되는 연산자
    - * 연산자
        - 포인터가 가리키는 곳의 내용을 반환함
        - 포인터를 통하여 변수를 간접 참조할 때 사용하는 연산자
    - & 연산자와 * 연산자의 예
        
        ![image.png](C언어1(2)/image%2095.png)
        
    - 예제
        
        ![image.png](C언어1(2)/image%2096.png)
        
        ![image.png](C언어1(2)/image%2097.png)
        
        ![image.png](C언어1(2)/image%2098.png)
        
- 주의 사항
    - 초기화하지 않고 사용하기
        - 초기화가 안된 포인터를 사용하면 안 된다.
            
            ```c
            int *p; // 포인터 p는 초기화가 안되어 있음
            *p = 100; // 위험한 코드
            ```
            
    - NULL 포인터 사용
        - 포인터가 아무것도 가리키고 있지 않는 경우
        - NULL로 초기화
            
            ```c
            int *p = NULL;
            ```
            
    - NULL
        - 헤더파일 stdio.h에 0으로 정의되어 있음
    - 포인터 p가 유효한지 검사
        
        ```c
        if ( p != NULL )
        printf("포인터 p는 유효함\n") ;
        else
        printf("포인터 p는 유효하지 않음\n") ; 
        ```
        
    - 포인터의 타입과 변수의 타입 일치
        
        ![image.png](C언어1(2)/image%2099.png)
        

# 포인터 연산

- 덧셈과 뺄셈 연산
    - 포인터에 대해 가능한 연산
        - 증가, 감소, 덧셈, 뺄셈 연산
        - 연산되는 값은 포인터가 가리키는 객체의 크기
        - 연산되는 값은 포인터가 가리키는 변수의 자료형의 크기
            
            ![image.png](C언어1(2)/image%20100.png)
            
    - 증가 연산 예제
        
        ![image.png](C언어1(2)/image%20101.png)
        
    - 포인터의 증감 연산
        - pc가 char형 포인터인 경우
            
            ![image.png](C언어1(2)/image%20102.png)
            
        - pc가 int 형 포인터인 경우
            
            ![image.png](C언어1(2)/image%20103.png)
            
        - pc가 double 형 포인터인 경우
            
            ![image.png](C언어1(2)/image%20104.png)
            
- 간접 참조 연산자와 증감 연산자
    - 증감 연산자는 간접 참조 연산자 *와 같이 사용 가능
        - 증감 연산자가 포인터에 적용되는 경우
            
            ![image.png](C언어1(2)/image%20105.png)
            
        - 증감 연산자가 포인터가 가리키는 대상에 적용되는 경우
            
            ![image.png](C언어1(2)/image%20106.png)
            
    - 수식 정리
        
        ![image.png](C언어1(2)/image%20107.png)
        
    - 예제
        
        ![image.png](C언어1(2)/image%20108.png)
        
- 포인터의 형변환
    - C언어에서는 꼭 필요한 경우에, 명시적으로 포인터의 타입을 변경 가능
        
        ```c
        double *pd = &f;
        int *pi;
        pi = (int *)pd;
        ```
        

# 포인터와 함수

- 함수 호출시 인수 전달 방식
    - 함수가 외부로부터 매개 변수를 통해 데이터를 받는 방법
        - 값에 의한 호출(call by value)
            - 함수로 복사본 전달
            - 기본적인 방법
        - 참조에 의한 호출(call by reference)
            - 함수로 원본 전달
            - C에서는 포인터를 이용하여 간접 구현 가능
    - swap() 함수 #1 (값에 의한 호출)
        
        ![image.png](C언어1(2)/image%20109.png)
        
    - 값에 의한 호출
        
        ![image.png](C언어1(2)/image%20110.png)
        
    - swap() 함수 #2 (참조에 의한 호출)
        
        ![image.png](C언어1(2)/image%20111.png)
        
    - 참조에 의한 호출
        
        ![image.png](C언어1(2)/image%20112.png)
        
- scanf() 함수
    - 변수에 값을 저장하기 위하여 변수의 주소를 받음
        
        ![image.png](C언어1(2)/image%20113.png)
        
- 포인터를 사용하는 반환값
    - 함수의 반환값으로 포인터 사용 가능
        - 함수가 종료되더라도 남아 있는 기억 장소의 변수를 반환해야 함
            
            ![image.png](C언어1(2)/image%20114.png)
            

# 포인터와 배열

- 개요
    - 배열 이름
        - 포인터 상수
        - 배열의 시작 주소
        - 연산 불가능
            
            ![image.png](C언어1(2)/image%20115.png)
            
    - 예제
        
        ![image.png](C언어1(2)/image%20116.png)
        
    - 포인터와 배열의 관계
        
        ![image.png](C언어1(2)/image%20117.png)
        
    - 포인터는 배열처럼 사용 가능
    - 인덱스 표기법을 포인터에 사용 가능
        
        ![image.png](C언어1(2)/image%20118.png)
        
    - 포인터를 배열처럼 사용
        
        ![image.png](C언어1(2)/image%20119.png)
        
- 배열 매개 변수
    - 일반 매개 변수 vs 배열 매개 변수
        
        ![image.png](C언어1(2)/image%20120.png)
        
    - 배열 매개 변수는 포인터로 간주
        
        ![image.png](C언어1(2)/image%20121.png)
        
    - 배열 이름
        - 포인터 상수
    - // 포인터와 함수의 관계
        
        ![image.png](C언어1(2)/image%20122.png)
        
    - 배열 매개 변수 vs 포인터 매개 변수
        
        ![image.png](C언어1(2)/image%20123.png)
        
- 포인터 사용의 장점
    - 포인터가 인덱스 표기법보다 빠름
        
        ![image.png](C언어1(2)/image%20124.png)
        
    - 포인터를 반환할 때 주의점
        - 함수가 종료되더라도 남아 있는 변수의 주소를 반환해야 한다.
            
            ![image.png](C언어1(2)/image%20125.png)
            
    - 연결 리스트나 이진 트리 등의 향상된 자료 구조를 만들 수 있음
    - 메모리처럼 접근할 수 있는 하드웨어 장치를 직접 조작 가능
    - 참조에 의한 호출 : 포인터를 매개 변수로 이용하여 함수 외부의 변수의 값을 변경 가능
    - 동적 메모리 할당

# 문자와 문자열

- 개요
    - 문자의 중요성
        - 컴퓨터 : 숫자 처리하는 기계
        - 인간 : 텍스트를 이용하여 정보를 전달
        - C언어 : 문자열을 위한 별도의 자료형 없음
    - 문자(character)
        - 하나의 글자
        - 작은 따옴표를 이용하여 표현
        - ‘A’, ‘h’, …
        - char형
    - 문자열(string)
        - 일련의 문자들의 모임
        - 큰 따옴표를 이용하여 표현
        - “A”, “hello”, …
        - char형의 배열
        - 널(NULL) 문자로 문자열의 끝을 표시
            - ‘\0’으로 표기 가능
            - 0으로 표기 가능
- 문자열의 저장과 출력
    - 문자열의 저장
        - 문자 배열의 초기화
            
            ![image.png](C언어1(2)/image%20126.png)
            
            ![image.png](C언어1(2)/image%20127.png)
            
    - 문자열의 출력
        - 반복문 이용
        - printf()
            
            ![image.png](C언어1(2)/image%20128.png)
            
    - 예제) 문자열의 출력
        
        ![image.png](C언어1(2)/image%20129.png)
        
    - 예제) 문자열의 복사
        
        ![image.png](C언어1(2)/image%20130.png)
        
    - 예제) 문자열의 길이
        
        ![image.png](C언어1(2)/image%20131.png)
        
- 문자열 처리
    - 문자열 변경
        - 문자 배열 원소에 개별적으로 변경할 수 있음
            
            ![image.png](C언어1(2)/image%20132.png)
            
        - 라이브러리 함수 strcpy() 사용
            
            ![image.png](C언어1(2)/image%20133.png)
            
    - 문자열 변경 시 주의사항
        
        ![image.png](C언어1(2)/image%20134.png)
        
    - 문자열 상수
        - 문자열 상수 : 프로그램 소스 안에 포함된 문자열
            
            ![image.png](C언어1(2)/image%20135.png)
            

# 문자 입출력 라이브러리

- 개요
    - 문자 입출력 함수들
        
        ![image.png](C언어1(2)/image%20136.png)
        
- getchar()와 putchar()
    - getchar(void)
        - 키보드로부터 하나의 문자을 입력 받아서 반환
        - <stdio.h>
        - EOF(End Of File) 문자 사용
        - 엔터키를 치면, 버퍼에 저장되었던 문자들이 프로그램으로 전달됨
        - EOF(End Of File) 문자
            - 파일의 끝을 표현하기 위해 정의된 상수
            - 더 이상 읽을 수 있는 데이터가 없음을 의미
            - 보통 -1로 정의된 상수
            - 콘솔에서 Ctrl + Z를 누르면 입력됨
            - 함수 호출이 실패했을 때 반환
    - putchar()
        - 모니터로 하나의 문자를 출력\
        - <stdio.h>
        - 엔터키를 치면, 버퍼에 저장되었던 문자들이 프로그램으로 전달됨
    - 예제]
        
        ![image.png](C언어1(2)/image%20137.png)
        
- _getch() 와 _putch()
    - _getch()와 _putch()
        - <conio.h>
        - EOF(End Of File) 문자
            - 입력의 끝을 나타내는 문자
            - 보통 -1로 정의
        - 버퍼를 사용하지 않고, 에코가 없음
    - _getch()
        - 사용자가 문자를 하나 입력하면 바로 프로그램으로 전달됨
        - 화면에 아무것도 나타내지 안흥ㅁ
    - 예제)
        
        ![image.png](C언어1(2)/image%20138.png)
        
    - 문자 입출력 함수들의 비교
        
        ![image.png](C언어1(2)/image%20139.png)
        
- scanf()와 printf()
    - %c 형식 지정자 사용
        
        ```c
        char ch;
        scanf("%c", &ch);
        printf("%c", ch);
        ```
        

# 문자열 입출력 라이브러리

- 개요
    - 문자열을 입출력하는 방법
        - 일반적인 경우 scanf()와 printf() 사용
            
            ![image.png](C언어1(2)/image%20140.png)
            
- scanf()와 printf()
    - %s 형식 지정자 사용
    - scanf()의 문제
        - 한 단어 입력 가능
        - 예제)
            
            ![image.png](C언어1(2)/image%20141.png)
            
- gets_s()와 puts()
    - gets_s(버퍼, 버퍼크기)
        - 표준 입력으로부터 엔터키(’\n’)까지 한 줄의 문자열 입력 받아 인자로 받은 버퍼에 저장하는 함수
        - 공백을 포함하여 문자열을 입력 받음
            - 엔터키(’\n’)는 널문자(’\0’)으로 저장됨
            - 성공하면 입력된 문자열 반환
            - 실패하면 NULL 반환
        - 버퍼 오버플로우 방지
    - puts(문자열)
        - 표준 출력으로 문자열 출력
            - 널문자(‘\0’)는 엔터키(‘\n’)로 변경됨
            - 문자열 출력 후 자동으로 개행이 이루어짐
            - 성공하면 음수 아닌 값 반환
            - 실패하면 EOF(End Of File) 반환
    - 예제)
        
        ![image.png](C언어1(2)/image%20142.png)
        

# 문자 처리 라이브러리

- 개요
    - 문자 관련 처리 라이브러리
        - 문자들을 검사하는 함수
            - 영문 알파벳/숫자/대문자/소문자 검사
            - is…()로 시작
            - 검사 결과가 참이면 0이 아닌 값 반환
            - 검사 결과가 거짓이면 0 반환
    - 대문자를 소문자로 변환시키는 함수 등
    - <stype.h>
- 종류
    - 문자 검사 라이브러리
        - 검사 결과가 참이면 0이 아닌 값 반환
        - 검사 결과가 거짓이면 0 반환
        - 인자 : int
        - 반환형: int
        
        ![image.png](C언어1(2)/image%20143.png)
        
        ![image.png](C언어1(2)/image%20144.png)
        
    - 문자 변환 라이브러리
        - 대문자를 소문자로 변환
        - to…()로 시작
        - 반환값은 변환된 문자
        - 인자: int
        - 반환형: int
            
            ![image.png](C언어1(2)/image%20145.png)
            
- 간단한 예제
    - 예제) 소문자이면 대문자로 변환하는 프로그램
        
        ![image.png](C언어1(2)/image%20146.png)
        

# 문자열 처리 라이브러리

- 개요
    - 문자열 처리 라이브러리
        - 문자열 이어 붙이기
        - 문자열 서로 비교하기 등
        - <string.h>
        - str… 로 시작
    - <string.h>
        
        ![image.png](C언어1(2)/image%20147.png)
        
        ![image.png](C언어1(2)/image%20148.png)
        
- 문자열 길이, 복사, 연결
    - strlen()
        - 문자열 길이
            
            ![image.png](C언어1(2)/image%20149.png)
            
        - 문자열 길이 예제)
            
            ![image.png](C언어1(2)/image%20150.png)
            
    - strcpy()
        - 문자열 복사
        - src가 가리키는 문자열을 dst가 가리키는 배열로 복사
            
            ![image.png](C언어1(2)/image%20151.png)
            
        - 문자열 복사 예제)
            
            ![image.png](C언어1(2)/image%20152.png)
            
    - strcpy() 주의사항
        
        ![image.png](C언어1(2)/image%20153.png)
        
    - strcat()
        - 문자열 연결
        - dst가 가리키는 문자열 뒤에 src 문자열을 연결
            
            ![image.png](C언어1(2)/image%20154.png)
            
        - 문자열 연결 예제)
            
            ![image.png](C언어1(2)/image%20155.png)
            
- 문자열 비교, 검색, 분리
    - strcmp()
        - 문자열 비교
        - 사전적인 순서로 두 개의 문자열이 같은지 비교(아스키코드값)
        - 문자열이 같으면 0 반환
            
            ![image.png](C언어1(2)/image%20156.png)
            
            ![image.png](C언어1(2)/image%20157.png)
            
    - strcmp() 예제
        
        ```c
        char s1[10] = "aaaaa";
        char s2[10] = "aaaaa";
        int ret = strcmp(s1, s2);
        if (ret == 0)
        printf("같은 배열\n");
        else
        printf("다른 배열\n");
        ```
        
    - strchr()
        - 문자 검색
        - 문자열에서 특정 문자가 있는지 검색
            
            ![image.png](C언어1(2)/image%20158.png)
            
        - 문자 검색 예제
            
            ![image.png](C언어1(2)/image%20159.png)
            
    - strstr()
        - 문자열 검색
        - 문자열에서 특정 문자가 있는지 검색
            
            ![image.png](C언어1(2)/image%20160.png)
            
        - 문자열 검색 예제
            
            ![image.png](C언어1(2)/image%20161.png)
            
    - strtok()
        - 문자열 분리
        - 특정 문자를 기준으로 문자열을 자르기
        - 토큰(token) : 문법적으로 더 이상 나눌 수 없는 기본적인 언어 요소
            - 문장에서 공백 문자로 분리된 단어들
                
                ![image.png](C언어1(2)/image%20162.png)
                
        - 문자열 분리
            
            ![image.png](C언어1(2)/image%20163.png)
            
        - 문자열에서 기준문자열을 기준하여 토큰으로 분리
        - 기준문자열 : 토큰을 분리하는 분리자
            - 여러 개 지정하려면 문자열(”, \t\n”)로 만들어 사용
        - 첫 번째 토큰에 대한 포인터 반환 후 계속 분리하려면 문자열 대신 NULL을 사용
    - strtok() 예제
        
        ![image.png](C언어1(2)/image%20164.png)
        
    - strtok() 주의사항
        - 자르는 부분을 널 문자(NULL)로 채운 뒤 잘린 문자열의 포인터를 반환
        - 원본 문자열의 내용을 바꾸므로 사용에 주의
            
            ![image.png](C언어1(2)/image%20165.png)
            

# 문자열의 수치 변환

- 문자열을 수치로 변환하는 전용함수
    - 전용 함수는 scanf()보다 크기가 작음
    - stdlib.h에 원형 정의 - 반드시 포함
        
        ![image.png](C언어1(2)/image%20166.png)
        
- 문자열의 배열
    - 문자열 여러 개를 저장하는 방법
        - 문자열의 배열
        - 문자 포인터 배열
            
            ![image.png](C언어1(2)/image%20167.png)
            

# 구조체 개념과 선언

- 자료형
    - C언어에서의 자료형
        - 기본 자료형
        - 파생 자료형
            - 기본 자료형에서 파생된 자료형
        - 사용자정의 자료형
            
            ![image.png](C언어1(2)/image%20168.png)
            
- 구조체 필요성
    - 학생에 대한 데이터의 모임
        - 학생 데이터
            - 학번 - 정수형
            - 이름 - 문자열
            - 학점 - 실수형
                
                ![image.png](C언어1(2)/image%20169.png)
                
    - 구조체
        - 여러 개의 변수들을 묶어서 만든 새로운 자료형
        - 객체 지향 프로그램에서의 클래스의 모체
        - 여러 개의 서로 다른 자료형들을 하나로 묶은 것
            
            ![image.png](C언어1(2)/image%20170.png)
            
- 구조체와 배열
    - 배열(array)
        - 동일한 종류의 데이터들의 모임
    - 구조체(structure)
        - 서로 다른 종류의 데이터들의 모임
            
            ![image.png](C언어1(2)/image%20171.png)
            

# 구조체의 선언과 초기화

- 구조체 선언
    - 구조체
        - 서로 다른 자료형의 변수들을 묶어서 만든 자료형
        - struct 키워드 사용
            
            ![image.png](C언어1(2)/image%20172.png)
            
        - struct 키워드
            - 구조체를 선언할 때 사용하는 키워드
        - 구조체 태그(tag)
            - 구조체들을 구별하기 위한 이름
        - 구조체 멤버(structure member)
            - 구조체에 포함되는 변수
            - 어떠한 자료형의 변수도 구조체의 멤버가 될 수 있음
            - 이름이 중복될 수 없음
        - 세미콜론(;)
            - 구조체의 선언이 끝나면 반드시 필요함
    - 구조체 선언
        - 변수 선언은 아님
        - 어떤 변수들이 포함되는 지만 말해줌
        - 구조체의 형태(틀)만 정의
        - 아직은 데이터를 저장할 수 없음
    - 구조체 선언의 예
        
        ![image.png](C언어1(2)/image%20173.png)
        
        ![image.png](C언어1(2)/image%20174.png)
        
- 구조체 변수 선언과 초기화
    - 구조체 변수
        
        ![image.png](C언어1(2)/image%20175.png)
        
        ![image.png](C언어1(2)/image%20176.png)
        
        ![image.png](C언어1(2)/image%20177.png)
        
    - 구조체 멤버 참조
        
        ![image.png](C언어1(2)/image%20178.png)
        
    - 구조체 태그 생략 시
        - 구조체 변수를 구조체 선언과 함께 선언
        - 구조체 선언 후에 구조체 변수 선언 불가
            
            ```c
            struct {
            int num ;
            char name[20] ;
            double grade ;
            } s1, s2 ;
            ```
            
- 구조체 활용
    - 구조체 멤버
        - 모든 자료형 가능
        - 구조체도 가능
            
            ![image.png](C언어1(2)/image%20179.png)
            
    - 구조체 멤버 접근
        
        ![image.png](C언어1(2)/image%20180.png)
        
    - 구조체 변수의 연산
        - 구조체 변수 대입 가능
            - 구조체 변수 안의 자료 복사 가능
                
                ![image.png](C언어1(2)/image%20181.png)
                
    - 구조체 변수의 연산
        - 구조체 변수 비교 불가능
            
            ![image.png](C언어1(2)/image%20182.png)
            

# 구조체 배열

- 개요
    - 구조체 배열
        - 동일한 구조체 여러 개의 모임
        - 예: 많은 학생들의 데이터
- 선언 및 초기화
    - 구조체 배열의 선언
        - 앞에 struct 붙임
            
            ```c
            struct student {
            int num ;
            char name[20] ;
            double grade ;
            } ;
            ```
            
            ```c
            struct student s[40] ;
            ```
            
    - 구조체 배열의 초기화
        - 중괄호 안에 또 중괄호 필요함
            
            ```c
            struct student {
            int num ;
            char name[20] ;
            double grade ;
            } ;
            ```
            
            ```c
            struct student s[3] = {
            {1, "kim", 4.42},
            {2, "lee", 3.5},
            {3, "kim", 3.76}
            }
            ```
            
- 멤버 접근
    - 구조체 배열의 멤버 접근
        - 배열의 인덱스는 0부터 시작
            
            ```c
            struct student {
            int num ;
            char name[20] ;
            double grade ;
            } ;
            ```
            
            ```c
            struct student s[3] ;
            s[0].num = 1 ;
            strcpy(s[0].name, "kim");
            s[0].grade= 4.42;
            ```
            

# 구조체와 포인터

- 개요
    - 구조체에서 포인터가 사용되는 경우
        - 구조체를 가리키는 포인터
        - 포인터를 멤버로 가지는 구조체
            
            ![image.png](C언어1(2)/image%20183.png)
            
- 구조체를 가리키는 포인터
    - 구조체 포인터 선언
        
        ![image.png](C언어1(2)/image%20184.png)
        
    - 구조체 변수를 이용한 구조체 멤버 접근
        
        ![image.png](C언어1(2)/image%20185.png)
        
    - 구조체 포인터변수를 이용한 구조체 멤버 접근
        
        ![image.png](C언어1(2)/image%20186.png)
        
        - → 연산자
        - 간접 멤버 연산자(indirect membership operator)
            
            ![image.png](C언어1(2)/image%20187.png)
            
            ![image.png](C언어1(2)/image%20188.png)
            
        - 포인터 변수 p가 가리키는 구조체의 멤버 number
    - 구조체 변수와 구조체 포인터의 조합 비교
        
        ![image.png](C언어1(2)/image%20189.png)
        
        - 포인터 변수 p가 가리키는 구조체의 멤버 number
        
        ![image.png](C언어1(2)/image%20190.png)
        
        - 구조체 p의 멤버 (포인터 변수) number가 가리키는 내용
        
        ![image.png](C언어1(2)/image%20191.png)
        
        - p가 가리키는 구조체의 멤버 (포인터 변수) number가 가리키는 내용
- 포인터를 멤버로 가지는 구조체
    - 구조체는 멤버로 포인터를 가질 수 있음
        
        ![image.png](C언어1(2)/image%20192.png)
        

# 구조체와 함수

- 개요
    - 구조체를 함수의 인수로 사용 가능
    - 구조체를 함수에서 반환값으로 반환 가능
    - 값에 의한 호출
        - 구조체 변수의 모든 내용이 복사되어 함수로 전달/반환
        - 구조체의 크기가 클 경우 : 상당한 시간 소요
        - 구조체의 포인터를 사용하는 것이 바람직
- 구조체와 함수의 인수
    - 값에 의한 호출
        - 구조체의 복사본이 함수로 전달됨
        - 구조체의 크기가 클 경우
            - 시간과 메모리가 많이 소요됨
                
                ```c
                int equal(struct student s1, struct student s2) {
                	if ( s1.num == s2.num )
                		return 1 ;
                	else
                		return 0 ;
                }
                ```
                
    - 값에 의한 호출 개선
        - 구조체의 포인터 변수를 인수로 전달 개선
            - 포인터 변수는 일정한 크기
            - 원본 데이터 변경 가능
                
                ```c
                int equal(struct student *p1, struct student *p2) {
                	if ( p1->number == p2->number )
                		return 1 ;
                	else
                		return 0 ;
                }
                ```
                
        - 구조체의 포인터 변수를 인수로 전달
            - 원본 데이터 훼손 방지
                
                ```c
                int equal(struct student const *p1,
                					struct student const *p2) {
                	if ( p1->number == p2->number )
                		return 1 ;
                	else
                		return 0 ;
                }
                ```
                
- 구조체와 함수의 반환값
    - 함수가 구조체를 반환할 때
        - 복사본이 반환됨
        - 한 번에 여러 개의 값 반환 가능
            
            ```c
            struct student create() {
            	struct student s;
            	s.num = 3;
            	strcpy(s.name, “kim”);
            	s.grade = 4.3;
            	return s;
            }
            ```
            

# 공용체

- 공용체
    - 공용체(union)
        - 같은 메모리 영역을 여러 개의 변수가 공유
        - 메모리 절약(가장 큰 멤버의 크기만큼 할당)
        - 동시에 모든 멤버 변수들의 값을 저장할 수 없음
    - 공용체 정의
        
        ![image.png](C언어1(2)/image%20193.png)
        
    - 공용체 변수 선언
        
        ![image.png](C언어1(2)/image%20194.png)
        
    - 공용체 변수 초기화
        - 한 번에 하나의 멤버만 사용됨
        - 첫 번째 멤버만 초기화 가능
            
            ![image.png](C언어1(2)/image%20195.png)
            
    - 공용체 멤버 접근
        
        ```c
        union example e ;
        e.c = ‘a’ ;
        printf(“%c, %d\n”, e.c, e.i);
        e.i = 10 ;
        printf(“%c, %d\n”, e.c, e.i);
        ```
        
        ```c
        union example {
        	char c ;
        	int i ;
        };
        ```
        
    - 구조체와 공용체의 차이점
        
        ![image.png](C언어1(2)/image%20196.png)
        
- 열거형
    - 열거형(enumeration)
        - 변수가 가질 수 있는 기호상수들을 모아놓은 자료형
        - 열거형으로 선언된 변수
            - 열거형에 정의된 상수들만 가질 수 있음
        - 프로그램의 이해도 향상, 오류 줄여줌
        - 예
            - 요일을 저장하는 변수의 값
            - { 일요일, 월요일, 화요일, 수요일, 목요일, 금요일, 토요일 } 중 하나
    - 열거형 정의
        - 상수들은 0에서 1씩 증가하는 정수값으로 자동으로 설정됨
            
            ![image.png](C언어1(2)/image%20197.png)
            
    - 열거형 변수 정의
        
        ![image.png](C언어1(2)/image%20198.png)
        
    - 열거형 태그 생략
        - 단순히 기호상수만 정의됨
            
            ![image.png](C언어1(2)/image%20199.png)
        
      ![image.png](C언어1(2)/image%20200.png)
            
    
