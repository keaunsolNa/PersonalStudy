# 생활코딩 웹 어플리케이션 수업

# 개요

- 순서
    
    구상 - 기획(계획)[기획자] -디자인 - 개발(development)[개발자] - 테스트[QA)
    
    - >반복
    
    + Start Small(작은 것부터 시작하라) ->우선 완성하라
    
    - > 최소한의 기능으로 시작해서 중요한 부분을 추가
    - > 복잡도 (지수폭발) -> 기능 추가에 신중해라
- 구상
    
    왜 수업을 만들게 되었는가
    
    오프라인 수업 -> 블로그 (최신식 정렬)[부적합] -> 사이트 구축 (오래된 순 정렬)
    
- 기획
    
    Ui 모델링
    
    - > UI (User Interface) [사용자가 시스템을 제어하는 조작장치]
    - > 모델링(직접 만들기 전에 가상으로 만드는 것)
    - > 사용자의 입장에서 동작하는 기능을 가상으로 만들어 보는 것.
    
    + 중요한 이유 - 커뮤니케이션. 무엇을 만들고자 하는지를 분명하게 서로가 공요휴기 위한 도구
    
    모델링 도구
    
    1. 손으로 그리기
    2. Pencil (오픈소스 모델링 도구) [[http://pencil.evolus.vn/]](http://pencil.evolus.vn/])
    3. Balsamiq (사람이 손으로 그린 것 같은 느낌의 모델링 도구. 유료 [[http://balsmiq.com](http://balsmiq.com/)]
    4. 파워 포인트
- 인터넷과 웹의 역사
    
    인터넷과 웹은 다르다. (인터넷 안에 웹이 포함) 인터넷이 운영체제라면 웹은 어플리케이션.
    
    1960년대 인터넷 등장. 1990년대 웹 등장.
    
    +인터넷이라는 것은 전세계에 있는 컴퓨터들이 네트워크를 통해 연결되서 파일과 데이터를 주고 받을 수 있는 전세계에서 가장 거대한 네트워크. (비유하자면 도로)
    
    +웹이란 것은 저 네트워크를 활용하여 html같은 프로그램 언어를 언어를 이용해 만들어진 웹페이지를 컴퓨터와 컴퓨터가 주고받을 수 있도록 하는 서비스. (비유하자면 도로 위를 다니는 교통같은것)
    
    +팀 버너스 리 (유럽 입자물리 연구소에서 웹을 만든 사람.) 웹 브라우저와 웹 서버 사이에서 데이터 주고 받는 것. 그 사이의 통신 규약인 HTTP, HTML 제작
    
    - > 이후의 CSS, Javascript, ,PHP, MySQL 이런 언어들은 다 웹브라우저, 웹서버, HTML을 더 잘 사용할 수 있게 하는 도우미 같은 것.
- 서버와 클라이언트
    
    웹은 서버와 클라이언트라는 체계 안에서 동작 하는 것.
    
    클라이언트(개인컴퓨터)와 서버는 본질적으로 크게 다르지 않다.
    
    웹 브라우저가 설치되어 있는 컴퓨터를 클라이언트 컴퓨터
    
    웹 서버가 설치되어 있는 컴퓨터를 서버 컴퓨터
    
    클라이언트에서 주소를 입력하면 주소에 해당하는 서버에게 웹페이지를 요청
    
    - > 서버 컴퓨터에 저장되어 있는 웹페이지 문서를 읽어서 클라이언트에게 응답
    - -> 요청하는 클라이언트(웹 브라우저) 응답하는 서버(웹 서버)
    
    웹 서버 (Apache, Nginx, IIS)
    
    Apache와 Nginx는 오픈소스. IIS는 마이크로 소프트
    
    수업에서는 1등인 Apache를 이용.
    
    설치 주소는 [http://projects.apache.org/projects/http_server.html](http://projects.apache.org/projects/http_server.html)
    
    단 직접 설치는 까다롭고 다른 설치해야 하는 사항도 많으며. 필요 요구 조건도 많기 때문에 어렵다.
    
    - >편의성이 좋지 않다.
    
    그래서 bitnami를 이용할 것. ([http://bitnami.com/stack/wamp](http://bitnami.com/stack/wamp))
    
    - >w(window) a(apache) m(mysql) p(php)
- 웹 서버 설치 (윈도우)
    
    프로그램 설치.
    
    웹브라우저에 Localhost/index.html 주소 입력
    
    localhost -> 웹 브라우저가 설치되어 있는 컴퓨터의 웹서버를 가리키는 주소
    
    /index.html -> 웹 브라우저가 웹서버에게 index.html 파일 요청
    
    웹서버는 컴퓨터에 있는 htdocs 디렉토리 안에 있는 index.html 파일을 웹 브라우저에게 전송
    
    웹브라우저가 index.html 을 표시
    
    Localhost/helloworld.html 입력 -> notfound 출력(파일 없음)
    
    메모장 통해 helloworld.html 모든 파일 형식, UTF-8으로 인코딩 한 파일 생성 후
    
    다시 새로고침 하면 메모장 내용 출력됨,
    
    (htdocs -> document root) = 문서 최상위 디렉토리
    
- 서버 제어
    
    비트나미 제어판 사용방법. Apache Web Server의 Configure에서 로그 확인 가능.
    
    스타트 통해서 키고 시작할것.
    
- 프로그래밍 언어
    
    프로그래밍 언어란 사람과 컴퓨터 사이의 커뮤니케이션을 위한 도구(언어)
    
    프로그래밍 된 언어는 언어 사용자인 사람도 이해할 수 있고, 해석하는 컴퓨터도 이해할 수 있다
    
    이 때 언어는 코드. 그 언어를 작성하는 행위가 코딩
    

# HTML

- HTML 기본 문법
    
    HTML(Hypertext Markup Language)
    
    - > Hypertext = 문서와 문서가 링크로 연결되어 있는 것. (문서 연결 시스템)
    
    문서와 문서 사이의 링크, 링크와 링크가 연결된 하나의 거대한 정보 덩어리가 웹
    
    링크는 HTML의 본질 웹의 본질은 HTML
    
    안녕하세요. <strong>생활코딩</strong>입니다
    
    - > <strong> = 시작 태그(열린 태그) </strong> = 끝 태그
    - > 생활코딩 = 콘텐츠
    
    => ex_html_1 실습(다큐독스) [[localhost/ex_html_1.html]](http://localhost/ex_html_1.html)
    
- HTML 속성
    
    A 태그(링크를 나타내는 태그)
    
    - > <a>생활코딩</a> = 생활코딩에 링크가 걸려있는 것.
    - -> <a href=”http://opentutorials.org/course/1”>생활코딩</a>
    - --> href - 속성명, ”http://opentutorials.org/course/1” = 속성의 값.
    
    =>ex_html_2 실습(다큐독스) [localhost/ex_html_2.html]
    
    - > 새창으로 열기
    - > <a href="http://naver.com" target="_blank">생활코딩</a>
    - -> 속성명을 추가할 때는 띄어쓰기 한 번.
    - --> target=”_blank” = 새창으로(새 탭으로) 열기
    
    =>ex_html_3 실습(다큐독스) [localhost/ex_html_3.html]
    
    - ---> target=”_self”> = 현재 창에서 열기
- HTML 태그의 중첩
    
    리스트 사용하는 방법,
    
    - ><li>html</li>
    
    <li>css</li>
    
    <li>javascript</li>
    
    => ex_html_4 실습(다큐독스) [localhost/ex_html_4.html]
    
    - > 두 가지 이상의 목록을 사용하는 방법
    - ><ul></ul> 태그, <ol></ol> 태그
    - ->
    
    <ul>
    
    <li>html</li>
    
    > <li>css</li>
    > 
    > 
    > <li>javascript</li>
    > 
    
    </ul>
    
    <ol>
    
    <li>A</li>
    
    <li>B</li>
    
    <li>C</li>
    
    </ol>
    
    - > ul = unordered list (순서가 없는 리스트)
    - > ol = ordered list (순서가 있는 리스트)
    
    <body> 태그는 본문. (문서의 내용, 화면에 표시되는 내용)
    
    <head> 태그는 문서를 설명하는 정보들을 감싸고 있는 태그 (문서에 대한 정보를 담고 있는 태그
    
    - > 실습의 <meta charset=”utf-8”
    
    = 바디의 내용이 utf-8 문자코드로 저장되어 있는 문서라는 내용을 브라우저에게 알려주는 것.
    
    - > <title>은 웹페이지의 이름을 지정할 수 있다.
    - -> <title>생활코딩</title>
    
    => ex_html_4 실습(다큐독스) [localhost/ex_html_4.html]
    
    - > <html></html> 태그는 태그 안 쪽에 있는 것들이 html문서라는 것을 알려주는 역할
- HTML 정리
    
    W3C = HTML을 체계적으로 발전시키기 위한 기구 (표준을 정의)
    
    - > 태그의 퇴출과 추가 (의장 = 팀 버너스리)
    
    실습용 메모장의 <!DOCTYPE html> = 이 HTML 문서가 어떤 표준안에 따라 작성된 것인지 웹 브라우저가 이해할 수 있도록 기술한 내용
    
    Ex)
    
    HTML 5
    
    <!DOCTYPE html>
    
    HTML 태그는 영단어 같은 것.
    
    단 100-200개 정도의 태그를 외우기 보다는 이해하는게 우선.
    
    Tag Refernce
    
    [http://dev.w3.org/html5/html-author/](http://dev.w3.org/html5/html-author/)
    
    - >W3C 에서 제공하는 HTML 사전
    
    [http://opentutorials.org/course/1058](http://opentutorials.org/course/1058)
    
    - > 한국어로 된 HTML 사전
    
    HTML의 본질은 어떠한 정보를 사람과 컴퓨터가 같이 이해할 수 있도록, 태그를 이용해서 규정하고 정의하는 것.
    
    HTML은 정보다.
    
- 모델링을 HTML로 만들기
    
    <h1,2,3> 테그 = 주제어(제목 테그) (h=head)
    
    - > 실습 위주
    
    =>index1.html (다큐독스)
    
- 의미론적인 웹
    
    Semantic Web (의미론적인 웹, 의미가 잘 드러나는 웹)
    
    HTML 5 = 웹을 좀 더 의미론적으로 잘 드러나게 해 주는 웹
    
    이전 수업에서 <ol> <ul> 태그는 문서를 탐색하게 하는 역할을 하는 테그.
    
    링크를 걸어 다른 사이트로 이동하게 함.
    
    - > <ol>은 네비게이션 <ul> 는 컨텐츠
    
    단 기계는 이전 코딩만으로는 이해할 수 없다
    
    - ><nav></nav> 테그 추가
    - ><hearder></hearder> 테그는 간판과 같은 정보임을 알려주는 코드( 실제로 변화는 없다)
    - -><article></article> 테그는 본문과 같은 정보임을 알려주는 코드 (실제로 변화는 없다)
- 사이트 완성
    
    실습과정.
    
    - > index, page_1,2,3
    
    링크를 통해 각각의 페이지로 연결하는 방법.
    
    각각의 페이지의 html을 만들어 <a></a>테그를 통해 연결하는 것.
    
    단. 배운 내용으로는 수정할 사항이 있거나, 새로운 링크를 추가할 때 모든 페이지에 각각의 수정이 필요함 (극히 번거로움)
    

# 쉬어가기, 개발 도구

- 쉬어가기
    
    웹은 사용자와 사용처가 많아지면서 점점 더 복잡하고 거대해졌다
    
    - > 현재는 복잡하지만 그 안에는 맥락이 있다.
    - -> 웹은 정보다. (본질.)
    
    +Client Side Tech = HTML, CSS, JavaScript 같은 웹 브라우저 위에서 동작하는 기술(프론트)
    
    +Server Side Tech = PHP, MySQL 같은 서버 쪽에서 동작하는 기술.(백)
    
- 개발 도구 1 : 도구의 필요성
    
    +도구를 사용할 때, 도구의 강력함 뿐만 아니라 학습의 비용도 생각할 것.
    
    - > 도구에는 에디터 뿐만 아니라 PHP,MYSQL등도 포함
    - -> 편리할 수록 어려울 가능성이 높다.
    
    + 버전 관리 시스템(Version Control System) 소스코드를 작성 할 때, 코드 작성 중 변경된 코드들의 역사를 기록하는 프로그램.
    
    - > 어떤 문제가 생겼을 때, 문제가 어디에서, 누구로 인해서 발생했는지 탐색할 수 있도록 도와줌
    - -> 작성한 코드를 다른 컴퓨터에 안전하게 저장해주는 역할도 함.
    - --> 여러 사람이 협업하는 과정에서 똑같은 파일을 수정했을 때 어떻게 질서를 잡아야 할 지 알려주는 역할
    
    +SVN, Mecurial, GIT(가장 유망)
    
    - >[http://opentutorials.org/course/1492](http://opentutorials.org/course/1492)
    - > GIT 사용관리 수업. 단 지금은 어려우니 추후 반드시 확인할 것.
    
    +코드 편집기 (Editor)
    
    - > 이전의 메모장이 삽이라면, 에디터는 포크레인 정도.
    - -> 훨씬 더 빠르게 작성 가능하고, 하기 쉬운 실수도 잘 보정해준다.
    - --> 수업에서는 아톰 에디터를 사용한다. (깃허브에서 만든)
    
    + 아톰 에디터 다운로드 링크 ([https://atom.io/](https://atom.io/))
    
- 개발 도구 2 : 윈도우에 아톰 설치
    
    아톰 설치 방법 안내
    
- 개발 도구 3 : 아톰 사용법
    
    코드의 속성에 따라 다른 색깔
    
    탭 기능으로 코딩 확인
    
    확장 기능(그 에디터가 가지고 있는 기본적인 기능 외의 것을 외부개발자가 만든 것을 사용할 수 있게 하는 기능) 사용 가능
    
    - >emmet 설치.
    - > 실습 emmet.html.
    - > 편리한 도구

# CSS

- CSS 이론 1 : 기본 문법
    
    CSS = 정보를 아름답게 표현하는 언어
    
    - >(Cascading Style Sheet)
    - -> 무언가 스타일을 만들기 위한 언어.
    - --> HTML과는 완전히 다르지만, HTML 없이는 있을 수 없는 언어
    - ---> 기본적으로 HTML을 디자인하기 위한 언어
    - ----> HTML 안에 있던 시각적인 디자인을 위한 태그가 다 CSS에 집중되며 탄생했다
    
    + 다큐독스 안에 있는 폴더를 열기 위해선 / 기호로 폴더 구분하면 된다
    
    - > localhost/css(폴더이름)/ex_css_1.html(파일이름)
    
    +<Style> 테그 (CSS테그를 시작하는 테그)
    
    - > h1 {color:red}
    - -> body에 있는 h1내용을 빨간색으로
    - -->h1(선택자selector) : 뒤의 내용을 누구에게 적용시킬 것인가 (주어)
    - ---> {color:red} (서술description) 어떤 효과를 줄 것인가
- CSS 이론 2 : 선택자 심화학습
    
    font-size:10px 폰트 사이즈를 10px로
    
    - >px(단위)
    
    + {color:red; font-size:10px}
    
    각각의 color:red, font-size:10px는 속성이라 칭한다
    
    각각의 속성과 속성을 구분하는 구분자가 ;(세미콜론)
    
    예제의 h2내용도 h1테그와 동일한 효과를 주고 싶다면
    
    <style>
    
    h1,h2 {color:red; font-size:10px}
    
    </style>
    
    h2{text-decoration:underline;} 테그
    
    h2테그 안에 있는 내용에 밑줄을 쳐라
    
    border 테그 : 테두리를 씌우는 테그
    
    + 같은 h1 테그라도 <header> 안에 있는 테그만 효과를 주고 싶다면
    
    - > header h1 {}
- CSS 이론 3 : 박스 모델
    
    박스 모델 : CSS를 이용해서 각각의 HTML테그들의 위치, 부피, 여백 이런 것들을 지정하는 것.
    
    border:1px red dotted
    
    - > 테두리:1픽셀 빨간색 점선
    
    1px, red, dotted 각각의 테그 사이에는 띄어쓰기 1개
    
    +solid(단선), dotted(점선)
    
    + id 테그
    
    - > html과 css에 정의되어 있는 속성. 설명서에 적혀있는 이름
    
    +# = id를 나타내는 특수한 기호
    
    - -> id="selected" = #selected
    
    + padding:30px;
    
    - > 테그의 보딩 거리(크기)를 조절하는 테그
    
    +margin : 테그와 테그 사이의 간격을 조절하는 테그
    
    - border, padding, margin, width, height 테그
    - > 테두리를 입력하는 border 테그
    - -> 컨텐츠를 감싸는 border의 부피를 결정하는 padding 테그
    - --> 테그와 테그 사이의 간격을 결정하는 margin 테그
    - ---> 컨텐츠의 크기. 폭을 변경하는 Width, 높이를 변경하는 Height 테그
    
    + 이 모든 것들이 박스 모델.
    
    + 예제 : ex_css_2.html
    
    + 구글 크롬에서는 페이지 소스 코드를 확인, ,수정할 수 있다
    
    - >(단, 소스 코드에는 영향을 주지 못 한다)
- CSS 이론 4 : float
    
    float = 웹 페이지의 레이아웃을 작성할 때 주로 사용하는 속성
    
    + img 테그
    
    - > <img src="(이미지UL주소)" />
    - -> 이미지를 띄우는 테그
    
    +float 테그
    
    - > 두 개의 컨텐츠가 나란히 화면에 배치되게 하는 기능을 가지고 있는 테그
    - -> float:right, float:reft
    - --> 왼쪽, 오른쪽에 배치하는 개념의 느낌
    
    => ex_css_3.html
    
- CSS  실습 1
    
    이전에 만들었던 것들을 CSS로 수정할 것.
    
    - > 실습 위주. 이전의 page_2.html
- CSS 실습 2
    
    + <link rel="stylesheet" type="text/css" href="http://localhost/style.css">
    
    - > [http://localhost/style.css](http://localhost/style.css) (style.css는 작성한 파일(시트) 이름) 를 불러 와 적용한다.
    - -> 동일한 CSS 에 공통적으로 적용 가능
    - --> CSS와 HTML의 분리 가능
    
    + CSS파일을 외부로 빼서, 각각의 HTML파일에 적용, 변화 가능
    
    - > *중복의 제거*
    - -> 유지보수가 쉬워진다. CSS 용량의 부담을 줄일 수 있다.
- CSS 활용
    
    웹페이지를 수정할 수 있는 방법.
    
    - > stylebot 기능.
- 중간 정리
    
    HTML(정보 언어) -> CSS(웹 디자인) -> JAVASCRIPT(유저와 상호작용) -> PHP(웹페이지의 생산성 향상)-> MySQL(데이터 암호화, 데이터베이스, 은행과 같은 역할)
    

# JS, PHP 프로그래밍

- JS, PHP 프로그래밍 1 복습과 수업 예고
    
    HTML, CSS는 문서를 작성하는데 어울리는 언어
    
    PHP, Javascript는 전형적인 프로그래밍을 위한 프로그램.
    
    - > Java, Python, C 언어를 다루는데 도움을 받을 수 있다
    
    + HTML, CSS = 웹 브라우저 위에서 사용하는 언어
    
    + PHP, 데이터베이스 = 웹 서버 위에서 사용하는 언어
    
    +웹 서버도 웹 브라우저처럼 소프트웨어다.
    
    + 웹 브라우저가 웹 서버에게 [http://a.cm/a.php](http://a.cm/a.php) 요청
    
    - > 웹서버는 .php는 html이 아니니, 해당 명령을 수행할 수 있는 PHP 엔진(인터프리터)에게 요청
    - -> PHP엔진은 서버 컴퓨터에 있는 저장장치에서 a.php를 읽는다
    - --> <?php ~ ?> = php문법의 시작과 끝을 알려주는 기호
    
    + PHP 엔진은 해석된 코드를 html로 적용해서 웹서버에게 전달
    
    + 웹서버는 완성된 HTML정보를 웹 브라우저에게 전송
    
    + 웹 브라우저는 해석된 HTML정보를 화면에 출력
    
- JS, PHP 프로그래밍 2 JavaScript VS PHP
    
    Javascript와 PHP는 경쟁적인 관계. 단. Javascript로만 할 수 있는 것도, PHP로만 할 수 있는 것도 있기에 두 개의 언어는 협력적인 관계이기도 하다.
    
    + HTML, CSS는 정적인 언어 = 한 번 코드를 작성하면 바뀌지 않는다.
    
    + Javascript와 PHP는 동적인 언어 = 사용자가 버튼을 누르면 어떤 일이 일어나고, 정보를 입력해서 서버를 전송하면 입력한 내용이 저장되고, 여러가지 상황에 따라 다르게 동작하는 언어.
    
    + JavaScript = 주로, 흑백모드처럼 버튼을 누르면 화면(내용,정보)이 변한다.
    
    + PHP = 주로, CSS파일을 새로 생성하여 링크를 통해 각각의 HTML 파일에 적용했던 것처럼. 하나의 HTML로 여러 정보들을 표현할 수 있는 방법.
    
    - > 하나의 PHP파일로 여러 개의 웹페이지를 만들 수 있게 한 것.
- JS, PHP 프로그래밍 3 웹페이지에 코드 삽입하기
    
    프로그래밍 코드를 HTML에 삽입하는 방법
    
    + <?php
    
    > ?>
    > 
    - > php코드의 시작과 끝
    
    + <Script>
    
    </Script>
    
    - > javascript의 시작과 끝
    
    + echo "hello world";
    
    - > body 안에 hello world 출력(php 안에서)
    - -> <?php
    
    echo "hello world";
    
    ?>
    
    - --> 위 부분이 php 엔진에 의해 해석해서, "hello world"를 출력하는것.
    - ---> <?php
    
    echo 10+10
    
    ?>
    
    - ---> 크롬 소스코드 상에서는 위의 코드가 20으로 출력
    
    + <Script>
    
    document.write(10+10)"
    
    </script>
    
    - > 크롬 소스코드 상에서 위와 동일하게 모든 내용이 출력
    - -> PHP와 Javascript의 차이점
    
    + PHP는 서버 쪽에서 실행되는 언어. (서버사이드 언어)
    
    - > 서버에서 구문이 실행된 결과가 만들어져서 웹브라우저에 전송 (과정은 브라우저에 나오지 않는다)
    - -> 서버에서 해석하지 않고, php 인터프리터에게 전송한 php파일을 웹서버에게 전송. 웹서버는 받은 결과만을 웹 브라우저에게 전송.
    
    + 그러나 Javascript는 웹 브라우저가 해석해서 처리하는 언어
    
    - > 서버에서 처리하지 않고, 웹 브라우저에서 자바스크립트 코드를 해석해서 반영한다. (브라우저에 해석하는 과정이 나온다.)
    
    +php 에서 $기호는 변수의 선언이다.
    
    ++1.php 예문
    
- JS, PHP 프로그래밍 4 데이터타입과 연산자
    
    JavaScript, PHP 모두 문자를 사용할 때는 ""안에 쓴다.
    
    단, 숫자는 ""를 쓰면 안된다.
    
    - > Javascript, PHP 모두 "100000" = 문자, 100000 = 숫자로 인식
    
    + document.write(10+10) = 20
    
    - > document.write("10"+"10") = 1010
    
    + echo 10+10 = 20
    
    - > echo "10"+"10"= 20
    - -> PHP 에서는 + 기호, 연산자는 숫자를 더할 때 사용하는 연산자라는 고정된 의미를 가지고 있다
    - --> "10"+"10"이 문자로 인식되어도, 실수했다고 생각하고 자동으로 숫자로 변환한다
    - ---> "10"."10"은 1010으로 표시
    
    + Javascript는 문자와 숫자 모두 더할 때 +기호를 사용
    
    + PHP는 숫자를 더할 때는 + 문자를 더할 때는 . 기호 사용
    
    +Javascript와 PHP 모두 더하기는(+). 빼기는(-) 곱하기는(*) 나누기는(/)
    
- JS, PHP 프로그래밍 5 디버깅
    
    버그 : 프로그램이 오동작 하는 행위
    
    디버그 : 오동작 한 프로그램을 해결하는 행위
    
    +Javascript, html은 크롬의 개발자 도구->console (ctrl+shift+j) 메뉴 통해 버그 파일을 확인 가능하다
    
    + php는 아톰 기준, wampstack->apache2->logs 통해서 확인 가능하다
    
- JS, PHP 프로그래밍 5-2
    
    위 디버깅 수업의 보충. 버그 찾는 방법.
    
    (아톰 기준) wampstack -> php 파일에서
    
    display_errors = off -> on으로 변경
    
    - > 비트나미 메니저에서 아파치 웹 서버 리 스타트
    - -> 수정한 코딩이 저장되면서 php엔진에 반영
- JS, PHP 프로그래밍 6 변수
    
    + 변수 = 바뀔 수 있는 값.
    
    Javascript = name="이고잉";
    
    PHP = $name="이고잉";
    
    (변수 지정)
    
    +변수를 쓰는 이유는 여러가지가 있지만, 지금은 프로그램을 최대한 변경하지 않기 위해 변수를 쓴다는 점을 기억하자.
    
- JS, PHP 프로그래밍 7 비교
    
    +비교 기호
    
    + == (좌항과 우항이 같은가?) -
    
    - > 1==2 -> false
    - > 1==1 -> true
    
    + != (같지 않다)
    
    - > 1!=1 -> false
    - > 1!=2 -> true
    
    + > (왼쪽이 더 크다)
    
    - > 1>2 -> false
    - > 2>1 -> true
    
    + < (오른쪽이 더 크다)
    
    - > 1<2 -> true
    - > 2<1 -> false
    
    + Javascript 에서는
    
    - > doument.write(2==1);
    
    + PHP에서는
    
    - > var_dump(2==1);
    
    + 위의 4가지 항은 Javascript, PHP 모두 동일
    
    - > Javascript와 PHP 모두 비교의 값은 두 가지(true, false) 중 하나로 나온다
    - -> 그리고 이 두 값을 블리언(boolean)이라고 칭한다
- JS, PHP 프로그래밍 8 조건문
    
    조건문 : 어떠한 상황에 따라서 이렇게도 되고, 저렇게도 되는 것.
    
    +JavaScript
    
    if(true/false){1
    
    }else{2
    
    }
    
    - > true인 경우 1번 코드가 실행
    - > false인 경우 2번 코드가 실행
    
    + <h1>JavaScript</h1>
    
    <script>
    
    result = (1==2);
    
    if(result){
    
    document.write("참");
    
    } else {
    
    document.write("거짓");
    
    }
    
    </script>
    
    +PHP
    
    if(true/false){
    
    }else{
    
    }
    
    - > true인 경우 1번 코드가 실행
    - > false인 경우 2번 코드가 실행
    
    + <h1>php</h1>
    
    <?php
    
    $result = (2==2);
    
    if($result){
    
    echo "참";
    
    } else {
    
    echo "거짓";
    
    }
    
    ?>
    
- JS, PHP 프로그래밍 9-1 JavaScript 로그인 앱
    
    + prompt("비밀번호"); : 비밀번호 입력 창을 화면에 출력
    
    + password = prompt("비밀번호");
    
    document.write(password);
    
    - > 페이지 들어갈 때 입력한 비밀번호[prompt ("비밀번호")]
    - -> document.write(password)로 입력되어 페이지에 출력됨
    
    + password = prompt("비밀번호");
    
    if(password == 1111) {
    
    document.write("안녕하세요.")
    
    }
    
    else {
    
    document.write("잘못된 입력입니다.")
    
    }
    
    - > 비밀번호 1111입력하면 안녕하세요
    - -> 비밀번호 틀리면 잘못된 입력입니다. 출력
    
    + 코드는 확정되었고, 사용자가 입력하는 비밀번호 값에 따라 if문의 결과가 달라진다
    
- JS, PHP 프로그래밍 9-2-1 php 로그인 앱 소개
    
    +localhost/phpjs/8-1.php
    
    + 비밀번호 트루
    
    - > localhost/phpjs/8-2.php?password=1111
    - -> 안녕하세요
    
    + 비밀번호 거짓
    
    - > localhost/phpjs/8-2.php?password=1234
    - -> 잘못된 접근입니다.
    
    + 입력값에 따라 주소가 변한다.
    
- JS, PHP 프로그래밍 9-2-2 php 로그인 앱 구현
    
    <form action="8-2.php">
    
    <p>비밀번호를 입력해주세요.</p>
    
    <input type="text"name="password">
    
    <input type="submit">
    
    </form>
    
    + [http://localhost/phpjs/8.php](http://localhost/phpjs/8.php) 참조
    
    - > <p>비밀번호를 입력해주세요.</p> = 비밀번호를 입력해주세요. 출력
    - -> <input type="text"name="password"> = 네모난 페스워드 입력 칸
    - --> <input type="submit"> = 제출 칸
    
    + 제출 칸(<input type="submit">)을 누르면
    
    "submit"이 위치한 폼의 액션 값(<form action="8-2.php"> )
    
    으로 사용자가 입력한 정보(<input type="text"name="password">)를 전송하도록 되어있 다.
    
    + 사용자가 입력한 정보 중에 password의 값 = $_GET[password];
    
    + <?php
    
    $password = $_GET["password"];
    
    if($password=="1111"){
    
    echo "hello world";
    
    } else {
    
    echo "get out";
    
    }
    
    ?>
    
    + $password = $_GET["password"];
    
    - > 8-1.php 에서 사용자가 입력한 정보 $_GET["password"]
    
    = $password 일때
    
    - -> if($password=="1111") 페스워드는 1111이다
    - --> 사용자가 입력한 정보(비밀번호)가 1111이라면 hello world 출력
    - ---> 사용자가 입력한 정보(비밀번호)가 1111이 아니라면 get out 출력
- JS, PHP 프로그래밍 10 반복문
    
    조건문이 기계를 똑똑하게 하는 것이었다면, 반복문은 기계를 강력하게 하는 요소
    
    반복문 :
    
    + JavaScript
    
    - > while(true/false){}
    - -> 불리언의 정보가 true 라면{}안의 구문이 반복적으로 실행된다
    - --> 불리언의 정보가 false가 될 때 까지
    
    + <h1>JavaScript</h1>
    
    <script>
    
    i = 0;
    
    while(i<10){
    
    document.write("hello world<br />");
    
    i = i+1;
    
    }
    
    - > 현재 i의 값은 0
    - -> 0<10 (true)
    - --> hello world 실행
    - ---> 0+1 = i = 1
    - ----> 1<10 (true)
    - ----->반복하다가
    - -------> 10<10(false)
    - ---------> 반복문 종료
    
    + PHP
    
    - > while(true/false){}
    
    +
    
    <h2>php</h2>
    
    <?php
    
    $i = 0;
    
    while($i<10){
    
    echo "hello world<br />";
    
    $i = $i+1;
    
    }
    
    ?>
    
    +<br />
    
    - > 줄바꿈 테그
    
    + <h1>JavaScript</h1>
    
    <ul>
    
    <script>
    
    i = 0;
    
    while(i<10){
    
    document.write("<li>hello world</li>");
    
    i = i+1;
    
    }
    
    </script>
    
    </ul>
    
    - > 리스트
- JS, PHP 프로그래밍 11 배열
    
    +배열(Array)
    
    - > 변수 안에는 하나의 값만 담을 수 있지만, 배열은 서로 연관되어 있는 여러 정보들을 연속된 그릇에 담아 체계적으로 관리하는 도구
    
    +값과 값 사이에는 ,를 해서 문자를 배열로 만들어서 리스트에 담아주는 것.
    
    + JavaScript
    
    - > list=new Array("one","two","three");
    
    list[0];
    
    + <script>
    
    list = new Array("one","two","three");
    
    document.write(list[0]);
    
    </script>
    
    - > list = new Array("one","two","three"); =배열
    - -> document.write(list[0]); = 배열의 첫 번째
    
    (프로그래밍 언어는 0부터 카운트한다.)
    
    + document.write(list.length); = 베열이 총 몇 개 있는지 (위 배열에서는 3개)
    
    + PHP
    
    - > $list=array("one","two","three");
    
    $list[0];
    
    <?php
    
    $list=Array("one","two","three");
    
    echo $list[1];
    
    ?>
    
    - > 위와 동일
    - -> echo count($list); = 배열이 총 몇 개인지
    
    + 배열을 쓰는 이유는 다양하지만, 관계성 있는 정보들을 그룹핑을 해서,
    
    리스트라는 이름으로 그룹핑하는 것.
    
- JS, PHP 프로그래밍 12 배열과 반복문
    
    +JavaScript
    
    <script>
    
    list=new Array("최진혁","최유빈","한이람","한이은");
    
    i=0;
    
    while(i<4){
    
    document.write(list[i]);
    
    i=i+1;
    
    }
    
    </script>
    
    - > while(i<4) -> 4번 반복해서 실행
    - -> 반복할 때 마다 i는 1씩 증가
    - --> (list[i]) = list{0} - list{1} - list{2} - list{3}
    - ----> while(i<list.length) = Array의 배열값 만큼 실행
    
    +PHP
    
    <ul>
    
    <?php
    
    $list = array("최진혁","최유빈","한이람","한이은","이고잉");
    
    $i = 0;
    
    while($i < count($list)){
    
    echo "<li>".$list[$i]."</li>";
    
    $i=$i+1;
    
    } ?>
    
    </ul>
    
- JS, PHP 프로그래밍 13 함수의 기본 문법
    
    부품들(조건문, 반복문, 변수, 데이터, 배열 등)을 조합해서 하나의 프로그램을 만든다
    
    - > 프로그램을 만드는데 수 많은 부품들이 필요하고, 많은 부품들이 만들어내는 복잡성으로 프로그램이 더 많은 가능성을 가지는 데 한계가 나타난다
    - -> 기계의 한계가 아닌 사람의 한계
    - --> 복잡해지는 프로그램에 질서를 부여하기 위해 정리정돈의 기술을 발전시키게 된다
    - ---> 그 정리정돈의 기술이 곧 함수
    - ----> 부품들을 모아 하나의 완제품을 만드는 것이 곧 함수
    - ------> 그 함수가 하나의 부품이 되고, 함수들이 모여 하나의 함수가 되거나 제품이 될 수 있다
    
    +JavaScript
    
    function function_name(){}
    
    function_name();
    
    - > function(약속된 키워드)
    - -> function_name(name이 만들려고 하는 함수의 이름{아무 이름이나 상관 없다})
    - -->function_name() {}안에 있는 로직들을 실행하는 것
    
    +
    
    <script>
    
    function a() {
    
    document.write("hello Function");
    
    }
    
    a();
    
    </script>
    
    - > function = 함수의 시작을 알리는 코드
    - -> a = 함수의 이름
    - --> () =
    - --->{document.write("hello Function");} = 함수를 호출했을 때 실행되어야 하는 부분
    - ---->a(); = 함수를 호출하는 코드
    
    + 위의 코드에서 a(); 가 5번 반복되면 hello Function 5번 출력
    
    - > 반복문과 다른 점은 한 곳에서만 써야 하는 반복문과 달리 함수는 어디에서나 자바 스크립트를 정의하고 다시 호출할 수 있다
    
    +PHP
    
    function function_name(){}
    
    function_name();
    
    + <?php
    
    function a(){
    
    echo "Hello PHP Function";
    
    }
    
    a();
    
    ?>
    
    위와 동일
    
- JS, PHP 프로그래밍 14 함수의 입력과 출력
    
    <script>
    
    function a(input) {
    
    document.write(input+1);
    
    }
    
    a(5);
    
    </script>
    
    - > 5는 입력값. 함수를 정의할 때 사용하는 괄호 {(input)}이 된다
    - -> 위의 함수가 function a(5)가 된다는 의미
    - --> 다시 말해서, input은 변수
    - ---> document.write(input+1); = input이 5가 됐으므로, 위 값은 6이 되어 화면에 6이 출력된다
    
    +
    
    <script>
    
    function a(input) {
    
    return input+1;
    
    }
    
    document. write (a(6));
    
    prompt(a(6));
    
    </script>
    
    - > return = 반환값
    - -> return input+1; = 출력값
    - --> input이 6이었으니, 6+1=7 출력값.
    
    +prompt(a(6)); = 내장된 함수, 빌트인 함수
    
    + function a(input) {
    
    return input+1;
    
    }
    
    = 사용자 정의 함수
    
    + write (a(6)); = 빌트인 함수
    
    + 함수는 document(~), window(~) 등 연관되어 있는 것들을 묶는 단위가 있다.
    
    - > 여기서 document, window 등 그 단위를 객체라고 한다.
    
    +
    
    <?php
    
    function a($input){
    
    return $input+1;
    
    }
    
    echo a(6);
    
    ?>
    
    +php 함수. 위와 내용 동일.
    
- JS, PHP 프로그래밍 15 UI, API
    
    UI(User Interface) = 사용자가 직접 조작하는 인터페이스
    
    API(Application Programming Interface) = 애플리케이션이 무언가를 하기 위해서 프로그래밍적으로 그 애플리케이션이 돌아가는 시스템에게 전달하는 명령
    
    +prompt("비밀번호를 입력해주세요");
    
    - > prompt 명령어를 입력했으니 만들었지만,
    
    세부 창은 웹브라우저가 미리 만들어놓고 준비하고 있는 것이라고도 볼 수 있다.
    
    - -> prompt는 애플리케이션이 프로그래밍적으로 요청하는 것이니, API의 일종이다.
    
    + UI <- 웹 에플리케이션 <- 웹 브라우저 <- 운영체제 <- C와 같은 언어 <- 어셈블리어 <- 기계어(0,1) <- 전자공학(cpu,ram) <- 전기공학 <- 물리학
    
    - > 위쪽일 수록 [high Level Technology] 아래쪽일 수록 [Low Level Technology]
    - -> 각각의 층은 API를 통해 교류하고 있다
    
    + prompt 창은 웹 브라우저가 혼자 만드는 것이 아니라, 운영체제가 제공하는 작은 부품들
    
    ( x창, 확인과 취소 창, 네모 칸 등) 조립해서 만든 것이라고 할 수 있다.
    
    + 과거에는 API를 제공하는 시스템이 운영체제(Unix, Linux, Window) 정도만 있었다
    
    - > 어떤 소프트웨어를 만드는 것은 운영체제 위에서 직접적으로 돌아가는 어플리케이션을 만드는 것.
    - -> 그 중에 등장한 웹 브라우저는, 운영체제 입장에서는 운영체제 위에서 동작하는 일개 소프트웨어지만 동시에 스스로가 API를 가지고 있었기 때문에 웹 브라우저 위에서 동작하는 수많은 웹 어플리케이션들이 등장하게 되었다.
    
    + 현대에 이르러, API는 폭발적으로 증가하고, 프로그래밍이 언어의 발달에 따라 쉬워졌다.
    
- JS, PHP 프로그래밍 16 프로그래밍 접근 방법
    
    + 적정 용도의 언어를 적정 수준으로 배우는 것이 가장 먼저.
    
    + API를 탐험해 보는 것.
    
    + 직접 만들고, 공유하고, 한계를 느껴보는 것.
    
    + 부족한 부분을 오픈된 지식을 통해 배워보는 것.
    
    + Computational Thinking : 컴퓨터적 사고
    
    + 공부의 순서. -> 처음부터 알고리즘, 데이터 스트럭쳐, 디자인 패턴과 같은 학문적 성취를 공부하면 이해의 어려움도 있지만, 학문적 성취는 거대한 데이터를 효율적으로, 빠르게, 복잡함을 줄여 처리하기 위해서 발달된 성취이니 만큼 공감하기 어려울 수 있다. (방법을 고안하기 까지의 절망감을 공감할 필요가 있다.)
    
    + 무엇보다, 자신의 방법을 찾아라.
    
- JS, PHP 프로그래밍 1 JavaScript 실습
    
    + Javascript, HTML, CSS의 관계성을 알자.
    
    + Javascript가 HTML을 프로그래밍 쪽으로 제어하는 언어라는 것.
    
    + <input type="button" value="white" /> = 버튼
    
    <input type="text" value="white" /> = 타이핑할 수 있는 네모칸
    
    <input type="checkbox" value="white" /> 체크할 수 있는 박스
    
    - > <input> 테그란 사용자가 어떤 정보를 웹 애플리케이션에게 입력할 수 있는 장치들을 의미하는 테그
    - -> 타입 속성으로 무엇을 입력하느냐에 따라 달라진다.
    - --> <value> 테그는 색상.
    
    + <alert> 테그는 경고창을 표시할 때 사용하는 테그
    
    + <onclick> 테그는 사용자가 버튼(<input> 테그)을 눌렀을 때 그 뒤의 자바스크립트를 코드를 실행한다.
    
    - >( onclick="alert('hello world')"/>
    
    + 이벤트 프로그래밍.
    
    - > 이벤트는 웹브라우저의 입장에서, 사용자가 버튼을 클릭하거나, 스크롤을 움직이거나, 마우스를 움직이는 등의 사건을 의미한다.
    - -> 이벤트 프로그래밍은 이벤트가 일어났을 때 어떠한 코드가 실행되어야 한다는 것을 브라우저에게 명령해 놓는것.
    
    + <onclick> 테그 = 클릭을 했을 때
    
    + <onfocus> 테그 = 사용자가 포커스를 맞췄을 때
    
    - > <input type="text" onfocus="alert('focus')"/> = 텍스트 창에 마우스를 올려 활성화(포커스)가 되었을 때
    
    + <onblur> 테그 = 포커스가 해제되었을 때
    
    - > 이러한 이벤트 프로그래밍으로 사용자가 어떤 액션(이벤트)를 주면 그것에 따라 작성한 Javascript 코드가 실행되도록 프로그래밍 할 수 있다는 것.
- JS, PHP 프로그래밍 2 JavaScript 실습
    
    + <input type="text" id="user_input"/>
    
    <input type="button" value="white" onclick="alert(document.getElementById('user_input').value)"/>
    
    - > 텍스트를 입력할 수 있는 입력창을 만든다, 그 안에 입력하는 내용(id)는 "user_input"이라고 칭한다.
    - -> white라는 버튼을 만든다.
    - --> 그 버튼을 눌렀을 때(on click), 경고문(alert)을 띄운다.
    - ---> 경고문의 내용은 document.getElementById('user_input')
    - ----> getElementById(가져온다 테그 아이디값을 바탕으로). = 아이디값을 바탕으로 테그를 가져온다 <getElementById>는 고유한 내장 함수. (document에 속한)
    - -----> 가져오는 테그는 user_input (사용자가 텍스트 입력창 안에 입력한 내용)
    - ------> 사용자가 입력한 정보는 .value를 통해 알 수 있다.
    
    + localhost/javascript/1.html 참조
    
- JS, PHP 2-1 : php 환경 설정 변경
    
    php 설정 변경.
    
    + display_errors = off를 온으로
    
    - > 에러 디스플레이 켜기
    
    + opcache.enable=1을 0으로
    
    - > 오피캐시가 동작하지 않으면서, 수정한 코드가 바로바로 적응된다.
    
    + 실제 서비스 할 때는 둘 다 켜두는것이 성능, 보안적으로 더 좋다.
    
    + Bitnami WAMP Stack에서 아파치 웹 서버를 리스타트 함으로 위의 환경설정을 적응(저장)할 수 있다.
    
- JS, PHP 프로그래밍 3 JavaScript 실습
    
    +css가 HTML을 디자인하는 언어라면, Javascript는 HTML을 제어하는 언어이다.
    
    + class="XX"
    
    - > <class(그룸핑)> 테그. 뒤의 "xx"라는 이름으로 특정 코드들을 그룹핑 한다
    - -> .XX{} 테그를 통해 그룹핑 된 코드들에게 속성을 부여할 수 있다.
    - --> class="em" -> em{}
    
    + <style>
    
    .em{
    
    text-decoration:underline;
    
    }
    
    </style>
    
    - > 추후, "em"이라는 이름이 붙여진 클래스들에, 밑줄을 그어주는 CSS
    
    + <body>
    
    <ol id="target">
    
    <li>html</li>
    
    <li>css</li>
    
    <li>javascript</li>
    
    </ol>
    
    <ul>
    
    <li>최진혁</li>
    
    <li>최유빈 </li>
    
    <li>한이람</li>
    
    <li>한이은</li>
    
    </ul>
    
    <input type="button" value="강조"
    
    onclick="document.getElementById('target').className='em'"/>
    
    </body>
    
    - > <ol></ol> 테그 사이의 <li> 코드들에게 id값(target)을 준다.
    - -> 강조라는 이름이 붙여진 버튼 코드를 삽입한다.
    - --> 클릭시, 타겟이라는 이름이 붙여진 id값들에게 "em"이라는 클래스 값을 준다.
    
    [onclick="document.getElementById('target').className='em'"/]
    
    - ---> 강조 버튼을 누르면, em이라는 클래스 값이 새겨진 <ol>~</ol> 테그 사이의 코드들에게 밑줄을 긋는다.
    
    + localhost/javascript/2.html 참조
    
- JS, PHP 프로그래밍 4 JavaScript 실습
    
    + <div(division)>테그. : 테그와 테그를 그룹핑 해서 CSS적인 효과를 주기 위한 테그
    
    - > 아무런 특징이 없다는 특징이 있다. (<nav>,<ul>,<li>,<a> 이런 테그들과는 다르게,
    
    <div> 테그는 어떤 테그들을 묶어주는 기능만 있다.
    
    - ->
    
    <div id="control">
    
    <input type="button" value="white" />
    
    <input type="button" value="black" />
    
    </div>
    
    (위 버튼들을 "control"이라는 id로, div테그를 이용하여 묶은 뒤
    
    +CSS파일에서,
    
    #control{
    
    float:right;
    
    }
    
    테그를 사용하여 오른쪽으로 버튼들을 지정할 수 있다.
    
    +body{
    
    backgrond-color:black;
    
    color:white;
    
    }
    
    - > <body>테그 아래에 있는 모든 테그들에게 적용
    - -> 배경을 검정색으로
    - --> 글씨 색깔은 하얀색으로
    
    + index.html, page_1,2,3.html 참조.
    
- JS, PHP 프로그래밍 5 JavaScript 실습
    
    +실습은 난이도의 문제로 생략. 영상보고 이해만.
    
    + <script src="주소"></script>
    
    - > 주소에 있는 코드를 읽어서, 실행한다. (css분리와 유사)
    
    + HTML은 정보를 담당
    
    - > CSS는 HTML을 예쁘게 하는 디자인
    - > Javascript는 HTML을 프로그래밍 쪽으로 제어를 담당.
- HTML, CSS, JavaScript의 활용
    
    +DISQUS = 댓글 다는 기능을 추가할 수 있는 서비스(프로그램)
    
    - > DISQUS 페이지에서 소스코드를 복사해서 <articl>코드 안쪽(기능을 추가하고 싶은 곳)에 붙여넣기 하면 가능하다.
    
    +tack = 채팅기능을 추가할 수 있는 서비스(프로그램)
    
    - > Widget Code 코드를 복사하여, <body>코드 위에 붙여주면 이용 가능.

# PHP

- PHP 실습 1
    
    + 웹브라우저에서 php파일을 요청하면, 웹서버는 php엔진에게 위임.
    
    - > php엔진은 php파일을 읽어서 php코드를 해석한 뒤, 그 결과를 웹서버에게 전송
    - -> 웹서버는 받은 결과를 웹 브라우저에게 다시 전송.
    
    + 기존에는 웹브라우저에서 다수의 파일을 읽을 때, 수정사항이 있으면 다수의 파일을 모두 수정해야 했다. 즉, 중복의 발생.
    
    - > 이제부터, html과 정보를 분리해서, 정보는 text파일에 담고, html파일은 php파일 하나에 담도록 한다.
    - -> 사용자가 a.com/index.php?id=1을 입력하면, iindex.php파일이 1.txt파일에서 정보를 읽어, 웹브라우저에게 돌려주는 식.
    
    +정보로부터 중복이 되는 html을 제거해서, 정보만으로 이루어져 있는 파일을 만들어내는 것.
    
    + 단, 이 상황은 과도기. 궁극적으로는 데이터베이스 안에 모든 정보를 저장하여, index.php파일이 데이터베이스로부터 정보를 읽어 웹 브라우저에게 전송하는 방식을 목표로 하자.
    
    - > 데이터베이스는 하나의 소프트웨어, 그 역할은 데이터를 체계적으로 관리하고, 많은 데이터를 효과적으로 처리하고, 보안성이 높아 안전하게 보관할 수 있는 전용 소프트웨어.
- PHP 실습 2
    
    + <?php
    
    echo $_GET['id'];
    
    ?>
    
    - >?id=1 (1.php파일의 id라는 입력 값
    - -> 그 입력값을 알고 싶을 때, $_GET 라는 약속된 배열을 입력한다.
    
    + <?php
    
    echo $_GET['name'];
    
    ?>
    
    - > ?name=egoing (1.pgp파일의 name이라는 입력 값.
    - -> 입력값을 알기 위한 $_GET
    
    + <?php
    
    echo $_GET['id'].",".$_GET['name'];
    
    ?>
    
    - > id값과 name값등, 다수의 입력값을 알고 싶을때
    - -> 각각의 입력값 &_GET 사이에
    
    .",".
    
    를 통해 &의 효과를 줄 수 있다.
    
    + 웹브라우저 상에서, 주소창에서, 주소(localhost/php/1.php와 값(name=egoing&id=1) 사이를 구분할 때는 ?를 사용한다
    
    - > 값과 값 사이를 구분할 때는 &를 사용한다.
    
    + echo file_get_contents("읽어오고 싶은 파일")
    
    - > php파일이 읽어오고 싶은 파일을 읽어서, 함수(file_get_contents)의 리턴값으로 돌려주는 것.
    
    + echo file_get_contents($_GET['id'].".txt");
    
    - > 위의 내용처럼 개별의 파일을 읽을 수 있지만, $_GET['id']."를 통해서 사용자가 입력한 값에 따라 가변적인 리턴값을 줄 수 있다.
- PHP 실습 3
    
    index.php파일 안의 정보
    
    <li><a href="http://localhost/page_1.html">javascript란?</a></li>
    
    <li><a href="http://localhost/page_2.html">변수와 상수</a></li>
    
    <li><a href="http://localhost/page_3.html">연산자</a></li>
    
    를 list.txt 파일 안에 두고,
    
    > <?php
    > 
    
    echo file_get_contents("list.txt");
    
    ?>
    
    를 통해 읽어오기만 함으로써, 코드와는 별개로, 정보의 수정이 필요할 때 코드를 변경하지 않고 정보만을 변경할 수 있다
    
    - > index.php파일의 수정 필요성이 작아진다.
- PHP 실습 4
    
    + index.php 파일 안의 정보를 1,2,3txt파일로 옮긴다.
    
    + 그 후,
    
    <?php
    
    echo file_get_contents($_GET['id'].".txt");
    
    ?>
    
    코드를 통해 각각의 id입력값에 따라 정보를 가변적으로 읽어낼 수 있게, 작성한다.
    
    +그 후, list.txt 안의 링크를
    
    [http://localhost/index.php?id=1,2,3](http://localhost/index.php?id=1,2,3) 으로 수정하면
    
    - > 각각의 링크에 맞는 1,2,3.txt 파일을 읽어내도록 수정할 수 있다.
    
    +단, 이 경우 JavaScript, 대문을 눌렀을 때, php?id 값이 없는 경우(id값이 없는 경우)가 되기 때문에, 오류가 생길 수 있다. 그렇기에
    
    <?php
    
    if(empty($_GET['id']) == false) {
    
    echo file_get_contents($_GET['id'].".txt");
    
    }
    
    ?>
    
    함수를 통해 조건문 id값이 없을 때,{if(empty($_GET['id]} 뒤의 구문
    
    echo file_get_contents($_GET['id'].".txt");
    
    을 읽으려는 시도를 하지 않게 된다. = 오류가 생길 위험을 없앤다.
    
    + 이전의 HTML파일들이 모든 정보를 하나하나의 파일에 담겨 있었지만,
    
    이제는 index.php 파일을 하나로 두고, 각각의 정보를 .txt파일에 둠으로서 읽어내기만 할 수 있다.
    
    + <img src="" alt="">
    
    테그를 통해 src=""의 따움표 안에 이미지의 UPL주소를 복사붙여넣기를 통해 넣음으로서
    
    모든 파일 안에 이미지를 삽입할 수 있다.
    
    + php의 본질적인 힘은 중복을 제거하는 것에 있다.
    
    - > 프로그래밍, 정보기술은 전자화된 시스템 위에서 동작하기에 HTML, CSS, Javascript를 하나 만들고
    
    그 하나를 여러 곳에서 동시에 가져다 쓰는 것, 중복의 제거가 가능하다.
    

# 데이터베이스(MySQL)

- 데이터베이스(MySQL) 이론 1
    
    + 데이터베이스 : 정보를 관리하는 전문 에플리케이션
    
    - > HTML이 중요한 것은 그것이 정보를 표현하는 것이기 때문
    - -> CSS, Javascrip도 정보를 표현하기 위한 기술적 구성들, 즉 수단
    - --> 즉, 정보가 위치하는 데이테베이스가 가장 중요하다고 할 수 있다.
    
    + 파일 : 가장 기본적이ㅗ 원시적인 형태의 데이터 관리 수단
    
    - > 어느 시스템에서나 쓸 수 있고, 설치할 필요도 없고 심플하며, 이해하기 어렵지 않다
    
    + 데이터베이스 : 공부도 해야 하고, 설치도 필요 하고, 어려운 등의 단점이 있다.
    
    - > 그러나 궁극적으로 에플리케이션을 만들기 위해서는 데이터베이스를 이용해야 한다.
    - -> 장점으로는
    
    1. 안전하다 : 파일은 누구라도 그 파일의 내용을 확인할 수 있지만, 데이터베이스는 금고와 같은 역할을 한다. 누군가가 무단으로 보지 못 하게 할 수 있고, 시스템의 고장 상황에서 정보를 백업하는 시스템을 가지고 있기에 안전하다.
    
    2. 빠르다 : 인덱스(index), 섹인을 통해서 정보를 빠르게 찾을 수 있도록 정리를 한다.
    
    3. 프로그래밍적 제어가능 : SQL을 이용해서 프로그래밍적으로 제어가 가능하다.
    
    + 가장 보편적으로 사용되고, 성공적인 데이터베이스 모델은 관계형 데이터베이스
    
    - > MySQL, MS-SQL, Oracle등이 있다.
    - -> 그중에서 MySQL을 이용해서 데이터베이스 시스템을 배울 것. (MySQL을 배우면 다른 제품들도 배우기 쉬워진다.)
    
    + MySQL은 WEB과 함께 성장한 데이터베이스. 오픈 소스로 개발된 데이터베이스.
    
    - > 제품의 주인은 MySQL AB -> SUN -> Oracle
    - -> Orcle의 정책에 대한 반발로 나온 MySQL의 개발자들이 만든 새로운 데이터베이스가 MariaDB
    - --> MySQL은 MariaDB와 완전히 호환된다.
    
    + Structured : 구조화된. 데이터베이스를 이해하는데 있어 핵심적인 키워드
    
    - > 정보를 좀 더 정돈 된 상태로 하는 것. 표(table) 같은 것. EXCEL같은 것.
    
    + 본격적인 데이터베이스와 엑셀의 차이는 SQL에 있다.
    
    - > SQL(structured Query Language) -> (컴퓨터에게) 구조화 된 (정보를) 질의하는 (프로그래밍 된) 언어.
    - -> MySql, Ms-SQL, Oracle은 모두 SQL이라는 표준화된 프로그래밍 언어를 구현하고 있기에 동일한 SQL을 통해서 시스템을 제어할 수 있다.
    
    + MySQL Client와 MySQL Server가 설치된 두 대의 컴퓨터가 있을 때, 전자를 클라이언트 컴퓨터, 후자를 서버 컴퓨터라 할 수 있다. (웹 뿐만 아니라 데이터베이스 시스템에서도 서버와 클라이언트의 개념은 존재한다.)
    
    - > 클라이언트에서 SELECT*FROM topic; 이라는 명령을 실행 하면 서버 컴퓨터에게 전달된다. 여기서 명령을 SQL이라고 한다.
    - -> 정보를 받은 서버 컴퓨터가 표로(구조화된) 정보로 다시 응답해주는 관계가 데이터베이스 시스템이 동작하게 된다는 것.
    
    + 웹브라우저가 [http://a.com/a,php를](http://a.com/a,php%EB%A5%BC) 입력하면 웹서버는 PHP를 처리할 수 없기에 PHP엔진에게 요청한다. PHP엔진은 a.php코드를 해석하는데, 그 과정에서 데이터베이스에 접속해서 정보를 가져오라는 SQL문(코드)가 들어가 있다면, PHP엔진은 데이터 베이스 서버에 접속해서 질문한다. 그러면 MySQL 서버는 그것에 해당하는 정보를 PHP 엔진에게 전달, 다시 웹 서버에게 전달, 다시 웹 브라우저에게 전달
    
    + 웹 브라우저 -> 웹 서버 -> PHP -> MySQL -> PHP -> 웹서버 -> 웹브라우저
    
    - > PHP는 Client, MySQL은 Server가 된다. (Client와 Server의 역할은 웹에만 국한되는 관계가 아니다)
- 데이터베이스(MySQL) 이론 2
    
    + 인터넷, 네트워크와 같은 것들이 관련되어 있다면 대부분 서버와 클라이언트라는 관계, 체게 위에서 동작한다.
    
    + MySQL의 핵심적인 부분은 정보를 어떻게 잘 관리하느냐 라는 서버의 역할에 있다.
    
    + MySQL의 클라이언트도 여러가지가 있지만, 수업에서는 MySQL monitor라는 프로그램을 사용할 것.
    
    - > MySQl monitor는 MySQL을 설치하면 기본적으로 같이 설치되며, 가장 표준적인 클라이언트.
    - -> 단점은 명렁어를 통해서 데이터베이스를 제어하는 방식을 이용하기에 난이도가 있다.
    
    + 윈도우+R 통해서 실행 메뉴 -> cmd 통해서 명령 프롬포프트 진입. -> 비트나미 설치 폴더에 있는
    
    - > C:\Bitnami\wampstack-8.1.1-0\mariadb\bin
    - > 진입. mysql 파일 속성의 위치(디렉토리) 복사하여 cd C:\Bitnami\wampstack-8.1.1-0\mariadb\bin 입력
    - > mysql -hlocalhost -uroot -p 입력
    - > enter password에서 비밀번호(kn6868595)입력
    - > welcome to the MariaDB monitor. 출력되면 MariaDB monitor 이용해서 서버에 접속 한 것.
    
    + 접속 과정에서 사용한 명령어들
    
    1. mysql = MySQL monitor라는 프로그램을 실행 시키겠다는 의미
    
    2. -hlocalhost = -h 뒤에 따라오는 것이 MariaDB server(MySQL server)의 주소라는 의미
    
    - > localhost라고 입력하는 것은 MySQL monitor가 설치되어 있는 컴퓨터에 같이 설치 되어 있는 MySQL server에 접속하겠다는 것.
    - -> server와 monitor가 다른 컴퓨터에 설치되어 있다면, -hopentoturial.org 이런 식으로 입력하는 것.
    
    3. -uroot = -u 뒤에 따라오는 것이 관리자 아이디라는 의미.
    
    4. -p = 비밀변호를 입력 받으라는 의미.
    
- 데이터베이스(MySQL) 이론 3
    
    + MySQL Server 안에 DATABASE 안에 Table들이 표의 형태로 저장된다.
    
    - > 비유하자면 Table은 컴퓨터 안의 파일들.
    - -> 파일들이 많아지면 파일을 담는 디렉토리, 폴더가 필요한데, DATABASE가 그 역할을 한다.
    - --> 웹 애플리케이션 하나가 데이터베이스 하나를 갖게 된다고 생각하자.
    
    + show database;
    
    - > 현재 접속한 서버에 존재하는 데이터베이스를 확인하는 명령어
    
    + create DATABASE opentutorials CHARACTER SET utf8 COLLATE utf8_general_ci;
    
    - > opentutorials(폴더이름). utf8(문자열 이름). CHARACTER SET utf8 COLLATE utf8_general_ci(입력하는 정보가 어떤 방식으로 문자로 기록되는지 나타내는 것.)
    - -> 데이터베이스를 만드는 명령어
    - --> 문법적인 것은 대문자로, 문법적인 것이 아니면 소문자로.
    
    + 데이터 베이스 안으로 들어가서 작업을 할 것인데, 이는 파일을 작업하려면 파일이 있는 디렉토리(폴더) 안으로 들어가서 해야하는 것과 같다.
    
    + use opentutorials; = opentutorials 라는 이름을 가진 데이터베이스를 사용하겠다는 것.
    
    - >Database changed 라고 나온다.
    
    + CREATE TABLE `topic` (
    
    `id` int(11) NOT NULL AUTO_INCREMENT,
    
    `title` varchar(100) NOT NULL,
    
    `description` text NOT NULL,
    
    `author` varchar(30) NOT NULL,
    
    `created` datetime NOT NULL,
    
    PRIMARY KEY(id)
    
    ) ENGINE=InnoDB DEFAULT CHARSET=suf9;
    
    CREATE TABLE : 테이블을 만든다.
    
    `topic` : ``안에 있는 텍스트가 문법적인 것이 아니라는 것을 데이터베이스 서버에 알려주기 위한 것. topic은 테이블 이름
    
    `id` : 컬럼의 이름 (컬럼은 테이블에서 특정한 단순 자료형의 일련의 데이터값과 테이블에서의 각 열을 의미한다.)
    
    int(INTEGER) : 정수, 숫자.
    
    'id' int(11) : id는 숫자가 와야한다는 것을 강제하는 의미.
    
    NOT NULL : 반드시 앞의 정보가 존재해야 된다는 의미.
    
    AUTO_INCREMENT : 행이 추가될 때마다 자동으로 숫자를 1씩 올려준다는 의미
    
    `title` varchar(100) : `title`에 들어가는 정보가 100글자 안쪽의 정보라는 의미. 100글자를 넘어가면 잘라낸다.
    
    `description` text : `description` 컬럼에 들어오는 정보는 긴 텍스트를 받을 수 있어야 된다는 의미.
    
    `author` : 작자라는 의미. (누가 작성했느냐(
    
    `created` datetime : 시간과 날짜
    
    PRIMARY KEY(id) : 성능을 위해서 사용하는 옵션, 중요하지만 지금은 넘어간다.
    
    + show tables; = 위에서 만든 테이블을 보여달라는 의미.
    
    + 엑셀과의 차이는, 엑셀에서는 id 값에 사용자가 무엇이든 입력할 수 있지만,
    
    - > 위에 int(11) 값을 입력한 이상, 데이터베이스에서는 숫자(정수)가 아니면 입력을 받지 않는다.
    - -> 데이터베이스의 중요한 특징은 엄격하다는 것.
    - --> 추후 조건문으로 정보를 추가하지 않고, 데이터베이스 단계에서 정보를 확신할 수 있다는 것.
    
    + 데이터베이스의 미덕은 엄격함에 있다.
    
    + 데이터베이스 시스템에서 행을 추가한다는 것은 정보를 입력한다는 것. 열(컬럼)이 추가된다는 것은 구조가 추가된다는 것.
    
    + INSERT INTO `topic` (title, description, author, created) VALUES('about javascript', 'javascript is ~', 'egoing', '2022-1-28 12:18:5');
    
    INSERT : 정보(title, description, author, created) 를 테이블에 추가한다.
    
    INTO `topic` : `topic`에 추가한다.
    
    문자를 입력할 때는 '' 단따움표.
    
    컬럼의 이름, 테이블의 이름을 입력할 때는 `` 그레이브 엑센트
    
    VALUES() : 앞의 정보 안에 입력할 값. 단, 입력할 때 앞에 입력한 순서에 맞춰 적는다.
    
    + SELECT * FROM topic; {중요}
    
    SELECT : 가져오려고 하는 데이터가 무엇인지 선택한다는 의미
    
    - : 알고 싶은 컬럼을 의미한다. *은 모든 컬럼 -> title과 author만 알고 싶다면
    - > SELECT title, author FROM topic;
    
    FROM topic; : topic 테이블에서 가져오겠다는 의미.
    
    + 위쪽 화살표 키를 키보드에서 누르면 이전에 입력했던 정보들이 나타난다.
    
    + where id=3; = id가 3인 행(id)을 가져온다.
    
    + ORDER BY id DESC; = 큰 숫자부터 가져온다.
    
    + ORDER BY author DESC; = author 중심으로 정렬해서 가져온다.
    
    + delete from topic where id='1' -> topic 안에 있는 id=1을 삭제한다.
    
- MySQL 실습 1 : PHP와 연동
    
    + PHP 엔진이 웹서버와 MySQL 사이에서 중개자 역할을 한다. 그런 맥락에서 미들웨어라고 부르기도 한다.
    
    - > PHP가 그런 역할을 하기 위해서 mysqli라고 하는 PHP에 내장되어있는 API를 사용해서 할 수 있다.
    
    + 데이터베이스를 다루는 코드는 복잡하고 여러 문제 상황들이 발생할 수 있으니, error.log 파일을 통해서 계속 확인하면서 진행하는 과정이 필요하다.
    
    + MySQL monitor와 mysqli는 본질적인 역할(데이터베이스 서버에게 무언가를 요청하는 클라이언트) 은 같다. MySQL monitor는 일반적인 프로그램, mysqli는 API라는 차이가 있을 뿐.
    
    + 데이터베이스 클라이언트가 데이터베이스　서버에　접속해서　어떤　일을　처리할　때　일어나는　작업들을　순차적으로　나열한　것．
    
    ＝　서버　접속　－＞　ＤＢ　선택　－＞　조회　－＞　출력
    
    + MySQL monitor
    
    1. 서버 접속 : mysql -hlocalhost -uroot -p111111;
    
    - > localhost에 존재하는 서버에 접속할 때, 아이디 값은 "root" 비밀번호는 "111111"인 사용자의 명의로 접속하겠다는 의미.
    
    2. DB 선택 : mysql> use opentutorials;
    
    - > opentutorials라는 이름의 데이터베이스를 사용하겠다는 명령.
    
    + mysqli
    
    1. 서버 접속 : $conn = mysqli_connect("localhost". "root", "111111");
    
    - > conn(connect)
    - -> mysqli_connect() : PHP에 내장되어 있는 함수. 이후 호스트 서버, 아이디, 비밀번호
    
    2. DB 선택 : mysqli_select_db($conn "opentutorials");
    
    - > $conn = 위의 서버 접속 함수를 통해 접속에 성공했고, 접속된 정보를 conn이라는 변수에 담은 것. 그 정보를 mysqli_select_db 함수의 첫 번째 인자로 전달해 주도록 약속되어 있다.
    - -> 사용하려고 하는 데이터베이스의 이름(opentutorials)을 담으면 된다.
- MySQL 실습 2 : 리스트 출력하기
    
    위의 연속.
    
    + MySQL monitor
    
    3. 조회 : mysql> SELECT*FROM topic;
    
    - >topic 테이블에 있는 모든 컬럼의 정보를 가져온다는 명령어.
    
    4. 출력 : 받은 정보를 화면에 출력한다.
    
    + mysqli
    
    3. 조회 : $result=mysqli_query($conn, "SELECT * FROM topic");
    
    - > mysqli_query 함수를 입력 후, 함수의 첫 번째 입력값은 서버 접속 과정에서 입력한 $conn 변수. 그 다음 SQL문인 select * from topic
    - -> SQL문인 select * from topic을 데이터베이스에게 전송하면 데이터베이스는 처리 후 다시 PHP에게 돌려주게 되는데, 그것을 "result"라는 변수에 담도록 되어있다.
    
    4. 출력 :
    
    $row = mysqli_fetch_assoc($result);
    
    $row["title"];
    
    $row["description"];
    
    - > mysqli_fetch_assoc이라는 함수를 이용해서, 함수의 입력값으로 조회 과정에서 질의한 ("SELECT * FROM topic"); 결과를 입력 값으로 내주는 것.
    - -> 그러면 그 실제 데이터가 $row라는 변수에 담기게 되어있다.
    - --> fetch = 가져온다는 의미
    - ---> 위 함수에 echo 값을 준 뒤 실행하면 하나의 값만 나오게 된다. 다음 행도 나오게 하고 싶다면, 동일하게 함수를 복사해서 붙여넣거나(단, 이는 코드의 중복)
    
    + while($row = mysqli_fetch_assoc($result)){
    
    echo $row['id'];
    
    echo $row['title'];
    
    echo "<br/>";
    
    }
    
    - > 위처럼, 반복문을 통해 실행하면 된다.
    - -> 반복문은 ($row = mysqli_fetch_assoc($result)) 값이 true인지 false인지를 확인한다.
    - --> ture라면 밑의 echo문이 실행이 되어 출력되고, false(더이상 읽어올 데이터가 없다면)라면 echo문을 실행하지 않고 반복문을 종료하게 된다.
    
    + 연관 배열(associative array) : 어떤 값에 이름을 주며 배열하는 것.
    
    - > 0,1,2 식으로 숫자로 하는 배열과 달리, 각각의 값에 이름(title, description 등)을 부여하고, 그 이름에 맞춰 배열하는 것.
    
    + var_dump($row);
    
    - > 입력값($row)으로 들어온 데이터가 무엇인지를 정확하게 알려주는 내장 함수
    - -> 위 코드에서 id값이 총 3개 있는데, 동일한 함수를 4번 입력하면 NULL (값이 없다) 가 나오게 된다.
    
    + PHP에서 NULL은 false라는 의미도 암시적으로 가지고 있다.
    
    - > PHP는 어떤 값이 존재한다는 것, false가 아닌 것은 ture로 간주하는 특성이 있다.
    
    + "\n(atom에선 역슬래시로 출력)" = 줄 바꿈을 하라는 약속된 기호.
    
    ++
    
    <?php
    
    while($row = mysqli_fetch_assoc($result)){
    
    echo '<li><a href="http://localhost/index.php?id='.$row['id'].'">'.$row['title'].'</li></a>'."\n";
    
    }
    
    ?>
    
    - > PHP 구문. 위의 총 정리.
    
    index.php 파일 참고.
    
- MySQL 실습 3 : 상세 정보 출력하기
    
    <?php
    
    if(empty($_GET['id'])===false){
    
    $sql = 'SELECT * FROM topic WHERE id='.$_GET['id'];
    
    $result = mysqli_query($conn, $sql);
    
    $row = mysqli_fetch_assoc($result);
    
    echo '<h2>'.$row['title'].'</h2>';
    
    echo $row['description'];
    
    }
    
    ?>
    
    - > 이전의 연속. 이 부분은 숙달이 필요할 듯.
    - -> 솔직히 잘 이해가 가지 않는다. 명령문과 함수를 외우고 이해하는 과정이 필요할 것 같다. 이 부분은 시간이 필요할 것 같다.
    
    +css가 반영이 늦을 때는 웹 페이지에서 ctrl + f5로 css 캐시 데이터를 삭제 해 보자
    
- MySQL 실습 4 : form
    
    Form(폼) : 사용자가 입력한 정보를 서버로 전송하는 수단.
    
    + <input type="text"> : 텍스트필드. (사용자가 정보를 입력할 수 있는 UI)
    
    + <textarea></textarea> : 본문처럼 많은 내용을 입력할 수 있는 텍스트 필드
    
    + <p></p> : paragraph(파라그래프,단락). 사이에 있는 코드들이 개별의 단락이 된다.
    
    + <input type="submit"> : 보내기 버튼. '제출' 버튼을 눌렀을 때 사용자가 입력한 정보를 서버로 전송하도록 하는 역할의 버튼.
    
    - > 단, 위 코드만으로는 어디로 보내야할지가 정해지지 않았기에 작동하지 않는다. 이 때 사용하는 테그가 <form> 테그.
    - -> (<form action="주소" method="GET"></form>)
    
    + <form action="http://localhost/php/3.php" method="GET">
    
    <p> 제목 : <input type="text" name='title'> </p>
    
    <p> 본문 : <textarea name="description"></textarea> </p>
    
    <input type="submit">
    
    </form>
    
    + action = submit버튼을 사용자가 눌렀을 때, form으로 감싸져 있는 테그들(control) 입력된 정보를 action속성에 지정된 애플리케이션(주소)에 전송한다는 뜻.
    
    + method = 정보를 뿌리는 방식을 어떻게 할 것인가. (GET, POST)
    
    + URL의 길이는 제한 표준이 있다.
    
    - > 긴 정보는 URL 입력 값을 통해서는 전송할 수 없다.
    - -> 이때는 앞의 method="GET"을 method="POST"로 변경하면 된다.
    - ---> php파일도 echo $_GET['title']을 echo %_POST['title']로 변경해야 한다.
    
    + <?php
    
    echo $_POST['title'];
    
    echo "<br>";
    
    echo $_POST['description'];
    
    ?>
    
    - > 앞의 text파일에서 전송받는 위치인 php파일
- MySQL 실습 5 : 굴착성
    
    + 수업의 목표는 전송된 정보를 받아서 실제 데이터베이스에 저장, 수정, 삭제하는 과정., 그 중에서도 데이터를 추가하는 방법에 대해 알아보도록 한다.
    
    + index.php 파일에 <a href="http://localhost/write.php">쓰기</a> 테그<div></div> 사이에 추가
    
    + 파일을 그대로 복사하여 위 링크의 write.php 파일 생성
    
    - > 내용을 대체할 <article></article> 사이의 php 구문 삭제 후
    - -> <form action="process.php" method="post"> 코드 추가. ( 사용자가 입력한 정보를 process.php라는 php 에플리케이션으로 전송하여, 사용자가 입력한 정보를 처리하도록 한다. 방법은 post)
    
    + 그 밑으로
    
    <p>
    
    제목:<input type="text" name="title">
    
    </p>
    
    <p>
    
    작성자:<input type="text" name="author">
    
    </p>
    
    <p>
    
    본문:<textarea name="description"></textarea>
    
    </p>
    
    <input type="submit" name="name" >
    
    구문 추가.
    
    + 그 후, 제출한 정보를 받을 (write.php 파일의 <form action="process.php" method="post"> 구문) process.php 파일 생성.
    
    + process.php
    
    <?php
    
    $conn = mysqli_connect("localhost", "root", "kn6868595");
    
    mysqli_select_db($conn, "opentutorials");
    
    $sql = "INSERT INTO topic (title,description,author,created) VALUES('".$_POST['title']."', '".$_POST['description']."', '".$_POST['author']."' ,now())";
    
    $result = mysqli_query($conn, $sql);
    
    header('Location: http://localhost/index.php');
    
    ?>
    
    내용의 흐름
    
    + 사용자가 index.php에서 "쓰기" 버튼을 누르면 index.php에 코딩된 링크에 따라 write.php로 이동하게 된다
    
    + 사용자가 write.php에 입력된 코드에 따라 나타난 텍스트 박스 "제목, 작성자, 본문"에 내용을 입력한 뒤, 제출(submit) 을 누르면
    
    + wirte.php에 작성된 코드(<form action="process.php" method="post">) 에 따라, 제출된 정보는 process.php로 이동된다.
    
    + 유저가 작성한 정보는 process.php 파일의 코드에 따라 localhost의 데이터베이스에 저장되게 된다.
    
    + 그 후, redirectuin 명령어인 header('Location: [http://localhost/index.php](http://localhost/index.php)'); 에 따라 index.php로 다시 돌아가게 된다.
    
    + now() : my SQL이 제공하는 함수*API)
    
    - > () 안에 현재 시간이 들어오는 역할을 한다.
    
    + redirection [header('Location: 주소'); ]
    
    - > header() 함수.
    - > 사용자가 원하는 주소로 돌아가게 한다.

# 활용 및 보안

- 활용, 이미지를 업로드해서 첨부하기 (uploadcare)
    
    + UPLOADCARE : 사진 첨부를 도와주는 프로그램.
    
    - > 서비스가 중요하기보다는, 이런 프로그램, 부품을 결합해서 에플리케이션을 만드는 코딩의 힘을 느끼는 것이 중요하다.
    - -> [https://uploadcare.com](https://uploadcare.com/)/
    - --> 회원 가입 후 무료이용, 단 일정 범위(용량) 이후 과금 필요
    - --->페이지의 Integration 밑에 있는 코드를 어플리케이션에 삽입하면 통합이 된다.
- 보안 1
    
    + 정보 비지니스의 핵심은 데이터며, 정보기술을 만드는 목적도 데이터 자체라고 할 수 있다.
    
    - > 서버는 데이터가 있는 집이며, 서버에 접속할 때는 늘 조심해야 한다.
    - -> 서버에서의 실수는 돌이킬 수 없기 때문이다.
    
    + 보안이란 담당자 혼자서 잘 할 수 있는 것이 아닌, 영향을 받는 모든 구성원과 체계들이 협조했을 때 달성할 수 있는 목표.
    
- 보안 2
    
    + localhost/write.php 웹페이지에서
    
    <script>
    
    merong
    
    </script>
    
    코드 입력시 그대로 출력된다.
    
    - > 자바스크립트는 자유도가 무척 높아, 컴퓨터의 정보를 탈취 해 자신들의 서버로 보낼 수 있는 능력이 있다.
    - -> 해킹, 피싱의 위험성이 크다.
    - --> 사용자가 등록한 정보 안에서는 스크립트 코드를 입력하지 못 하게 하거나, 입력한 정보를 HTML로 그대로 표현하게 하는 방식 등으로 방지할 수 있다.
    
    + [https://dev.w3.org/html5/html-author/charref](https://dev.w3.org/html5/html-author/charref)
    
    - > <>. ; 과 같은 프로그래밍적 기호들을 화면상에 코드가 아닌 상태로 출력하기 위한 명령어들을 모아둔 곳.
    
    < = $lt; , >&gt; 와 같은 식.
    
    - -> 다만, 이와 같은 방식은 번거롭기에
    
    <?php
    
    echo htmlspecialchars("<a>");
    
    ?>
    
    처럼, htmlspecialchars() 라는 php 내장함수를 통해 입력할 수도 있다.
    
    + 이는 보안을 위한 중요한 방법론 중 하나.
    
    - > 자바스크립트 코드로 입력해도 실행되지 않고, 코드 내용이 그대로 출력되게 된다는 것.
    
    + index.php 에서
    
    <?php
    
    while($row = mysqli_fetch_assoc($result)){
    
    echo '<li><a href="http://localhost/index.php?id='.$row['id'].'">'.$row['title'].'</a></li>'."\n";
    
    }
    
    ?>
    
    코드가 사용자가 "쓰기"를 통해서 입력하는 정보에 해당하는 부분.
    
    + 단, 여기서 $row['id'} 부분은 앞서 명령 프롬포트를 통해 데이터베이스를 구축할 때, autoincrement 함수를 통해 시스템이 생성한 정보기에 수정할 필요가 없다.
    
    + 하지만, ['title'], 뒤의 ['description']과 같은 부분은 사용자가 직접 입력한 정보이기에, htmlspecialchars를 통해 보안을 추가할 필요가 있다.
    
    - > 그러나, 이렇게 모든 컬럼들을 htmlspecialchars() 함수로 감쌀 경우, 본문의 코드들도 코드 형식으로 출력이 된다.
    - -> 이 때 strip_tags (HTML은 허용하고, 스크립트 태그를 지울 때 사용하는 함수) 를 사용해서 문제를 해결할 수 있다.
    
    = echo strip_tags($row['description']);
    
    - > ['description'] 컬럼 안에 있는 정보를 일거서 출력할 때, HTML 정보만 허용하고 스크립트 태그는 출력하지 마라.
    - -> 다만 이 경우 모든 테그들이 허용이 되지 않고 삭제되기 때문에, 허용할 테그들만을 출력할 것을 정할 수 있다.
    - --> echo strip_tags($row['description'], '<a><li><ol><ul><h1><h2>');
    
    와 같은 식으로, 허용할 테그들만을 뒤에 후술함으로써 기능을 이용할 수 있다.
    
    + 이럴 경우, Security 창을 진입할 시, <alert> 테그는 허용되지 않았기에 팝업창이 작동하지 않고, 코드로 작성되어 있는 것을 확인할 수 있다.
    
    + 이와 같은 일련의 과정을 escaping 이라고 한다.
    
    + php.net
    
    - > php의 함수들을 정리해둔 곳.
- 보안 3
    
    + cmd에서
    
    SELECT * FROM user;
    
    를 통해 유저 목록을 불러올 수 있다. ( 컴퓨터에서는 장문의 에러가 뜨면서 확인 못 함. 해결방법 아직 못 찾음)
    
    + SELCT * FROM user WHERE name="egoing" AND password="111111";
    
    을 통해 "egoing" 이라는 이름과 "111111"이라는 비밀번호를 가진 유저만 가져올 수 있다.
    
    - >둘 중 하나라도 틀리면 읽어내지 못 한다.
    - -> 이를 통해서 로그인 어플리케이션을 만들 수 있다.
    
    + 14.php 파일 생성 (phpjs 디렉토리)
    
    - >기존의 8-1.php 파일 복사 후 데이터베이스 관련 코드 추가
    
    <?php
    
    $conn = mysqli_connect("localhost", "root", "kn6868595");
    
    mysqli_select_db($conn, "opentutorials");
    
    $sql = "SELECT * FROM user WHERE name='".$_GET['name']."'AND password='".$_GET['password']."'";
    
    echo $sql;
    
    $result = mysqli_query($conn, &sql);
    
    var_dump($result->num_rows);
    
    ?>
    
    - > 사전에 입력한 비밀번호인 "1111"이 입력되면 hello world, 틀리면 get out 출력
    - > 비밀번호가 맞으면 var_dump로 리졸트가 1, 하나의 행을 리턴, 성공
    - -> 비밀번호가 틀리면 int(0)으로 실패, 데이터서버에 없다.
    - ---> $result = mysqli_query($conn, &sql); 입력시 오류 발생하며 읽어내지 못 하는 현상 발생.
    
    $result = mysqli_query($conn, "SELECT * FROM topic"); 가 아니면 읽어내지 못 함.
    
    + <?php
    
    if($result->num_rows=="1"){
    
    echo "hello world";
    
    } else {
    
    echo "get out";
    
    }
    
    ?>
    
    - > int(1)이 나오면 (ture) "hello world"
    
    나오지 않으면 "get out"
    
    - --> int(8)로 고정되는 현상 발생.
    - ---> 해결 못 함.
    
    + CMD에서,
    
    SELECT * FROM user WHERE name="egoing" AND password="1111"; 이 true일 때,
    
    egoing의 정보가 출력된다.
    
    - > SELECT * FROM user WHERE name="egoing" AND password="1112";로 password가 틀렸을 때,
    
    egoing의 정보는 출력되지 않는다.
    
    - > SELECT * FROM user WHERE 1=1에서 1=1은 ture이기에, SELECT * FROM user처럼 모든 user의 목록이 출력된다.
    - > 이를 응용해서, SELECT * FROM user WHERE name="egoing" AND password="2222"; or 1=1; 하면
    
    password가 틀렸음에도 1=1이 ture이기에 egoing을 포함한 모든 user의 정보가 출력된다.
    
    +마찬가지로, php에서도 웹페이지 상에서 페스워드가 틀려도, <' or '1'='1> 라고 입력 시 ture값을 띄울 수 있다.
    
    + mysqli_real_escape_string($conn, $_GET['name'});
    
    를 이용해 회피할 수 있다.
    
    cmd 에러 해결이 필요하다....
    

# 라이브러리

- 라이브러리 1 : 개론
    
    + 중복의 제거를 통해 얻을 수 있는 효과
    
    - > 유지보수의 편의성 (하나의 파일만 수정하면 그것을 모든 곳에서 동시 수정 가능하게 한다.)
    - > 코드의 양 감소
    - > 가독성 향상
    
    + 소프트웨어에서의 코드란 제품과 유사하다.
    
    + 중복의 제거와 제거된 코드의 재사용은 맞닿아있다.
    
    + 프로그래밍에서의 라이브러리는 도서관과 같은 의미로, 중복해서 사용되는 로직을 재사용 할 수 있도록 분리한 것, 부품화 해서 재사용할 수 있도록 하는 것이 라이브러리.
    
    - > 수많은 파일들의 중복되는 코드들을 모아두는 것
    
    +db_init();
    
    - > init(initialization) : 초기화
    
    + index.php
    
    <?php
    
    require("lib/db.php");
    
    $conn = db_init();
    
    $result = mysqli_query($conn, "SELECT * FROM topic");
    
    ?>
    
    1. "lib/db.php" 파일이 필요하다는 구문에 db.php파일로 이동한다.
    
    3. db_init(); 이 실행되면 기억하고 있던 db.php에 연결되어
    
    6. db_init(); 함수는 $conn이라고 하는 변수를 리턴값으로 받는다.
    
    + db.php
    
    <?php
    
    function db_init(){
    
    $conn = mysqli_connect("localhost", "root", "kn6868595");
    
    mysqli_select_db($conn, "opentutorials");
    
    return $conn;
    
    }
    
    ?>
    
    2. index.php 파일의 요청에 따라 db.php를 읽으며, db_init(); 함수를 기억한다.
    
    4. $conn = mysqli_connect("localhost", "root", "kn6868595");
    
    mysqli_select_db($conn, "opentutorials");
    
    함수를 실행(database에 연결) 한다.
    
    5. 그리고 $conn에 쓰였던 정보를 $conn에 담겨 return(index.php로) 한다.
    
    + 이와 같은 과정은 api(db_init)를 하나 정의한 것.
    
    + 다만, 위와 같은 코드는 다수의 사용자가 사용하는 웹의 특성 상, id와 password 값이 고정되어 있지 않기에 한계가 크다.
    
    - > 비밀번호에 변수가 필요하다.
    
    + function db_init($host, #duser, #dpw, #dname)
    
    - > 이처럼, db_init() 함수의 가로 안에
    
    $localhost, #db user, #password, $dname 안이라는 변수를 추가하며,
    
    =>
    
    + <?php
    
    function db_init($host, #duser, #dpw, #dname){
    
    $conn = mysqli_connect($host, $duser, #dpw);
    
    mysqli_select_db($conn, $dname);
    
    return $conn;
    
    }
    
    ?>
    
    index.php의 구문도
    
- 라이브러리 2 : 직접 만들기
    
    +require(파일 위치);
    
    - > 해당 함수가 있는 에플리케이션이 동작하기 위해서는 가로 안에 있는 파일이 가로 안에 있는 위치에 있어야 한다는 의미.
    - -> require("lib/db.php");
    - --> lib 디렉토리 안의 db.php 파일이 필요하다.
    
    + require("config/config.php");
    
    require("lib/db.php");
    
    함수를 통해 코드를 호출함으로서 중복의 제거를 용이하게 할 수 있다.
    
    - > db.php 와 config.php 를 통해 약간의 실습
- 라이브러리 3-1 : Twitterbootstrap 소개
    
    + 다른 사람이 만든 라이브러리를 사용해서 에플리케이션을 만들자.
    
    - > 바퀴를 개발하지 말라. (다른 사람이 이미 바퀴를 만들었다.)
    
    + 트위터 부트스트랩 (Twitter Bootstrap)
    
    - > 3.3.4 버전 다운로드 (최신 버전은 5.1)
    - -> 수업 내용은 3.3.4버전 기준으로 진행되고, 중요한 것은 타인의 라이브러리를 이용하는 방식의 효율성에 있기 때문이다.
    - --> 버튼, 레이아웃 같은 것들을 직접 디자인하지 않아도, 정형화된 라이브러리를 사용할 수 있다.
    - ---> 지금까지 만든 사이트를 부트스트랩을 이용해서 개선해보자.
- 라이브러리 3-2 : Twitterbootstrap 삽입
    
    + 라이브러리에 관심을 가지는 것은 생산성을 향상시키는 중요한 요소
    
    - > 라이브러리에 관심을 가지는 것은 개발자의 본질에 가깝다
    
    ## + getting started에 있는 ([https://getbootstrap.com/docs/5.1/getting-started/introduction/](https://getbootstrap.com/docs/5.1/getting-started/introduction/)) Basic template 코드 확인.
    
    - > 부트스트랩을 적용시키기 위한 핵심(골격) 코드
    
    + 다운로드 받은 파일을 apache2 > htdoc 안에 압축풀기
    
    - > template 코드 확인 후 index.php 파일에 복사 붙여넣기
    - -> 영상과는 버전 업그레이드로 인한 차이점이 크다.
    - --> 정상 작동은 확인함.
- 라이브러리 3-3 : Twitterbootstrap 레이아웃
    
    + Grid system (디자인을 할 때 격자모양으로 가상의 선을 긋고, 레이아웃을 사용하는 컨셉.
    
    - > <div class="col-md-1">.col-md-1</div> 테그.
    - -> 그 테그들을 모아서, <div class="row"> 아래에 묶는다.
    
    + 영상에 나오는 1.html 참조
    
    - > index.php 파일 수정
    
    + 트위터 부트스트랩도 Javascript, html, css를 이용하기에, 그 셋의 범위 밖의 일을 할 수는 없다.
    
    - > 중요한 것은 편의성에 있다.
- 라이브러리 3-4 : Twitterbootstrap 세부디자인
    
    Twitterbootstrap 에 작성되어 있는 레이아웃을 클래스 네임을 지어주는 방식으로 활용할 수 있다.
    
    - > <header class="jumbotron">
    
    </header>
    
    - > class="img-circle" 과 같은 방식으로 활용한다.
    
    + 그 후, 개선된 이미지의 크기와 같은 세부조정은 CSS 파일을 통해 직접 조정한다.
    
    + text-center : 가운데 정렬
    
    +++ 중요한 것은 사소한 방법론이 아닌, 문제를 해결하는 과정.
    
    - > 부트스트랩에 있는 여러 샘플들을 보고, 요소 검사를 통해 어떤 테그가 어떤 이미지를 만드는지 보고, 적응한 뒤, 어떤 로직, 함수였는지 확인 해 보는 것.
- 라이브러리 3-5 : Twitterbootstrap 세부디자인
    
    + class="btn btn-default" 버튼 테그
    
    + <div class="btn-group" aria-label="..."> : 클래스 후 하나로 버튼을 묶어주는 테그
    
    + class="btn btn-success" :초록색 버튼
    
    + <hr> 테그 : 수평선을 만들어주는 테그./
    
    그 외 다양한 버튼 관련된 디자인을 부트스트랩에서 확인, 적용할 수 있다.
    

# 인터넷과 자가서버

- 인터넷과 자가서버 1 : IP와 도메인
    
    + IP 주소 (Internet Protocol Address)
    
    - > 각각의 플레이어들이 지켜야 하는 규칙이 IP, Internet Protocol.
    - -> 또한, 각각의 플레이어들이 정보를 주고 받기 위해서는 주소가 필요한데, 여기서의 주소가 Address.
    - --> 비유하자면 각각의 전화번호를 IP 주소라고 할 수 있다
    
    + cmd에서 ping opentutorials.org(주소)
    
    - > 명령어를 통해 IP 주소 (13.124.77.38)를 확인할 수 있다.
    - -> 그 후에는 crrl + c 버튼을 통해 빠져나올 수 있다.
    - --> 단, ip주소는 불변하는 것이 아닌 언제든 여러 사정으로 변경될 수 있다.
    
    + 접속하기 위해서는 서버 뿐만 아니라, 클라이언트도 IP 주소가 필요하다.
    
    - > 편지로 치면 우편 번호와 유사하다.
    
    + IP 주소로 입력 시, 서버의 HTML 코드를 해석 후 클라이언트에게 전송하는 것.
    
    + 컴퓨터는 도메인으로 접속하는 것이 아닌, IP 주소를 통해서만 접속할 수 있다.
    
    - > 이를 도메인으로 접속하게 해 주는 것이 DNS(Domain Name System).
    
    + 클라이언트가 도메인을 입력 하면, Name Server라는 DNS 서버 에 접속한 뒤, 도메인의 IP주소를 묻는다.
    
    - > 그러면 Name Server가 문의된 도메인의 주소를 클라이언트에게 응답한다.
    - -> 그 뒤 클라이언트가 확인한 IP주소로 원하는 서버에 접속하게 된다.
- 인터넷과 자가서버 2 : ipv 6
    
    자신의 ip(124.54.68.253)/index.php 를 UPL 주소에 입력하자
    
    - > 접속 안됨.
    - -> 공인 IP가 아닌 사설 IP를 쓰기 때문
    - --> IP는 0.0.0.0 ~ 255.255.255.255 사이의 주소값. (42억개)
    - ---> 컴퓨터, 스마트폰, 사물인터넷 등 IP주소가 필요한 경우가 많다.
    
    + 해결방법 1. IPv6
    
    - > 기존의 IPv4(124.54.68.253) 보다 훨씬 복잡함
    - -> IPv6로 만들 수 있는 주소의 경우의 수는 2의 128승.
    - --> 기존의 시스템이 있기에, 강의 시점에서는 IPv4와 IPv6가 동시에 사용되고 있음.
- 인터넷과 자가서버 3 : 포트
    
    IP 주소로 접속이 안된 이유는 공유기를 사용해서일 가능성이 높다.
    
    - > 하나의 공유기로 다수의 컴퓨터를 사용할 때, 다수의 컴퓨터와 공유기는 각각 별도의 ip 주소를 가진다.
    - -> MY IP로 검색해서 나오는 주소(124.54.68.253)는 컴퓨터의 IP가 아닌 공유기의 IP다.
    - --> 그렇기에 컴퓨터에 도달하지 못 해 접속이 되지 않은 것.
    - ---> 공유기의 IP가 공인 IP, 각각의 IP가 사설 IP.
    - ----> 사설 IP는 공유기의 공인 IP안에서만 유일하다. ( 동일한 IP가 다른 공인 IP안의 사설 IP로서 존재할 수 있다.)
    
    + 이와 같은 문제는 포트포워딩 (port forwarding)을 통해 해결할 수 있다.
    
    - > 공인 ip를 통해서 접속할 때, 사설 ip로 토스해주는 기능
    - -> 포트란? 클라이언트가 어떤 특정한 서버에 접속 했을 때, 정박할 수 있는 곳이라고 비유할 수 있다.
    
    + 222.109.62.43(오픈 튜토리얼 ip주소)에 접속할 때,
    
    - > [http://와](http://xn--ol5b/) .80(포트주소)이 사라지는 이유는 필요가 없어서가 아닌, 당연하기에 생략하는 것.
    - -> 웹서버는 주로 80번 포트에 설치되기 때문
    
    + cmd 사용할 때
    
    mysql -uroot -p -h222.109.62.43 -P3306
    
    - > 222.109.62.43 호스트의 3306포트로 접속
    
    포트 포워딩 : 사설 ip로 접속 했을 때, 공인 ip에서 사설 ip로 전달해주는 것.
    
- 인터넷과 자가서버 4 : 포트포워딩
    
    + 통신사에서 받은 케이블을 WAN 포트에 접촉 (공인 IP 부여)
    
    + LAN 1,2,3ㅢ 포트에 각각의 케이블로 각각의 컴퓨터에 연결 (사설 ip 부여)
    
    1. 공유기의 관리자에 접속. (iptime 기준, 내부 ip주소는 192.168.0.1 하지만 kt를 쓰고 있기에 cmd의 ipconfig 명령어로 확인한 ip는 172.30.1.254)
    
    - > 접속 시 보여지는 화면은 공유기가 보여주는 화면
    
    2. 고급 설정의 NAT/라우더 관리의 포트포워드 설정 진입.
    
    3. 사설 ip 주소 확인 (현재 사용하는 노트북 ip주소) : ipconfig 의 ipv4 주소 (172.30.1.10)
    
    4. 장치 설정의 트래픽 관리에서 포트 포워딩 설정 추가
    
    5. 이제 172.30.1.10/index.php로 접속 가능(외부에 열린 페이지가 된다.)
    
    +외부 포트는 외부에서 공유기로 들어오는 포트, 내부 포트는 공유기에서 컴퓨터로 들어가는 포트
    
- 인터넷과 자가서버 5 : 절대경로와 상대경로
    
    + 이전 ip 주소로 접속했던 페이지에서 링크를 누르면 localhost로 접속한다.
    
    - > 코드 상 링크에 localhost가 있기 때문
    - -> 링크의 localhost를 ip주소로 변경하면 ip주소로 접속하게 되지만, 이런 방식은 ip가 변경되거나 다른 호스트로 접속해야 하면 다시 주소를 변경해야 한다.
    
    + 위와 같은 상황에서 상대경로와 절대경로가 나온다.
    
    - > XX아파트 1202호가 절대경로라면, xx아파트 1201호에 사는 사람이 말하는 옆집이 상대경로.
    - -> 나의 위치와 무관하게 어떤 위치를 지정할 때 절대경로
    - --> 나의 위치에 따라 달라지는 경로를 표현할 때 상대경로
    
    +
    
    <a href="http://localhost/index.php">http://localhost/index.php</a>
    
    <a href="/index.php">index.php</a>
    
    - > 둘은 동일한 주소로 이동하는데, 이는 / 가 이 경로상에서 가장 최상위 디렉토리를 의미하기 때문이다.
    - -> 1.html의 최상위 디렉토리는 localhost. 그렇기위 둘은 동일한 경로.
    
    + ../index.php
    
    - > ../ 는 현재 위치한 디렉토리(/path)의 부모(localhst, 바로 앞 디렉토리) 테그를 의미.
    - -> ../index.php 는 localhost/index.php가 된다. (localhost/path/1.html로 접속했을 때. 172.30.1.10/path/1.html로 접속하면 172.30.1.10/index.php)
    
    즉.
    
    <a href="http://localhost/index.php">
    
    <a href= "/index.php">
    
    <a href= "../index.php">
    
    유저가 [http://172.30.1.10/path/1.html로](http://172.30.1.10/path/1.html%EB%A1%9C) 접속 했을 때, 1번은 localhost/index.php로 접속하지만
    
    2,3번은 172.30.1.10/index.php로 접속하게 되는 식.
    
    +./ 테그는 현재 디렉토리를 의미. ../테그는 부모 디렉토리. / 테그는 최상위 디렉토리
    
    <li><a href="http://localhost/path/sub/sub.html">http://localhost/path/sub/sub.html</a></li>
    
    <li><a href="/path/sub/sub.html">/path/sub/sub.html</a>"</li>
    
    <li><a href="./sub/sub.html">./sub/sub.html</a></li>
    
    <li><a href="sub/sub.html">sub/sub.html</a></li>
    
    위 4가지 코드는 동일한 위치를 가르킨다.
    
    + path/1.html 참고.
    
    + 172.30.1.10. IP주소만을 입력하면 172.30.1.10/index.html 로 접속한다.
    
    이는 암시적으로, html이 기본 대문페이지로 지정되어 있기 때문이다.
    
    쉽게 가는 방법은 기존의 index.html 파일을 삭제하는 것.
    
    그러면 172.30.1.10/index.php로 접속하게 된다.
    
    다른 방법은 비트나미 매니저를 통해 설정을 변경하는 방법도 있다.
    
- 인터넷과 자가서버 6 : 유동아이피와 DDNS
    
    유동 아이피 (dynamic address) : 동적인 IP, IP가 변하는 것.
    
    - > 컴퓨터를 장기간 사용하지 않으면, 통신사는 기존의 IP주소를 회수한 뒤 새로운 가입자에게 부여한다. 이 후 기존의 컴퓨터가 다시 컴퓨터를 사용하면 변경된 IP주소를 부여받게 된다.
    - -> 이와 같은 방식을 유동 아이피, Dynamic address라고 한다.
    - --> 이는 통신사가 가지고 있는 IP가 한정적이기 때문.
    - ---> 그렇기에 가정에서 서버를 운용하는 것은 적합하지 않다.
    - ----> 통신사에 추가비용을 지불하면 고정 IP를 받을 수 있다.
    
    + 이와 같은 문제를 해결하기 위한 기술이 DDNS(Dynamic DNS)
    
    - > DDNS를 설치하면 일정 시간에 한 번씩 네임서버에 접속해서 설치된 디바이스의 아이피를 알려준다.
    - -> 아이피가 변경되면, 변경된 IP를 알려주어 접속할 수 있게 해 준다.
    
    + 장치설정 - 부가 기능 - DDNS 설정을 통해 외부 이용자도 접속할 수 있도록 하는 도메인 네임을 설정할 수 있다.
    
    - > freedns.afraid.org 서비스를 이용하면 구입한 도메인을 DDNS로 사용할 수 있다.

# 호스팅

- 호스팅 1
    
    HOST : 인터넷에 접속해있는 하나하나의 컴퓨터
    
    HOSTING : 보통 정보를 제공하는 사업자, 서버쪽에서 사용되는 컴퓨터 또는 소프트웨어를 제공하는 사업자.
    
    - > IDC(Internet Data Center) : 아주 안전한 곳에, 자가발전과 네트워크도 원활한, 서버가 작동하기에 최적의 조건을 갖춘 공간.
    - -> 보안과 네트워크가 중요하다.
    - --> 이런 인프라를 갖추고, 인프라 안에서 서버 운영을 대행해주는 역할을 하는게 호스팅 사업.
    
    + 웹 호스팅 : 웹 어플리케이션을 운영하기 위한 모든 것을 제공하는 것.
    
    - > 웹 서버 (Apache, NGINX) + 미들웨어(PHP, Java, Python, Ruby) + 데이터베이스(MySQL, ORACLE, SQL Server) + 서버(물리적 서버)
    - -> 장점은 애플리케이션을 업로드만 하면 된다.
    - --> 단점은 웹 애플리케이션을 동작하는 용도로만 사용할 수 있다.
    
    (운영체제 레벨에서 접근해서 할 수 있는 여지가 없다.)
    
    +서버 호스팅 : 컴퓨터를 제공하는 것. (물리적 서버)
    
    - > 서버 컴퓨터를 제공해준다. (다른 운영프로그램등은 직접 설치해야한다.)
    - -> 장점은 모든 것을 할 수 있다, 자유도가 높아 활용도가 높다
    - --> 단점은 직접 서비스를 운영해야 한다는 것.
- 호스팅 2
    
    클라우드 컴퓨팅 : 인프라의 질적/양적 발전이라는 의미가 크다.
    
    - > 패러다임 시프팅은 아니지만, 질적 양적 변화가 급격해 패러다임이 바뀐 것만큼 큰 변화를 가져다 주는 것.
    
    클라우드의 중요 개념 : 가상화와 종량제
    
    + 종량제 : 쓰는 만큼 돈을 낸다.
    
    + 가상화란
    
    : 물리적 기계(컴퓨터) -> 운영체제 -> 가상머신(소프트웨어로 만든 기계) -> 운영체제
    
    - > 하나의 물리적 기계 위에 여러가지 운영체제를 설치해 여러가지 컴퓨터를 사용하는 것처럼 할 수 있다.
    - -> 대표적으로 VMWare, VirtualBox, Parallels 등의 프로그램이 있다
    
    = 윈도우 위에 VMWare 등을 이용해 리녹스나 맥을 설치하는 느낌
    
    + 클라우딩 컴퓨팅의 강력함은 하나의 강력한 컴퓨터를 분할해서 다수의 사용자에게 사용할 수 있도록 임대하는데 있다.
    
    - > 클라우딩 컴퓨팅 모델은 전통적인 모델과 달리, 낭비와 부족을 거의 없이 관리할 수 있다. (물리적 시간의 차이로 인한)
    
    + 직접 운영 : 컴퓨터, 운영체제, Platform, SOFRWARE 모두 담당
    
    + IaaS(infrastructure as a Service) : 컴퓨터, 운영체제는 업체가, Platform 과 SOFTWARE만 직접
    
    - > 대표적으로 KT U클라우드나 아마존의 웹 서비스 등이 있다.
    
    PasS(Platform as a Service) : 컴퓨터, 운영체제, Platform까지 업체가, SOFRWARE만 직접
    
    SaaS(Software as a Service) : 4가지 모두 업체가 담당. (유저는 서비스를 사용만 한다.)
    

# 성장(**Scalability)**

- 성장(Scalability) 1
    - 성장통을 어떻게 극복할 것인가.
    
    + 스케일, 스케일러빌리티(Scalability) : 규모, 좀 더 많은 규모를 수용할 수 있는 능력.
    
    + Scale UP : 하나의 컴퓨터가 강력해지는 것.
    
    - > 제네럴 셔먼 나무
    
    + Scale OUT : 적당한 크기의 여러대의 컴퓨터가 작동하는 것.
    
    - > 판도 나무
    
    + 지금까지의 모든 과정은 하나의 컴퓨터 위에서 작동했지만, 시스템의 거대화(스케일러빌리티)를 통해서 하나의 컴퓨터로는 불가능하게 되었다.
    
    - > 여러 대의 컴퓨터로 규모를 지탱할 필요가 생기는데, 그 과정과 방법에 대해 알아보는 것.
- 성장(Scalability) 2
    
    하나의 컴퓨터로 모든 트래픽을 감당할 수 없을 때, 여러 개의 컴퓨터의 필요성이 커진다.
    
    - > 보통 가장 많은 데이터를 차지하는 데이터베이스에 먼저 문제가 생기기 쉽고, 데이터베이스를 다른 컴퓨터에 분담하게 함으로써 문제를 해결한다.
    - > 기존의 컴퓨터에 있는 PHP 코드를 아래와 같이 수정한다.
    
    mysqli_connect{"COMPUTER 2", "root", "11111");
    
    - > 이 때 "COMPUTER2" 는 새로운 컴퓨터의 주소.
    - > 이것이 첫 번째 스케일 아웃.
    - -> 위와 같은 스케일 아웃의 단점은 네트워크를 통해 두 대의 컴퓨터가 PHP와 MySQL이 데이터를 주고받게 되는데, 이런 방식은 한 대의 컴퓨터에 비해 느릴 수밖에 없다.
    - > 그러나 이와 같은 방식이 이익이 크다.
    - > 또 다시 트래픽이 늘어감에 따라, 웹 서버와 PHP를 분할하는 스케일 아웃을 진행한다.
    - > 컴퓨터 3에 PHP를 설치하여 웹 서버와 PHP가 케이블을 통해 통신하도록 할 수 있다.
    
    + 각각 웹 서버, PHP, MySQL(데이터베이스) 이 분할됨에 따라
    
    COMPUTER3의 PHP는 애플리케이션 서버, COMPUTER2의 MySQL은 데이터베이스 서버라고 칭한다.
    
    + 데이터베이스 용 컴퓨터를 하나 더 구매한뒤, COMPUTER4라 칭한다. 또한 기존의 데이터를 복사한다.
    
    기존의 데이터베이스 서버는 MySQL Master, 새로 추가된 데이터베이스 서버는 MySQL SLLAVE로 칭한 뒤, PHP는 master에서는 쓰기 작업을, Slave에서는 읽기 작업을 진행함으로서 부담을 감소시킨다.
    
    - > 쓰기 작업은 데이터를 추가, 삭제, 수정하는 것을 의미한다.
    
    위와 같은 과정을 코드로 표현하면
    
    $master=mysqli_connect("computer2", "root", "111111")";
    
    $slave = mysqli_connect("computer4", "root", "111111")";
    
    - --
    
    mysqli_query($master, "INSERT INTO topic....");
    
    mysqli_query($master, "UPDATE...");
    
    mysqli_query($master, "DELETE FROM topic...");
    
    mysqli_query($slave, "SELECT*FROM topic");
    
    와 같은 형식이 된다.
    
    - > PHP 서버는 computer2와 computer4에 동시에 커넥트(접속) 하게 되는데, computer2는 $master라는 변수에 리턴값을 computer4는 $slave라는 변수에 리턴값을 가지게 된다.
    - -> INSERT, UPDATE, DELETE (추가,수정,삭제) 작업을 할 때는 $master 변수에,
    - -> SELECT(읽기) 작업을 할 때는 $slave 변수에 접속하여 작업을 수정하게 한다.
    
    + 쓰기 작업에는 골치 아픈 문제가 있는데, COMPUTER 2,4가 모두 쓰기 작업이 가능하다면
    
    많은 사람들이 PHP 에플리케이션을 이용해서 데이터베이스에 접속하는 상황에서
    
    누군가가 똑같은 토픽, 정보에 대해 COMPUTER 4에서 삭제를 하고 COMPUTER 2에서 정보를 업데이트를 하면
    
    COMPUTER 2는 존재하지 않는 정보에 대해 수정을 하려고 하는 상황이 발생한다. -> 버그
    
    그렇기에 데이터베이스는 한 대의 컴퓨터에서 쓰기를 전담하고, 다른 컴퓨터는 쓰기를 전담한 컴퓨터에 있는 내용을 복제함으로써 데이터가 중복으로 쓰기 작업이 일어나는걸 막는다고 볼 수 있다.
    
    + 트래픽이 또 추가되면 computer5를 구매 후, MySQL slave2를 지정한다.
    
    - > master가 변환되면 slave1,2 모두 master를 복사해 수정한다.
    - > PHP는 랜덤하게 Slave 1,2 에서 한번씩 정보를 읽어옴으로써 트래픽을 감소시킨다.
    - > 컴퓨터의 트래픽은 쓰기보다 읽기에서 훨씬 더 많이 발생한다.
    - > 그 뒤로는 slave 3,4,5,6 늘리기만 하면 스케일 아웃을 이룰 수 있게 된다.
    
    + master의 트래픽도 한계에 이르게 되면, 샤딩이라는 기술이 등장한다.
    
    - > 새로운 컴퓨터 (computer5)를 구입한 후, 두 개의 master 서버 모두 master DB를 설치한다.
    - > 그 후 하나의 마스터는 1~1000번 사이의 사용자들의 정보만을 저장
    - -> 또 다른 마스터는 1000~2000번 사이의 사용자들의 정보만을 저장
    - --> 저장된 정보가 줄어듬으로써 트래픽을 감소시킨다.
    
    + 그러나 샤딩은 복잡하고 사고의 가능성이 크기 때문에 몹시 어렵다.
    
    + 위와 같은 방식으로 데이터베이스는 Scalability를 확보 했다고 볼 수 있다.
    
    + PHP쪽을 스케일 아웃할 때는 새로운 컴퓨터 (COMPUTER 7)에 동일한 PHP를 생성한 뒤, 웹 서버에서 두 개의 서버를 번갈아가면서 접속하게 함에 따라 부하를 줄인다.
    
    - > 데이터베이스는 PHP에서 분산함으로써 부하를 줄이고, PHP는 웹 서버에서 분산함으로써 부하를 줄인다.
    - -> 추후 웹 서버도 스케일 아웃이 필요할 때, 그 부담을 분산시켲줄 것은 무엇인가.
- 성장(Scalability) 3
    
    _사용자가 서비스에 접속할 때, 그 순서는
    
    사용자가 도메인 입력 -> 네임 서버(DNS서버)에서 IP주소 확인 ->컴퓨터에게 전달 -> 받은 IP주소로 웹 서버 접속
    
    - > 이러한 방식에서 라운드 로빈이라는 방법을 사용할 수 있다.
    
    +기존의 웹 서버가 computer 1, 새로 스케일 아웃한 웹 서버가 computer2일 때
    
    computer 1,2의 IP주소는 다르므로, DNS 서버에서 사용자에게 computer1,2 의 ip주소를 번갈아 알려줌으로써 웹 서버의 부담을 줄일 수 있다.
    
    - > 이와 같은 방식이 라운드 로빈 방식
    
    + 또 다른 방식으로는 Load Balancer가 있다.
    
    - > 로드는 시스템에 걸리는 부하, 밸런서는 부하의 균형을 잡아주고 분산해주는 분배기와 같은 역할을 하는 소프트웨어 혹은 장치.
    - > 로드밸런서는 어떤 컴퓨터에 설치되어있는 소프트웨어일 수도 있고, 전용 장비일 수도 있다.
    - > 모든 사용자들이 로드밸런서에 먼저 접속 한뒤, computer 1,2 번에 분담해서 보냄으로서 부하를 감소시키는 방식.
    - > 장점은 로드밸런서가 각각의 웹서버를 감시함으로써, 각각의 컴퓨터가 가지고 있는 부담에 따라 트래픽을 분담해서 보낼 수 있다.
    
    + 클라우드 컴퓨팅은 기본적으로 로드밸런서를 제공한다.
    
    - > 이후 로드밸런서에 임대받은 컴퓨터들을 연결한다.
    - > 로드밸런서에 연결된 컴퓨터의 상태(CPU점유율같은)를 체크함으로써, 일정 수준의 부하(CPU점유율80%이상 10분 지속같은)가 계속되면 새로운 컴퓨터를 추가 배정함으로써 부담을 자동으로 줄일 수 있다.
    - > 마찬가지로, 점유율이 떨어지면 배정받았던 컴퓨터를 순차적으로 삭제함으로서 낭비를 줄일 수 있다.
    
    + Scalability는 규모가 커짐으로써 더 많은 컴퓨팅 파워를 배분하는 것 뿐만 아니라, 작아진 트래픽에 맞춰 파워를 줄임으로서 비용을 줄이는 것 또한 Scalavbility의 중요한 역할 중 하나.