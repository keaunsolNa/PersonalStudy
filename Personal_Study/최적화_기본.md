# 최적화 기본

![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled.png)

- 옵티마이저와 실행 계획
    - 개념
        
        <aside>
        💡 최적화란 행동을 할 때, 어떻게 할 것인지를 정하는 것. 
        → 성능 모델링과는 다르다. SQL문을 실행할 때, 어떻게 하면 효율적으로 할 수 있을지에 대한 고민이 최적화이며, 최적화를 하는 기계가 옵티마이저.
        → 옵티마이저의 핵심은 SQL문을 실행하기 “전”에 최적의 실행계획을 찾는 것.
        
        </aside>
        
        - 옵티마이저는 하나의 프로세스인 만큼, 시행하는데 시간이 걸린다.  비용을 계산하는 과정을 감수할 필요가 있을 때 시항하는 것. 인덱스와 유사한 의미로 생각하자.
    - 규칙 기반 옵티마이저
        - 정의
            - RBO, Rule-Based Optimizer
            - 규칙에 기반하여 옵티마이저를 구동한다.
            - 거의 사용하지는 않지만, 하위 버전 호환성을 위해 유지한다.
            - 규칙기반 옵티마이저는 이미 규칙이 규정되어있으며, 그 규칙에 맞춰서 시행된다.
            - 규칙기반 옵티마이저의 한계 
            → 몇 개의 규칙만으로 현실의 모든 상황을 설명하기 어렵다.
            → SQL문 처리에 예상되는 비용(소요시간, 자원사용량)을 최소화하기 위한 방법 필요
            → 테이블, 인덱스, 컬럼 등의 객체에 대한 통계정보, 시스템 통계정보 활용
            → 통계정보, DBMS 버전, DBMS 설정 정보에 따라 동일한 SQL문도 서로 다른 실행계획이 생성될 수 있다.
                - 정확한 통계정보 관리는 비용기반 최적화의 중요 요소
        - 중요 특징
            - Full Table Scan(FTS)
                - 테이블 내의 모든 데이터를 읽어가면서 조건을 검색한다.
                - 고수위 마크(HWM, High Water Mark) 아래의 모든 블록을 읽으므로 시간이 많이 소요된다.
                - HVM은 데이터 저장단위의 표시줄 같은 역할. 데이터가 INSERT될 때, 5개의 데이터 블록 단위로 구성된
                    
                    ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%201.png)
                    
                - 병렬처리 방식.
                - 다음의 경우 옵티마이저는 FTS를 선택한다.
                → SQL문에 조건이 존재하지 않는 경우 
                → SQL문 조건에 사용 가능한 인덱스가 없는 경우
                → 조건을 만족하는 데이터가 매우 많은 경우 (옵티마이저가 선택한다.)
                    → 인덱스 스캔은 한 번의 I/O요청에 한 Block 단위로 데이터를 읽는다.
                    → FTS는 한 번의 I/O요청으로 여러 Block을 동시에 읽는다.
                → 병렬 처리 방식으로 처리하는 경우
            
            ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%202.png)
            
            - Single row by Rowid : 
            ROWID를 통해서 테이블에서 하나의 행을 액세스한다. 
            → ROWID : 데이터 베이스 테이블에서 단일 행을 고유하게 정의하는 의사 열 
            → 의사 열 : 데이터베이에서 저장된 열을 참조하는 것처럼, 쿼리의 WHERE 절에서 참조할 ROWID. (Placeholder와 유사한 개념으로 이해하자. )
            - Single row by unique or primary key : 
            Unique index를 통해서 하나의 행을 엑세스하는 방식 
            → 인덱스를 먼저 엑세스하고, 인덱스의 ROWID를 추출해서 행을 엑세스한다.
            - Composite index : 
            복합 인덱스로 검색하는 경우 사용하는 Index
            복합키처럼 다수의 인덱스를 통해 행에 엑세스한다.
            → 인덱스 매칭률이 높을수록 우선
            → 인덱스 매칭률이 동일하면, 구성 칼럼이 많을수록 우선.
            - 위 이미지에서 index1은 2/3, index2는 2/2. 따라서 아래 인덱스의 매칭률이 높다.
                - 인덱스 매칭률
                    
                    ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%203.png)
                    
                    ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%204.png)
                    
            - Single column index :
            단일 컬럼 인덱스에 = 조건으로 검색
            - Bounded range search on indexed columns :
            인덱스가 생성되어 있는 컬럼에 양쪽 범위를 한정하는 형태로 검색한다. 
            → LIKE, BETWEEN
            —> X BETWEEN ‘10’ AND ‘20’
            - Unbounded range search on indexed columns : 
            인덱스가 생성되어 있는 컬럼에 한쪽 범위만 한정하는 형태로 검색한다.
            → >, ≥, <, ≤
            —> A > 10
                
                ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%205.png)
                
            
            <aside>
            💡 비용 기반 옵티마이저에는 COST 명령어가 포함된다. 규칙기반과 비용기반 옵티마이저를 구분하는 가장 쉬운 방법은 COST의 존재 유무
            
            </aside>
            
    - 비용 기반 옵티마이저
        - 정의
            - CBO, Cost-Based Optimizer
            - 비용 기반 옵티마이저는 통계(딕셔너리)에 기반해서 시행된다.
            - 따라서 통게에 기반하여 비용이 많이 드는 방식과 적게 드는 방식을 선정, 적게 드는 방식으로 진행된다.
            - 비용 기반 옵티마이저는 기본적으로 규칙 기반 옵티마이저의 한계를 벗어나고자 만들어졌다.
        - 구조
            
            ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%206.png)
            
            - 질의 변환기 : SQL문을 보다 작업이 용이한 형태로 변환
            - 대안 계획 생성기 : 동일한 결과를 생성하는 다양한 대안 계획 생성
            → 가능한 모든 계획을 생성하지는 않으므로(리소스 낭비), 최적 대안이 누락되는 경우도 있음
            - 비용 예측기 : 다양한 통계정보를 활용하여 대안 계획의 비용 예측
        - 실행 계획
            
            ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%207.png)
            
            - 조인 기법 : NL Join, Sort Merge Join, Hash Join등을 사용한다.
            - 엑세스 기법 : Index Scan, Full Table Scan의 방식으로 인덱스 스캔
            - 최적화 정보 :
            → 최적화 정보는 실제 실행 결과가 아닌, 통계 정보(딕셔너리)바탕의 에측치다.
            → Cost : 상대적인 비용 정보 (숫자가 낮을수록 유리)
            → Card : 주어진 조건을 만족하는 행의 수 (숫자가 낮을수록 유리)
            → Bytes : 결과 집합이 차지하는 메모리의 양 (숫자가 낮을수록 유리)
- 인덱스
    - 인덱스 정의
        - 인덱스는 검색 속도 향상을 위한 기술.
    - B-Tree 인덱스
        
        <aside>
        💡 B-Tree 구조는 데이터의 DML 작업이 복잡하다.
        
        </aside>
        
        ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%208.png)
        
        - 일치(=)검색과 범위(BETWEEN, <>)검색에 모두 적합하다.
        - Root Block
            - Branch Block 중 최상위
        - Branch Block
            - 분기를 목적으로 한다.
            - 다음 단계를 가지는 포인터를 가지고 있다.
        - Leaf Block
            - 분기의 가장 아래 단계
            - 인덱스 구성 컬럼의 데이터와 해당 행의 위치를 가리키는 식별자로 구성된다.
            → Range 검색 시 최초 행을 찾은 뒤, 최초행을 기준으로 범위 검색이 진행된다. (15~20 범위를 찾을 때, Root Block에서 15번을 찾은 뒤, 15번에서 20번까지 옆으로 가면서 찾는 것.)
            - Leaf Block간 양방향 링크를 가지고 있다. → 오름 차순, 내림 차순으로 검색 가능한 이유
        
        ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%209.png)
        
    - index Scan
        - Index Unique Scan
            - Unique index를 사용하여 단 하나의 데이터를 추출하는 방식이다.
            - Index 구성 컬럼에 조건이 모두 ‘=’로 주어진 경우 사용한다.
            - 둘 중 하나라도 위배되면 Index Range Scan으로 넘어간다.
        - Index Range Scan
            - 한 건 이상의 데이터를 추출하는 방식
            - Non-Unique Index를 이용하는 경우
            - Index 구성 컬럼에 ‘=’이외의 조건이 주어진 경우
- 조인 수행 원리 (튜닝 Big3 Join)
    
    <aside>
    💡 최적화에서의 조인은 테이블과 테이블 사이의 조인이 아닌, 조인을 어떻게 수행할 것인가에 대한 문제.
    → 각 조인은 단계별로 다른 조인을 적용 가능하다.
    
    </aside>
    
    - NL join
        
        ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%2010.png)
        
        - 선행 테이블(외부 테이블)과 후행 테이블(내부 테이블) 조인
        → 선행과 후행은 이중 for문을 생각하자.
        - 선행 테이블의 조건을 만족하는 행 추출 → 후행 데이터를 읽으면서 조인
        → 이 과정을 선행 테이블의 조건을 만족하는 행 수만큼 반복
        - 결과 행의 수가 적은 테이블을 조인 순서상 선행 테이블로 두는 것이 유리
        - 소규모 데이터 인덱스를 사용하여 작업하는 OLTP 업무에 적합하다.
        - 연결 조건 인덱스 및 드라이빙 테이블의 우선순위에 따라 성능이 결정된다.
    - Sort Merge Join
        
        ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%2011.png)
        
        - 조인 칼럼 기준으로 데이터를 정렬한 후 조인을 수행한다.
        - 정렬할 데이터가 많은 경우에는 성능이 저하된다.
        - Non-Equl 조인이 가능하다. (정렬이 되어있기 때문에)
        - 위 그림의 경우, (Equl Join)
        1번은 연봉이 1억 이상인 직원만 SELECT
        2번은 뽑아온 결과 집합을 사번을 기준으로 정렬
        3번(가장 우측 테이블)은 배기량 2000cc 이상인 차량만 SELECT
        4번은 뽑아온 결과 집합을 사번을 기준으로 정렬
        5. 두 테이블의 일치 여부(EQUL) 판별 후 5번 결과집합으로 출력
        - 인덱스를 사용하지 않으며, Non-Equl Join도 가능하다.
        - 정렬 수행에 비용이 소요된다.
    - Hash join
        
        <aside>
        💡 해쉬 함수는 긴 자릿수를 짧은 자릿수로 매핑하는 것.
        
        </aside>
        
        ![Untitled](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%A5%E1%86%A8%E1%84%92%E1%85%AA%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%2027fa1b044c774ef28b4431e2cb70d444/Untitled%2012.png)
        
        - 조인 칼럼 기준으로 해쉬 함수를 수행하여, 동일한 해쉬 값을 갖는 경우에만 실제 값을 비교하여 조인을 수행한다.
        - 해쉬 테이블을 메모리에 생성해야 한다.
        → 결과 행의 수가 적은 테이블을 선행 테이블(Build Input)로 사용하는 것이 좋다.
        → Build Input(선행), Probe Input(후행)
        - 해쉬 비교는 아래와 같은 방식으로 진행된다. 
        123456과 998877, 222256, 123456를 비교할 때, 해쉬값인 56과 77, 56, 56을 비교한 뒤, 77은 탈락하고, 222256과 123456만으로 비교를 수행한다.
        - 위 그림을 기준으로 볼 때, Probe Input에서 추출해온 1번 값을 A버킷과 비교하고, A 버킷안에 값이 없으면 B버킷에서 비교하는 것이 아니라 패스한다. 이후 2번 값을 A버킷과 비교하고, 일치하는 값이 있으면 B→C→D 버킷 순으로 비교하는 식
        - NL Join처럼 결과 행의 수가 적은 테이블로 많은 테이블과 비교하는 것이 성능 면에서 좋다.
        - Equl Join만 가능하며, 데이터가 많은 경우 유리하다.
        - 해쉬 함수 계산에 비용이 소모된다.
        - 결과 행의 수가 적은 테이블을 선행 테이블로 사용하는 경우 성능이 향상된다.